\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory}{}\section{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory Class Reference}
\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory}\index{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory@{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory}}


Inheritance diagram for edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=299pt]{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=299pt]{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_aa71d30215a0783c82208524f0b0f179e}{}{\bfseries Immutable\+Memory\+Unit\+Factory} (Symbolic\+Universe universe, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1ModelFactory}{Model\+Factory} factory)\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_aa71d30215a0783c82208524f0b0f179e}

\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitSet}{Immutable\+Memory\+Unit\+Set} \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3b11943ce391ee5ee59de7d853411868}{canonic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set)
\begin{DoxyCompactList}\small\item\em Return the \char`\"{}canonical\char`\"{} version of the given memory unit set. \end{DoxyCompactList}\item 
boolean \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a678985ac788be90be3ef7be8e9c52ae4}{is\+Joint} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnit}{Memory\+Unit} mu1, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnit}{Memory\+Unit} mu2)
\begin{DoxyCompactList}\small\item\em This is an over-\/approximation method to test if two memory units have any intersection. \end{DoxyCompactList}\item 
boolean \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3e87e2a3a73bd681f21e05ff2ef79e67}{is\+Joint} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnit}{Memory\+Unit} mu)
\begin{DoxyCompactList}\small\item\em This is an over-\/approximation method of membership testing. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitSet}{Immutable\+Memory\+Unit\+Set} \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_af6097f29066b0c80acc325011594756f}{union} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set1, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set2)
\begin{DoxyCompactList}\small\item\em This is an over-\/approximation method of union. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitSet}{Immutable\+Memory\+Unit\+Set} \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a322588182c0edbbd76d8f86aa2cf9fd2}{intersects} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set1, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set2)
\begin{DoxyCompactList}\small\item\em This is an over-\/approximation method of intersection. \end{DoxyCompactList}\item 
void \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a410154869f968ce72dca60cefb4d6a34}{add} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnit}{Memory\+Unit} mu)
\begin{DoxyCompactList}\small\item\em Adds a memory unit to a memory unit set. \end{DoxyCompactList}\item 
\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_ac508a007149ebc7ddb49070882affc2f}{}void {\bfseries add} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set, Symbolic\+Expression pointer)\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_ac508a007149ebc7ddb49070882affc2f}

\item 
\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_ae711e61d4e24d789a29a6b35c3aa2157}{}\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnit}{Immutable\+Memory\+Unit} {\bfseries new\+Memory\+Unit} (int dyscope\+I\+D, int var\+I\+D, Reference\+Expression reference)\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_ae711e61d4e24d789a29a6b35c3aa2157}

\item 
\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a6c3537c5434bc00c9afbe6de8bf9ba40}{}\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitSet}{Immutable\+Memory\+Unit\+Set} {\bfseries new\+Memory\+Unit\+Set} ()\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a6c3537c5434bc00c9afbe6de8bf9ba40}

\item 
boolean \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a4cf134a224506d07117547bd1c8c05ae}{is\+Joint} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set1, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitSet}{Memory\+Unit\+Set} mu\+Set2)
\begin{DoxyCompactList}\small\item\em This is an over-\/approximation method to test if two memory unit sets have any intersection. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a410154869f968ce72dca60cefb4d6a34}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!add@{add}}
\index{add@{add}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{add}]{\setlength{\rightskip}{0pt plus 5cm}void edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+add (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set, }
\item[{{\bf Memory\+Unit}}]{mu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a410154869f968ce72dca60cefb4d6a34}


Adds a memory unit to a memory unit set. 


\begin{DoxyParams}{Parameters}
{\em mu\+Set} & the memory unit set which is to be added to a new element \\
\hline
{\em mu} & the memory unit to be added to the given memory unit set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new memory unit set after adding the given memory unit 
\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_a45c2d19cbc76ed74d1cb8531c96628a4}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3b11943ce391ee5ee59de7d853411868}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!canonic@{canonic}}
\index{canonic@{canonic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{canonic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+Memory\+Unit\+Set} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+canonic (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3b11943ce391ee5ee59de7d853411868}


Return the \char`\"{}canonical\char`\"{} version of the given memory unit set. 

The memory unit set returned will satisfy all of the following\+: 
\begin{DoxyItemize}
\item it will be observationally equivalent to the given memory unit set, i.\+e., there is no way a C\+I\+V\+L-\/\+C program can distinguish between the two memory unit sets 
\item the memory unit set returned will be the unique representative of its equivalence class, i.\+e., if this method is invoked with two equivalent memory unit sets, it will return the same object 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em mu\+Set} & any non-\/null memory unit set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the canonical version of the given memory unit set 
\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_a92b22a4500dc9fe09628f1c2c9bcd2fb}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a322588182c0edbbd76d8f86aa2cf9fd2}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!intersects@{intersects}}
\index{intersects@{intersects}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{intersects}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+Memory\+Unit\+Set} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+intersects (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set1, }
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a322588182c0edbbd76d8f86aa2cf9fd2}


This is an over-\/approximation method of intersection. 

It always returns a super set of the intersection of the given memory unit sets.


\begin{DoxyParams}{Parameters}
{\em mu\+Set1} & the first memory unit set \\
\hline
{\em mu\+Set2} & the second memory unit set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_a08f26ce4f2067fd0e1105dd277fa841c}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a678985ac788be90be3ef7be8e9c52ae4}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!is\+Joint@{is\+Joint}}
\index{is\+Joint@{is\+Joint}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{is\+Joint}]{\setlength{\rightskip}{0pt plus 5cm}boolean edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+is\+Joint (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit}}]{mu1, }
\item[{{\bf Memory\+Unit}}]{mu2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a678985ac788be90be3ef7be8e9c52ae4}


This is an over-\/approximation method to test if two memory units have any intersection. 

It returns true if the two memory units may or may N\+O\+T have any intersection.


\begin{DoxyParams}{Parameters}
{\em mu1} & the first memory unit \\
\hline
{\em mu2} & the second memory unit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_a1f654eef9c72122cb334ecbef1658db1}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3e87e2a3a73bd681f21e05ff2ef79e67}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!is\+Joint@{is\+Joint}}
\index{is\+Joint@{is\+Joint}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{is\+Joint}]{\setlength{\rightskip}{0pt plus 5cm}boolean edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+is\+Joint (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set, }
\item[{{\bf Memory\+Unit}}]{mu}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a3e87e2a3a73bd681f21e05ff2ef79e67}


This is an over-\/approximation method of membership testing. 

If mu\+Set doesn\textquotesingle{}t contain mu, returns false. If mu\+Set may or may not contain mu, returns true.


\begin{DoxyParams}{Parameters}
{\em mu\+Set} & the memory unit set \\
\hline
{\em mu} & the memory unit to be tested for membership \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if the given memory unit set does not contain the given memory unit; returns true if it may or may not contain the memory unit. 
\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_ad25e0cb6162a6fe07379609bc5433743}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a4cf134a224506d07117547bd1c8c05ae}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!is\+Joint@{is\+Joint}}
\index{is\+Joint@{is\+Joint}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{is\+Joint}]{\setlength{\rightskip}{0pt plus 5cm}boolean edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+is\+Joint (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set1, }
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_a4cf134a224506d07117547bd1c8c05ae}


This is an over-\/approximation method to test if two memory unit sets have any intersection. 

It returns true if the two memory unit sets may or may N\+O\+T have any intersection.


\begin{DoxyParams}{Parameters}
{\em mu\+Set1} & the first memory unit \\
\hline
{\em mu\+Set2} & the second memory unit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_aaf39bdf7b5a765f3912aac91c88bebb5}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.

\hypertarget{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_af6097f29066b0c80acc325011594756f}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}!union@{union}}
\index{union@{union}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::common\+::immutable\+::\+Immutable\+Memory\+Unit\+Factory}}
\subsubsection[{union}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+Memory\+Unit\+Set} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+Memory\+Unit\+Factory.\+union (
\begin{DoxyParamCaption}
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set1, }
\item[{{\bf Memory\+Unit\+Set}}]{mu\+Set2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMemoryUnitFactory_af6097f29066b0c80acc325011594756f}


This is an over-\/approximation method of union. 

It always returns a super set of the union of the given memory unit sets.


\begin{DoxyParams}{Parameters}
{\em mu\+Set1} & the first memory unit set \\
\hline
{\em mu\+Set2} & the second memory unit set \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory_a8142f2c1e6ef3c9bfbe12355ffe3f133}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+Memory\+Unit\+Factory}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/arnabd/workspace/civl/trunk/src/edu/udel/cis/vsl/civl/state/common/immutable/Immutable\+Memory\+Unit\+Factory.\+java\end{DoxyCompactItemize}
