\hypertarget{brilliantrussian_8h}{}\section{/home/arnabd/workspace/civl/trunk/examples/omp/m4ri/m4ri/brilliantrussian.h File Reference}
\label{brilliantrussian_8h}\index{/home/arnabd/workspace/civl/trunk/examples/omp/m4ri/m4ri/brilliantrussian.\+h@{/home/arnabd/workspace/civl/trunk/examples/omp/m4ri/m4ri/brilliantrussian.\+h}}


M4\+R\+I and M4\+R\+M.  


{\ttfamily \#include $<$math.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$m4ri/mzd.\+h$>$}\\*
{\ttfamily \#include $<$m4ri/mzp.\+h$>$}\\*
Include dependency graph for brilliantrussian.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{brilliantrussian_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{brilliantrussian_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{brilliantrussian_8h_a7c80eeffdf54a6ec67d70d8f54d913db}{mzd\+\_\+make\+\_\+table} (\hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} r, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} c, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$T, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} $\ast$L)
\begin{DoxyCompactList}\small\item\em Constructs all possible $2^k$ row combinations using the gray code table. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_a74df420e46e0e6548042c33cbe43fd8d}{mzd\+\_\+process\+\_\+rows} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L)
\begin{DoxyCompactList}\small\item\em The function looks up k bits from position i,startcol in each row and adds the appropriate row from T to the row i. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_a210dfd5b2353fbaa1ecbf14b0209cc07}{mzd\+\_\+process\+\_\+rows2} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T0, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L0, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T1, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L1)
\begin{DoxyCompactList}\small\item\em Same as mzd\+\_\+process\+\_\+rows but works with two Gray code tables in parallel. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_abdff0368957f4041c353763874c7130a}{mzd\+\_\+process\+\_\+rows3} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T0, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L0, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T1, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L1, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T2, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L2)
\begin{DoxyCompactList}\small\item\em Same as mzd\+\_\+process\+\_\+rows but works with three Gray code tables in parallel. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_a78967f819694d02fde80b970d24e0a9b}{mzd\+\_\+process\+\_\+rows4} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T0, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L0, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T1, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L1, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T2, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L2, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T3, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L3)
\begin{DoxyCompactList}\small\item\em Same as mzd\+\_\+process\+\_\+rows but works with four Gray code tables in parallel. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_a2a7a3cd746cfd98dcf885b8df2a69217}{mzd\+\_\+process\+\_\+rows5} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T0, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L0, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T1, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L1, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T2, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L2, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T3, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L3, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T4, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L4)
\begin{DoxyCompactList}\small\item\em Same as mzd\+\_\+process\+\_\+rows but works with five Gray code tables in parallel. \end{DoxyCompactList}\item 
void \hyperlink{brilliantrussian_8h_ada7254c182115459c300f599f81145cd}{mzd\+\_\+process\+\_\+rows6} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} endrow, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} startcol, int k, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T0, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L0, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T1, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L1, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T2, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L2, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T3, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L3, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T4, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L4, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$T5, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} const $\ast$L5)
\begin{DoxyCompactList}\small\item\em Same as mzd\+\_\+process\+\_\+rows but works with six Gray code tables in parallel. \end{DoxyCompactList}\item 
\hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} \hyperlink{brilliantrussian_8h_a317ffc5fe030481a6ee5e3c542b78c85}{\+\_\+mzd\+\_\+echelonize\+\_\+m4ri} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$\hyperlink{structA}{A}, const int full, int k, int heuristic, const double threshold)
\item 
void \hyperlink{brilliantrussian_8h_ab8fb672b3ce0ef365a40c8f6127ba074}{mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$M, int k)
\begin{DoxyCompactList}\small\item\em Given a matrix in upper triangular form compute the reduced row echelon form of that matrix. \end{DoxyCompactList}\item 
\hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} \hyperlink{brilliantrussian_8h_ad7d8c85656a410ce4f04675ae583224a}{\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$\hyperlink{structA}{A}, int k, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} r, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} c, \hyperlink{misc_8h_a03971b7935a6bc6fb77e74988850a136}{rci\+\_\+t} max\+\_\+r)
\begin{DoxyCompactList}\small\item\em Given a matrix in upper triangular form compute the reduced row echelon form of that matrix but only start to do anything for the pivot at (r,c). \end{DoxyCompactList}\item 
\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$ \hyperlink{brilliantrussian_8h_aaba0eb0110d8c8a3350e21b5f647d388}{mzd\+\_\+inv\+\_\+m4ri} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$dst, const \hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$src, int k)
\begin{DoxyCompactList}\small\item\em Invert the matrix src using Konrod\textquotesingle{}s method. \end{DoxyCompactList}\item 
\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$ \hyperlink{brilliantrussian_8h_ac89b0377af93051bc8cd3a0cb57e8c17}{mzd\+\_\+mul\+\_\+m4rm} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$C, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$\hyperlink{structA}{A}, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$B, int k)
\begin{DoxyCompactList}\small\item\em Matrix multiplication using Konrod\textquotesingle{}s method, i.\+e. \end{DoxyCompactList}\item 
\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$ \hyperlink{brilliantrussian_8h_a7b054433be6b71e1c613f64057d56031}{mzd\+\_\+addmul\+\_\+m4rm} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$C, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$\hyperlink{structA}{A}, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$B, int k)
\begin{DoxyCompactList}\small\item\em Set C to C + A\+B using Konrod\textquotesingle{}s method. \end{DoxyCompactList}\item 
\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$ \hyperlink{brilliantrussian_8h_a216539b395a38c1a449fd00dc1916b7e}{\+\_\+mzd\+\_\+mul\+\_\+m4rm} (\hyperlink{structmzd__t}{mzd\+\_\+t} $\ast$C, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$\hyperlink{structA}{A}, \hyperlink{structmzd__t}{mzd\+\_\+t} const $\ast$B, int k, int clear)
\begin{DoxyCompactList}\small\item\em Matrix multiplication using Konrod\textquotesingle{}s method, i.\+e. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
M4\+R\+I and M4\+R\+M. 

\begin{DoxyAuthor}{Author}
Gregory Bard \href{mailto:bard@fordham.edu}{\tt bard@fordham.\+edu} 

Martin Albrecht \href{mailto:martinralbrecht@googlemail.com}{\tt martinralbrecht@googlemail.\+com}
\end{DoxyAuthor}
\begin{DoxyNote}{Note}
For reference see Gregory Bard; Accelerating Cryptanalysis with the Method of Four Russians; 2006; \href{http://eprint.iacr.org/2006/251.pdf}{\tt http\+://eprint.\+iacr.\+org/2006/251.\+pdf} 
\end{DoxyNote}


\subsection{Function Documentation}
\hypertarget{brilliantrussian_8h_a317ffc5fe030481a6ee5e3c542b78c85}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!\+\_\+mzd\+\_\+echelonize\+\_\+m4ri@{\+\_\+mzd\+\_\+echelonize\+\_\+m4ri}}
\index{\+\_\+mzd\+\_\+echelonize\+\_\+m4ri@{\+\_\+mzd\+\_\+echelonize\+\_\+m4ri}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{\+\_\+mzd\+\_\+echelonize\+\_\+m4ri}]{\setlength{\rightskip}{0pt plus 5cm}{\bf rci\+\_\+t} \+\_\+mzd\+\_\+echelonize\+\_\+m4ri (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{A, }
\item[{const int}]{full, }
\item[{int}]{k, }
\item[{int}]{heuristic, }
\item[{const double}]{threshold}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a317ffc5fe030481a6ee5e3c542b78c85}
\begin{DoxyParagraph}{General algorithm}
\begin{DoxyItemize}
\item Step 1.\+Denote the first column to be processed in a given iteration as $a_i$. Then, perform Gaussian elimination on the first $3k$ rows after and including the $i$-\/th row to produce an identity matrix in $a_{i,i} ... a_{i+k-1,i+k-1},$ and zeroes in $a_{i+k,i} ... a_{i+3k-1,i+k-1}$.\end{DoxyItemize}
\begin{DoxyItemize}
\item Step 2. Construct a table consisting of the $2^k$ binary strings of length k in a Gray code. Thus with only $2^k$ vector additions, all possible linear combinations of these k rows have been precomputed.\end{DoxyItemize}
\begin{DoxyItemize}
\item Step 3. One can rapidly process the remaining rows from $i + 3k$ until row $m$ (the last row) by using the table. For example, suppose the $j$-\/th row has entries $a_{j,i} ... a_{j,i+k-1}$ in the columns being processed. Selecting the row of the table associated with this k-\/bit string, and adding it to row j will force the k columns to zero, and adjust the remaining columns from $ i + k$ to n in the appropriate way, as if Gaussian elimination had been performed.\end{DoxyItemize}
\begin{DoxyItemize}
\item Step 4. While the above form of the algorithm will reduce a system of boolean linear equations to unit upper triangular form, and thus permit a system to be solved with back substitution, the M4\+R\+I algorithm can also be used to invert a matrix, or put the system into reduced row echelon form (R\+R\+E\+F). Simply run Step 3 on rows $0 ... i-1$ as well as on rows $i + 3k ... m$. This only affects the complexity slightly, changing the 2.\+5 coeffcient to 3.\end{DoxyItemize}

\end{DoxyParagraph}
\begin{DoxyAttention}{Attention}
This function implements a variant of the algorithm described above. If heuristic is true, then this algorithm, will switch to P\+L\+U\+Q based echelon form computation once the density reaches the threshold.
\end{DoxyAttention}
\hypertarget{brilliantrussian_8h_a216539b395a38c1a449fd00dc1916b7e}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!\+\_\+mzd\+\_\+mul\+\_\+m4rm@{\+\_\+mzd\+\_\+mul\+\_\+m4rm}}
\index{\+\_\+mzd\+\_\+mul\+\_\+m4rm@{\+\_\+mzd\+\_\+mul\+\_\+m4rm}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{\+\_\+mzd\+\_\+mul\+\_\+m4rm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mzd\+\_\+t}$\ast$ \+\_\+mzd\+\_\+mul\+\_\+m4rm (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{C, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{A, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{B, }
\item[{int}]{k, }
\item[{int}]{clear}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a216539b395a38c1a449fd00dc1916b7e}


Matrix multiplication using Konrod\textquotesingle{}s method, i.\+e. 

compute C such that C == A\+B.

This is the actual implementation.

This function is described in Martin Albrecht, Gregory Bard and William Hart; Efficient Multiplication of Dense Matrices over G\+F(2); pre-\/print available at \href{http://arxiv.org/abs/0811.1714}{\tt http\+://arxiv.\+org/abs/0811.\+1714}


\begin{DoxyParams}{Parameters}
{\em C} & Preallocated product matrix. \\
\hline
{\em \hyperlink{structA}{A}} & Input matrix \hyperlink{structA}{A} \\
\hline
{\em B} & Input matrix B \\
\hline
{\em k} & M4\+R\+I parameter, may be 0 for auto-\/choose. \\
\hline
{\em clear} & clear the matrix C first\\
\hline
\end{DoxyParams}
\begin{DoxyAuthor}{Author}
Martin Albrecht -- initial implementation 

William Hart -- block matrix implementation, use of several Gray code tables, general speed-\/ups
\end{DoxyAuthor}
\begin{DoxyReturn}{Returns}
Pointer to C. 
\end{DoxyReturn}
The algorithm proceeds as follows\+:

Step 1. Make a Gray code table of all the $2^k$ linear combinations of the $k$ rows of $B_i$. Call the $x$-\/th row $T_x$.

Step 2. Read the entries $a_{j,(i-1)k+1}, a_{j,(i-1)k+2} , ... , a_{j,(i-1)k+k}.$

Let $x$ be the $k$ bit binary number formed by the concatenation of $a_{j,(i-1)k+1}, ... , a_{j,ik}$.

Step 3. for $h = 1,2, ... , c$ do calculate $C_{jh} = C_{jh} + T_{xh}$.\hypertarget{brilliantrussian_8h_ad7d8c85656a410ce4f04675ae583224a}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri@{\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}}
\index{\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri@{\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{\+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}]{\setlength{\rightskip}{0pt plus 5cm}{\bf rci\+\_\+t} \+\_\+mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{A, }
\item[{int}]{k, }
\item[{{\bf rci\+\_\+t}}]{r, }
\item[{{\bf rci\+\_\+t}}]{c, }
\item[{{\bf rci\+\_\+t}}]{max\+\_\+r}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_ad7d8c85656a410ce4f04675ae583224a}


Given a matrix in upper triangular form compute the reduced row echelon form of that matrix but only start to do anything for the pivot at (r,c). 


\begin{DoxyParams}{Parameters}
{\em \hyperlink{structA}{A}} & Matrix to be reduced. \\
\hline
{\em k} & M4\+R\+I parameter, may be 0 for auto-\/choose. \\
\hline
{\em r} & Row index. \\
\hline
{\em c} & Column index. \\
\hline
{\em max\+\_\+r} & Only clear top max\+\_\+r rows. \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_a7b054433be6b71e1c613f64057d56031}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+addmul\+\_\+m4rm@{mzd\+\_\+addmul\+\_\+m4rm}}
\index{mzd\+\_\+addmul\+\_\+m4rm@{mzd\+\_\+addmul\+\_\+m4rm}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+addmul\+\_\+m4rm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mzd\+\_\+t}$\ast$ mzd\+\_\+addmul\+\_\+m4rm (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{C, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{A, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{B, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a7b054433be6b71e1c613f64057d56031}


Set C to C + A\+B using Konrod\textquotesingle{}s method. 

This is the convenient wrapper function, please see \+\_\+mzd\+\_\+mul\+\_\+m4rm for authors and implementation details.


\begin{DoxyParams}{Parameters}
{\em C} & Preallocated product matrix, may be N\+U\+L\+L for zero matrix. \\
\hline
{\em \hyperlink{structA}{A}} & Input matrix \hyperlink{structA}{A} \\
\hline
{\em B} & Input matrix B \\
\hline
{\em k} & M4\+R\+I parameter, may be 0 for auto-\/choose.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to C. 
\end{DoxyReturn}
\hypertarget{brilliantrussian_8h_aaba0eb0110d8c8a3350e21b5f647d388}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+inv\+\_\+m4ri@{mzd\+\_\+inv\+\_\+m4ri}}
\index{mzd\+\_\+inv\+\_\+m4ri@{mzd\+\_\+inv\+\_\+m4ri}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+inv\+\_\+m4ri}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mzd\+\_\+t}$\ast$ mzd\+\_\+inv\+\_\+m4ri (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{dst, }
\item[{const {\bf mzd\+\_\+t} $\ast$}]{src, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_aaba0eb0110d8c8a3350e21b5f647d388}


Invert the matrix src using Konrod\textquotesingle{}s method. 


\begin{DoxyParams}{Parameters}
{\em dst} & Matrix to hold the inverse (may be N\+U\+L\+L) \\
\hline
{\em src} & Matrix to be inverted. \\
\hline
{\em k} & Table size parameter, may be 0 for automatic choice.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Inverse of src if src has full rank 
\end{DoxyReturn}
\hypertarget{brilliantrussian_8h_a7c80eeffdf54a6ec67d70d8f54d913db}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+make\+\_\+table@{mzd\+\_\+make\+\_\+table}}
\index{mzd\+\_\+make\+\_\+table@{mzd\+\_\+make\+\_\+table}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+make\+\_\+table}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+make\+\_\+table (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} const $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{r, }
\item[{{\bf rci\+\_\+t}}]{c, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} $\ast$}]{T, }
\item[{{\bf rci\+\_\+t} $\ast$}]{L}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a7c80eeffdf54a6ec67d70d8f54d913db}


Constructs all possible $2^k$ row combinations using the gray code table. 


\begin{DoxyParams}{Parameters}
{\em M} & matrix to generate the tables from \\
\hline
{\em r} & the starting row \\
\hline
{\em c} & the starting column (only exact up to block) \\
\hline
{\em k} & \\
\hline
{\em T} & prealloced matrix of dimension $2^k$ x m-\/$>$ncols \\
\hline
{\em L} & prealloced table of length $2^k$ \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_ac89b0377af93051bc8cd3a0cb57e8c17}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+mul\+\_\+m4rm@{mzd\+\_\+mul\+\_\+m4rm}}
\index{mzd\+\_\+mul\+\_\+m4rm@{mzd\+\_\+mul\+\_\+m4rm}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+mul\+\_\+m4rm}]{\setlength{\rightskip}{0pt plus 5cm}{\bf mzd\+\_\+t}$\ast$ mzd\+\_\+mul\+\_\+m4rm (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{C, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{A, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{B, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_ac89b0377af93051bc8cd3a0cb57e8c17}


Matrix multiplication using Konrod\textquotesingle{}s method, i.\+e. 

compute C such that C == A\+B.

This is the convenient wrapper function, please see \+\_\+mzd\+\_\+mul\+\_\+m4rm for authors and implementation details.


\begin{DoxyParams}{Parameters}
{\em C} & Preallocated product matrix, may be N\+U\+L\+L for automatic creation. \\
\hline
{\em \hyperlink{structA}{A}} & Input matrix \hyperlink{structA}{A} \\
\hline
{\em B} & Input matrix B \\
\hline
{\em k} & M4\+R\+I parameter, may be 0 for auto-\/choose.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to C. 
\end{DoxyReturn}
\hypertarget{brilliantrussian_8h_a74df420e46e0e6548042c33cbe43fd8d}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows@{mzd\+\_\+process\+\_\+rows}}
\index{mzd\+\_\+process\+\_\+rows@{mzd\+\_\+process\+\_\+rows}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a74df420e46e0e6548042c33cbe43fd8d}


The function looks up k bits from position i,startcol in each row and adds the appropriate row from T to the row i. 

This process is iterated for i from startrow to stoprow (exclusive).


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T} & contains the correct row to be added \\
\hline
{\em L} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_a210dfd5b2353fbaa1ecbf14b0209cc07}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows2@{mzd\+\_\+process\+\_\+rows2}}
\index{mzd\+\_\+process\+\_\+rows2@{mzd\+\_\+process\+\_\+rows2}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows2}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows2 (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T0, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L0, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T1, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L1}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a210dfd5b2353fbaa1ecbf14b0209cc07}


Same as mzd\+\_\+process\+\_\+rows but works with two Gray code tables in parallel. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T0} & contains the correct row to be added \\
\hline
{\em L0} & Contains row number to be added \\
\hline
{\em T1} & contains the correct row to be added \\
\hline
{\em L1} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_abdff0368957f4041c353763874c7130a}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows3@{mzd\+\_\+process\+\_\+rows3}}
\index{mzd\+\_\+process\+\_\+rows3@{mzd\+\_\+process\+\_\+rows3}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows3}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows3 (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T0, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L0, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T1, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L1, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T2, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L2}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_abdff0368957f4041c353763874c7130a}


Same as mzd\+\_\+process\+\_\+rows but works with three Gray code tables in parallel. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T0} & contains the correct row to be added \\
\hline
{\em L0} & Contains row number to be added \\
\hline
{\em T1} & contains the correct row to be added \\
\hline
{\em L1} & Contains row number to be added \\
\hline
{\em T2} & contains the correct row to be added \\
\hline
{\em L2} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_a78967f819694d02fde80b970d24e0a9b}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows4@{mzd\+\_\+process\+\_\+rows4}}
\index{mzd\+\_\+process\+\_\+rows4@{mzd\+\_\+process\+\_\+rows4}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows4}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows4 (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T0, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L0, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T1, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L1, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T2, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L2, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T3, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L3}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a78967f819694d02fde80b970d24e0a9b}


Same as mzd\+\_\+process\+\_\+rows but works with four Gray code tables in parallel. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T0} & contains the correct row to be added \\
\hline
{\em L0} & Contains row number to be added \\
\hline
{\em T1} & contains the correct row to be added \\
\hline
{\em L1} & Contains row number to be added \\
\hline
{\em T2} & contains the correct row to be added \\
\hline
{\em L2} & Contains row number to be added \\
\hline
{\em T3} & contains the correct row to be added \\
\hline
{\em L3} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_a2a7a3cd746cfd98dcf885b8df2a69217}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows5@{mzd\+\_\+process\+\_\+rows5}}
\index{mzd\+\_\+process\+\_\+rows5@{mzd\+\_\+process\+\_\+rows5}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows5}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows5 (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T0, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L0, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T1, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L1, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T2, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L2, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T3, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L3, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T4, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L4}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_a2a7a3cd746cfd98dcf885b8df2a69217}


Same as mzd\+\_\+process\+\_\+rows but works with five Gray code tables in parallel. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T0} & contains the correct row to be added \\
\hline
{\em L0} & Contains row number to be added \\
\hline
{\em T1} & contains the correct row to be added \\
\hline
{\em L1} & Contains row number to be added \\
\hline
{\em T2} & contains the correct row to be added \\
\hline
{\em L2} & Contains row number to be added \\
\hline
{\em T3} & contains the correct row to be added \\
\hline
{\em L3} & Contains row number to be added \\
\hline
{\em T4} & contains the correct row to be added \\
\hline
{\em L4} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_ada7254c182115459c300f599f81145cd}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+process\+\_\+rows6@{mzd\+\_\+process\+\_\+rows6}}
\index{mzd\+\_\+process\+\_\+rows6@{mzd\+\_\+process\+\_\+rows6}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+process\+\_\+rows6}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+process\+\_\+rows6 (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{{\bf rci\+\_\+t}}]{startrow, }
\item[{{\bf rci\+\_\+t}}]{endrow, }
\item[{{\bf rci\+\_\+t}}]{startcol, }
\item[{int}]{k, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T0, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L0, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T1, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L1, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T2, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L2, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T3, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L3, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T4, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L4, }
\item[{{\bf mzd\+\_\+t} const $\ast$}]{T5, }
\item[{{\bf rci\+\_\+t} const $\ast$}]{L5}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_ada7254c182115459c300f599f81145cd}


Same as mzd\+\_\+process\+\_\+rows but works with six Gray code tables in parallel. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to operate on \\
\hline
{\em startrow} & top row which is operated on \\
\hline
{\em endrow} & bottom row which is operated on \\
\hline
{\em startcol} & Starting column for addition \\
\hline
{\em k} & M4\+R\+I parameter \\
\hline
{\em T0} & contains the correct row to be added \\
\hline
{\em L0} & Contains row number to be added \\
\hline
{\em T1} & contains the correct row to be added \\
\hline
{\em L1} & Contains row number to be added \\
\hline
{\em T2} & contains the correct row to be added \\
\hline
{\em L2} & Contains row number to be added \\
\hline
{\em T3} & contains the correct row to be added \\
\hline
{\em L3} & Contains row number to be added \\
\hline
{\em T4} & contains the correct row to be added \\
\hline
{\em L4} & Contains row number to be added \\
\hline
{\em T5} & contains the correct row to be added \\
\hline
{\em L5} & Contains row number to be added \\
\hline
\end{DoxyParams}
\hypertarget{brilliantrussian_8h_ab8fb672b3ce0ef365a40c8f6127ba074}{}\index{brilliantrussian.\+h@{brilliantrussian.\+h}!mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri@{mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}}
\index{mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri@{mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}!brilliantrussian.\+h@{brilliantrussian.\+h}}
\subsubsection[{mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri}]{\setlength{\rightskip}{0pt plus 5cm}void mzd\+\_\+top\+\_\+echelonize\+\_\+m4ri (
\begin{DoxyParamCaption}
\item[{{\bf mzd\+\_\+t} $\ast$}]{M, }
\item[{int}]{k}
\end{DoxyParamCaption}
)}\label{brilliantrussian_8h_ab8fb672b3ce0ef365a40c8f6127ba074}


Given a matrix in upper triangular form compute the reduced row echelon form of that matrix. 


\begin{DoxyParams}{Parameters}
{\em M} & Matrix to be reduced. \\
\hline
{\em k} & M4\+R\+I parameter, may be 0 for auto-\/choose. \\
\hline
\end{DoxyParams}
