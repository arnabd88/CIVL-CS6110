\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory}{}\section{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory Interface Reference}
\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory}\index{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory@{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory}}


The state factory is used to create all state objects.  




Inheritance diagram for edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=299pt]{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
Symbolic\+Universe \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5ca93a5b12557dcb6337cf3cf41862ec}{symbolic\+Universe} ()
\begin{DoxyCompactList}\small\item\em Returns the symbolic universe used by this factory to manipulate symbolic expressions. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a99001c497b2ff46cd098525744a7d0c1}{canonic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, boolean \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}{collect\+Processes}, boolean \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a4ffda85305907c945cc3ffb2d3339eeb}{collect\+Scopes}, boolean \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a78a17339ebd0be7dacaf1f06e78626d7}{collect\+Heaps}, Set$<$ \hyperlink{enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind}{Heap\+Error\+Kind} $>$ to\+Be\+Ignored)  throws C\+I\+V\+L\+Heap\+Exception
\begin{DoxyCompactList}\small\item\em Return the \char`\"{}canonical\char`\"{} version of the given state. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abcd886f831cb9db1dac78c3aee029751}{initial\+State} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Model}{Model} model)  throws C\+I\+V\+L\+Heap\+Exception
\begin{DoxyCompactList}\small\item\em Returns the canonic, initial state for a \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} Model. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae266fa51d2dea90e7e5d3ca8b45dd22b}{set\+Variable} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable}{Variable} variable, int pid, Symbolic\+Expression value)
\begin{DoxyCompactList}\small\item\em Updates the value assigned to a variable in the state. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab1877edd7985bfa3bb4171fed7671472}{set\+Variable} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int vid, int scope\+Id, Symbolic\+Expression value)
\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2c05d9800df5a48cfd13da18caf24364}{add\+Process} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction}{C\+I\+V\+L\+Function} function, Symbolic\+Expression\mbox{[}$\,$\mbox{]} arguments, int caller\+Pid)
\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_af2a497fca3857a16cda6ddda36d2eb49}{add\+Process} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction}{C\+I\+V\+L\+Function} function, int function\+Parent\+Dyscope, Symbolic\+Expression\mbox{[}$\,$\mbox{]} arguments, int caller\+Pid)
\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aefff2ccf75944f8eea5c77d95aeb3b5f}{terminate\+Process} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Sets the process state for the designated process to be the process state with the empty stack. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5f969c52d703e39c812dfde91ad68d75}{remove\+Process} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Removes a process from the state. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ad68188e38333826e7f585b5ceb858a08}{set\+Location} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location}{Location} location)
\begin{DoxyCompactList}\small\item\em Sets the location of a process. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3d545b10a549db49479268ea772245b1}{set\+Location} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location}{Location} location, boolean access\+Changed)
\begin{DoxyCompactList}\small\item\em Sets the location of a process. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3c7ba7469eca87e1359b63656f6de1fb}{push\+Call\+Stack} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction}{C\+I\+V\+L\+Function} function, Symbolic\+Expression\mbox{[}$\,$\mbox{]} arguments)
\begin{DoxyCompactList}\small\item\em Pushes a new entry onto the call stack for a process. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8eae26822f75dc67b3a588a725af7430}{push\+Call\+Stack} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction}{C\+I\+V\+L\+Function} function, int function\+Parent\+Dyscope, Symbolic\+Expression\mbox{[}$\,$\mbox{]} arguments)
\begin{DoxyCompactList}\small\item\em Pushes a new entry onto the call stack for a process. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab11e79aef8f8b8b80e830cbf48f03c1e}{pop\+Call\+Stack} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Pops an entry off the call stack for a process. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_adbeb8d17faccb408984c62646ad3491d}{simplify} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Simplifies all variable values in the state, using the path condition as the simplification context. \end{DoxyCompactList}\item 
long \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2e8deab13e632331d44f30808e245bd3}{get\+Num\+State\+Instances} ()
\begin{DoxyCompactList}\small\item\em Returns the number of objects of type \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} that have been instantiated since this J\+V\+M started. \end{DoxyCompactList}\item 
int \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5442b4d2a0f993e07a9bd403ebdcd917}{get\+Num\+States\+Saved} ()
\begin{DoxyCompactList}\small\item\em Returns the number of states stored by this state factory. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a78a17339ebd0be7dacaf1f06e78626d7}{collect\+Heaps} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, Set$<$ \hyperlink{enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind}{Heap\+Error\+Kind} $>$ to\+Be\+Ignored)  throws C\+I\+V\+L\+State\+Exception
\begin{DoxyCompactList}\small\item\em Performs a garbage collection and canonicalization of heaps. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a4ffda85305907c945cc3ffb2d3339eeb}{collect\+Scopes} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, Set$<$ \hyperlink{enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind}{Heap\+Error\+Kind} $>$ to\+Be\+Ignored)  throws C\+I\+V\+L\+State\+Exception
\begin{DoxyCompactList}\small\item\em Performs a garbage collection and canonicalization of dynamic scopes. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}{collect\+Processes} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Performs a garbage collection and canonicalization of the process states. \end{DoxyCompactList}\item 
boolean \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8960b6b6ec0ad03227bf46ee17b19ed1}{locked\+By\+Atomic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Checks if any process at the state is holding the atomic lock, i.\+e, the process is executing some atomic blocks. \end{DoxyCompactList}\item 
int \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abd00efcbcd99ef258a98712c1a5519fd}{process\+In\+Atomic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Returns the P\+I\+D of the process that holds the atomic lock at a certain state. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aeba2dd3ec097f8086d633109f66419df}{get\+Atomic\+Lock} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Declares that the process with the given P\+I\+D now owns the atomic lock. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a20c86533f0d632ee5258f90c464d596e}{enter\+Atomic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Process pid enters a new atomic section. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ace7452c8c5a59d8862e3fc189577cf8b}{leave\+Atomic} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid)
\begin{DoxyCompactList}\small\item\em Process pid leaves an atomic section. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a1a81054b9e512c38bcf873ce54c36896}{release\+Atomic\+Lock} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Releases the atomic lock, by updating the atomic lock variable with the undefined process value. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2f48636d5dba0d57c3e7cf63e9980b9d}{set\+Process\+State} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1ProcessState}{Process\+State} process\+State)
\item 
boolean \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab2ba56b706c95a3afbe32c54504c5b16}{is\+Descendant\+Of} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int ancestor, int descendant)
\begin{DoxyCompactList}\small\item\em Checks if one dyscope is strictly the descendant of the other (not equal to). \end{DoxyCompactList}\item 
int \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7bb8f08bb0e64d60c886d2cd482e9c80}{lowest\+Common\+Ancestor} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int one, int another)
\begin{DoxyCompactList}\small\item\em Computes the lowest common ancestor of two given dyscopes. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair}{Pair}$<$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State}, Symbolic\+Expression $>$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2d470ef099fa677050a049e6ffb0090f}{malloc} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int dyscope\+I\+D, int malloc\+I\+D, Symbolic\+Expression heap\+Object)
\begin{DoxyCompactList}\small\item\em Allocates an object, of the given value, for the given malloc I\+D in the heap of the given dyscope. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair}{Pair}$<$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State}, Symbolic\+Expression $>$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae7914fbfe856e913a2f9ad694ed01b9b}{malloc} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int pid, int dyscope\+I\+D, int malloc\+I\+D, Symbolic\+Type element\+Type, Numeric\+Expression element\+Count)
\begin{DoxyCompactList}\small\item\em Allocates an object for the given malloc I\+D in the heap of the given dyscope. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae67ff5361d7dda8a7b1ca1b3a7d6ad48}{deallocate} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, Symbolic\+Expression heap\+Object\+Pointer, int dyscope\+Id, int malloc\+Id, int index)
\begin{DoxyCompactList}\small\item\em Deallocates a heap object from the heap of a given dyscope. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a38d4a9ddfedabc175ca4f3339e429ab7}{increment\+Num\+Symbolic\+Constants} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Increase the number of symbolic constants by one. \end{DoxyCompactList}\item 
int \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aa25cbfaca9b0e6a1d7aa7e15dc50ec87}{num\+Symbolic\+Constants} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Returns the number of symbolic constants appearing in the given state. \end{DoxyCompactList}\item 
\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_adae846f055fce4e5a5ad400c92d2ef6d}{}int {\bfseries num\+Symbolic\+Inputs} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_adae846f055fce4e5a5ad400c92d2ef6d}

\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_afb5218196825ebba4a22fb05335a008c}{increment\+Num\+Symbolic\+Inputs} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Increase the number of symbolic constants by one. \end{DoxyCompactList}\item 
\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aadbb2c92c0b77f2549d36fd17469b42b}{}\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory}{Memory\+Unit\+Factory} {\bfseries mem\+Unit\+Factory} ()\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aadbb2c92c0b77f2549d36fd17469b42b}

\item 
Map$<$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable}{Variable}, Symbolic\+Expression $>$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8f666801e5c6522fcdc81b508cf1e10d}{input\+Variable\+Value\+Map} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state)
\begin{DoxyCompactList}\small\item\em Returns the map of variable and value of input variables at the given state. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a71c4b5efdb8a18f3e9d6e724c0045d4f}{merge\+Monostates} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry}{Immutable\+Collective\+Snapshots\+Entry} entry)
\begin{DoxyCompactList}\small\item\em Merges a set of \hyperlink{}{Immutable\+Mono\+State} to a F\+A\+K\+E global \hyperlink{}{Immutable\+State} which should only be used to evaluation. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7948dbf498b93bb9e67a757450dfc421}{add\+To\+Collective\+Snapshots\+Entry} (\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} state, int pid, int place, int queue\+I\+D, int entry\+Pos, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression}{Expression} assertion)
\begin{DoxyCompactList}\small\item\em Take a snapshot on current state then store the snapshot with the collective assertion into an collective\+Snapshots\+Entry. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aaa4576f13147144139eb71f61c506c7b}{create\+Collective\+Snapshots\+Enrty} (\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} state, int pid, int num\+Processes, int place, int queue\+I\+D, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression}{Expression} assertion, Symbolic\+Expression channels, Contract\+Kind kind, List$<$ \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair}{Pair}$<$ \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable}{Variable}, Symbolic\+Expression $>$$>$ pick\+Up\+Station)
\begin{DoxyCompactList}\small\item\em The process with \char`\"{}pid\char`\"{} creates a fresh new \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry}, then saves its own snapshot in the new entry. \end{DoxyCompactList}\item 
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a79263e51d0e37343b1211adb8f1f19f1}{dequeue\+Collective\+Snapshots\+Entry} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int queue\+I\+D)
\begin{DoxyCompactList}\small\item\em Dequeues an \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry} from the specific snapshots queue, returns a new state. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry}{Immutable\+Collective\+Snapshots\+Entry} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a319b79f1cb6f0ca0608b5bccf4a0151c}{peek\+Collective\+Snapshots\+Entry} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int queue\+I\+D)
\begin{DoxyCompactList}\small\item\em Copy the top \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry} from the specific snapshots queue, returns the copied snapshots entry. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abb62af481c4c0f8bbc5091b16f1d9d75}{commit\+Updated\+Channels\+To\+Entries} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int queue\+Id, Symbolic\+Expression\mbox{[}$\,$\mbox{]} new\+Channels)
\begin{DoxyCompactList}\small\item\em Update all entries in a collective queue with a group of message buffers. \end{DoxyCompactList}\item 
\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry}{Immutable\+Collective\+Snapshots\+Entry}\mbox{[}$\,$\mbox{]} \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a03ae05bbe6479f7111e129a649cfed4b}{get\+Snapshots\+Queue} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} state, int queue\+I\+D)
\begin{DoxyCompactList}\small\item\em Returns the corresponding snapshot queue by giving the identifier of an M\+P\+I communicator (The identifier is a component of the \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} M\+P\+I library implementation). \end{DoxyCompactList}\item 
\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ad7c232147650e90b66e1675de991ef84}{}\hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState}{Immutable\+State} {\bfseries copy\+Snapshots\+Queues} (\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} from\+State, \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} to\+State)\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ad7c232147650e90b66e1675de991ef84}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
The state factory is used to create all state objects. 

\begin{DoxyAuthor}{Author}
Timothy K. Zirkel (zirkel) 

Timothy J. Mc\+Clory (tmcclory) 

Stephen F. Siegel (siegel) 
\end{DoxyAuthor}


\subsection{Member Function Documentation}
\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2c05d9800df5a48cfd13da18caf24364}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!add\+Process@{add\+Process}}
\index{add\+Process@{add\+Process}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{add\+Process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+add\+Process (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{{\bf C\+I\+V\+L\+Function}}]{function, }
\item[{Symbolic\+Expression\mbox{[}$\,$\mbox{]}}]{arguments, }
\item[{int}]{caller\+Pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2c05d9800df5a48cfd13da18caf24364}
Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an Illegal\+Argument\+Exception is thrown. Hence the calling process must have a non-\/empty call stack. 

The P\+I\+D of the new process will be \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State_a1fb9bc3c57e059c2885a73ba4d08b441}{State\#num\+Procs()}, where state is the pre-\/state (the given state), not the new state. 


\begin{DoxyParams}{Parameters}
{\em state} & The old state. \\
\hline
{\em function} & The function in which the new process starts. \\
\hline
{\em arguments} & The arguments to this function call. \\
\hline
{\em caller\+Pid} & the P\+I\+D of the process that is creating the new process \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a1b0ab2bb34419888f0a80b1a6c9ac756}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_af2a497fca3857a16cda6ddda36d2eb49}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!add\+Process@{add\+Process}}
\index{add\+Process@{add\+Process}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{add\+Process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+add\+Process (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{{\bf C\+I\+V\+L\+Function}}]{function, }
\item[{int}]{function\+Parent\+Dyscope, }
\item[{Symbolic\+Expression\mbox{[}$\,$\mbox{]}}]{arguments, }
\item[{int}]{caller\+Pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_af2a497fca3857a16cda6ddda36d2eb49}
Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an Illegal\+Argument\+Exception is thrown. Hence the calling process must have a non-\/empty call stack. 

The P\+I\+D of the new process will be \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State_a1fb9bc3c57e059c2885a73ba4d08b441}{State\#num\+Procs()}, where state is the pre-\/state (the given state), not the new state. 


\begin{DoxyParams}{Parameters}
{\em state} & The old state. \\
\hline
{\em function} & The function in which the new process starts. \\
\hline
{\em function\+Parent\+Dyscope} & The dyscope I\+D of the parent of the new function \\
\hline
{\em arguments} & The arguments to this function call. \\
\hline
{\em caller\+Pid} & the P\+I\+D of the process that is creating the new process \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a9a90cec9f8322c9b8abc34cd366f2b9e}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7948dbf498b93bb9e67a757450dfc421}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!add\+To\+Collective\+Snapshots\+Entry@{add\+To\+Collective\+Snapshots\+Entry}}
\index{add\+To\+Collective\+Snapshots\+Entry@{add\+To\+Collective\+Snapshots\+Entry}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{add\+To\+Collective\+Snapshots\+Entry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+add\+To\+Collective\+Snapshots\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf Immutable\+State}}]{state, }
\item[{int}]{pid, }
\item[{int}]{place, }
\item[{int}]{queue\+I\+D, }
\item[{int}]{entry\+Pos, }
\item[{{\bf Expression}}]{assertion}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7948dbf498b93bb9e67a757450dfc421}


Take a snapshot on current state then store the snapshot with the collective assertion into an collective\+Snapshots\+Entry. 

If the global state has a queue, then either create a new entry then enqueue, or modify a existing entry, otherwise create both a queue and a entry. Return the new or modified entry.


\begin{DoxyParams}{Parameters}
{\em state} & The current state \\
\hline
{\em pid} & The P\+I\+D of the process \\
\hline
{\em place} & The place of the process in the collective entry \\
\hline
{\em queue\+I\+D} & The I\+D identifies a collective entry \\
\hline
{\em entry\+Pos} & The position of the entry in the collective queue \\
\hline
{\em assertion} & The expression of a assertion asserted by the process \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ae7514e9e3d808ecf1b7f5b375cf5cf8f}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a99001c497b2ff46cd098525744a7d0c1}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!canonic@{canonic}}
\index{canonic@{canonic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{canonic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+canonic (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{boolean}]{collect\+Processes, }
\item[{boolean}]{collect\+Scopes, }
\item[{boolean}]{collect\+Heaps, }
\item[{Set$<$ {\bf Heap\+Error\+Kind} $>$}]{to\+Be\+Ignored}
\end{DoxyParamCaption}
) throws {\bf C\+I\+V\+L\+Heap\+Exception}}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a99001c497b2ff46cd098525744a7d0c1}


Return the \char`\"{}canonical\char`\"{} version of the given state. 

The state returned will satisfy all of the following\+: 
\begin{DoxyItemize}
\item it will be observationally equivalent to the given state, i.\+e., there is no way a C\+I\+V\+L-\/\+C program can distinguish between the two states 
\item there will be no gaps in the dynamic scope I\+Ds and no null dynamic scopes 
\item there will be no gaps in the P\+I\+Ds and no null process states 
\item every dynamic scope will be reachable (starting from the frame of the call stack of one of the processes and following parent edges in the dyscope tree) 
\item the state returned will be the unique representative of its equivalence class, i.\+e., if this method is invoked with two equivalent states, it will return the same object 
\end{DoxyItemize}

Note that the state returned may in fact be the same as the one given.

Note that this does everything that methods \hyperlink{}{collect\+Scopes(\+State)} and \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}{collect\+Processes} do. So there is no need to call those methods if you are already calling this method.

This method may go further in simplifying the state. This is up to the particular implementation.


\begin{DoxyParams}{Parameters}
{\em state} & any non-\/null \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} state \\
\hline
{\em collect\+Processes} & shall processes be collected? \\
\hline
{\em collect\+Scopes} & shall scopes be collected? \\
\hline
{\em collect\+Heaps} & shall heaps be collected?\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the canonical version of the given state 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a62c70f6ea5fb68aaf09cb09087b006b1}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a78a17339ebd0be7dacaf1f06e78626d7}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!collect\+Heaps@{collect\+Heaps}}
\index{collect\+Heaps@{collect\+Heaps}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{collect\+Heaps}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+collect\+Heaps (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{Set$<$ {\bf Heap\+Error\+Kind} $>$}]{to\+Be\+Ignored}
\end{DoxyParamCaption}
) throws {\bf C\+I\+V\+L\+State\+Exception}}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a78a17339ebd0be7dacaf1f06e78626d7}


Performs a garbage collection and canonicalization of heaps. 

Computes the set of reachable heap objects, and removes all unreachable heap objects. Renumbers heap objects in a canonic way. Updates all pointers in the state accordingly. This operation should be completely invisible to the user.


\begin{DoxyParams}{Parameters}
{\em state} & a state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the state after canonicalizing heaps, which may be this state or a new one 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a66fc6a266b28ded9287b0ec6d2621a94}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!collect\+Processes@{collect\+Processes}}
\index{collect\+Processes@{collect\+Processes}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{collect\+Processes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+collect\+Processes (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}


Performs a garbage collection and canonicalization of the process states. 

Removes any process state that is null. Renumbers the P\+I\+Ds so that there are no gaps (and start from 0).


\begin{DoxyParams}{Parameters}
{\em state} & any non-\/null \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the state with processes collected 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a4e0a1ff9fd037a1afdd7e9c6dce4a18b}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a4ffda85305907c945cc3ffb2d3339eeb}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!collect\+Scopes@{collect\+Scopes}}
\index{collect\+Scopes@{collect\+Scopes}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{collect\+Scopes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+collect\+Scopes (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{Set$<$ {\bf Heap\+Error\+Kind} $>$}]{to\+Be\+Ignored}
\end{DoxyParamCaption}
) throws {\bf C\+I\+V\+L\+State\+Exception}}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a4ffda85305907c945cc3ffb2d3339eeb}


Performs a garbage collection and canonicalization of dynamic scopes. 

Compute the set of reachable dynamic scopes, and removes any which are unreachable. Renumbers the dynamic scopes in a canonic way. Updates all scope references in the state. This operation should be completely invisible to the user.


\begin{DoxyParams}{Parameters}
{\em state} & a state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the state after canonicalizing scopes, which may be this state or a new one 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ac08af796a3dfdb6f0cce6c0c1afb8c68}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abb62af481c4c0f8bbc5091b16f1d9d75}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!commit\+Updated\+Channels\+To\+Entries@{commit\+Updated\+Channels\+To\+Entries}}
\index{commit\+Updated\+Channels\+To\+Entries@{commit\+Updated\+Channels\+To\+Entries}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{commit\+Updated\+Channels\+To\+Entries}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+commit\+Updated\+Channels\+To\+Entries (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{queue\+Id, }
\item[{Symbolic\+Expression\mbox{[}$\,$\mbox{]}}]{new\+Channels}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abb62af481c4c0f8bbc5091b16f1d9d75}


Update all entries in a collective queue with a group of message buffers. 

Note\+: The entry in position i will be updated with the message buffers in new\+Buffers\mbox{[}i\mbox{]}. The 0 position in collective queue is the head of the queue. The reason of using an array of message buffers to update the collective queue is to prevent the queue in state be changed for other purposes.


\begin{DoxyParams}{Parameters}
{\em state} & The current state \\
\hline
{\em queue\+Id} & The I\+D of the collective queue \\
\hline
{\em new\+Channels} & The array of new message buffers. see \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry_a41f3b2e873b8f0e650cab149bbe4f129}{Collective\+Snapshots\+Entry\#get\+Msg\+Buffers()} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a948646856ef1cd713a740aecc22d34c0}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aaa4576f13147144139eb71f61c506c7b}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!create\+Collective\+Snapshots\+Enrty@{create\+Collective\+Snapshots\+Enrty}}
\index{create\+Collective\+Snapshots\+Enrty@{create\+Collective\+Snapshots\+Enrty}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{create\+Collective\+Snapshots\+Enrty}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+create\+Collective\+Snapshots\+Enrty (
\begin{DoxyParamCaption}
\item[{{\bf Immutable\+State}}]{state, }
\item[{int}]{pid, }
\item[{int}]{num\+Processes, }
\item[{int}]{place, }
\item[{int}]{queue\+I\+D, }
\item[{{\bf Expression}}]{assertion, }
\item[{Symbolic\+Expression}]{channels, }
\item[{Contract\+Kind}]{kind, }
\item[{List$<$ {\bf Pair}$<$ {\bf Variable}, Symbolic\+Expression $>$$>$}]{pick\+Up\+Station}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aaa4576f13147144139eb71f61c506c7b}


The process with \char`\"{}pid\char`\"{} creates a fresh new \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry}, then saves its own snapshot in the new entry. 

This function returns the new state with a new entry in one of its snapshots queues.


\begin{DoxyParams}{Parameters}
{\em state} & The current state \\
\hline
{\em pid} & The P\+I\+D of the process \\
\hline
{\em num\+Processes} & The number of processes participating this collective entry \\
\hline
{\em place} & The place of the process in the collective entry \\
\hline
{\em queue\+I\+D} & The I\+D identifies a collective queue \\
\hline
{\em assertion} & The expression of the assertion asserted by the processes \\
\hline
{\em channels} & Message buffer snapshot \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a4462151d1c85d4d4a878d88d6cc96350}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae67ff5361d7dda8a7b1ca1b3a7d6ad48}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{deallocate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+deallocate (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{Symbolic\+Expression}]{heap\+Object\+Pointer, }
\item[{int}]{dyscope\+Id, }
\item[{int}]{malloc\+Id, }
\item[{int}]{index}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae67ff5361d7dda8a7b1ca1b3a7d6ad48}


Deallocates a heap object from the heap of a given dyscope. 

It marks the heap object as I\+N\+V\+A\+L\+I\+D instead of removing it, updates any pointer to that removed object to be an U\+N\+D\+E\+F\+I\+N\+E\+D pointer, which is defined by the symbolic utility. The removal of the heap object happens later when the heap gets collected during state canonicalization.

\begin{DoxySeeAlso}{See also}
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2d470ef099fa677050a049e6ffb0090f}{malloc}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em state} & The pre-\/state. \\
\hline
{\em heap\+Object\+Pointer} & The pointer which points to the heap object to be removed. \\
\hline
{\em dyscope\+Id} & The I\+D of the dyscope where the pointer points to. \\
\hline
{\em malloc\+Id} & The malloc I\+D of the heap object to be removed, i.\+e., the index of the heap field in the heap. \\
\hline
{\em index} & The index of the heap object in the heap field. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state after the heap object is removed from the heap, and corresponding pointers updated. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_adbb5cfa400e857cedde973811105fed9}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a79263e51d0e37343b1211adb8f1f19f1}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!dequeue\+Collective\+Snapshots\+Entry@{dequeue\+Collective\+Snapshots\+Entry}}
\index{dequeue\+Collective\+Snapshots\+Entry@{dequeue\+Collective\+Snapshots\+Entry}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{dequeue\+Collective\+Snapshots\+Entry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+dequeue\+Collective\+Snapshots\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{queue\+I\+D}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a79263e51d0e37343b1211adb8f1f19f1}


Dequeues an \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry} from the specific snapshots queue, returns a new state. 


\begin{DoxyParams}{Parameters}
{\em state} & The current state \\
\hline
{\em queue\+I\+D} & The I\+D identifies a collective queue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a54d1895551e52122c30a1eb645f7f690}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a20c86533f0d632ee5258f90c464d596e}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!enter\+Atomic@{enter\+Atomic}}
\index{enter\+Atomic@{enter\+Atomic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{enter\+Atomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+enter\+Atomic (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a20c86533f0d632ee5258f90c464d596e}


Process pid enters a new atomic section. 

~\newline
 Precondition\+: no other processes hold the atomic lock~\newline
 If the process already holds the atomic lock, then its atomic count is incremented; ~\newline
 if the process doesn\textquotesingle{}t hold the atomic lock, then the atomic lock is obtained and its atomic count is set to be 1.


\begin{DoxyParams}{Parameters}
{\em state} & \\
\hline
{\em pid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new state after process pid enters a new atomic section 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a025b6b9e6b52f0f5a7f47a946e35e02d}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aeba2dd3ec097f8086d633109f66419df}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!get\+Atomic\+Lock@{get\+Atomic\+Lock}}
\index{get\+Atomic\+Lock@{get\+Atomic\+Lock}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{get\+Atomic\+Lock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+get\+Atomic\+Lock (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aeba2dd3ec097f8086d633109f66419df}


Declares that the process with the given P\+I\+D now owns the atomic lock. 

Precondition\+: no process is holding the atomic lock in the given state.


\begin{DoxyParams}{Parameters}
{\em state} & any non-\/null \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} state \\
\hline
{\em pid} & The P\+I\+D of the process that is going to take the atomic lock \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a state equivalent to given one except that process P\+I\+D now owns the atomic lock 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a912ed0ca7a4414f2edc2be8e36faefde}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2e8deab13e632331d44f30808e245bd3}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!get\+Num\+State\+Instances@{get\+Num\+State\+Instances}}
\index{get\+Num\+State\+Instances@{get\+Num\+State\+Instances}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{get\+Num\+State\+Instances}]{\setlength{\rightskip}{0pt plus 5cm}long edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+get\+Num\+State\+Instances (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2e8deab13e632331d44f30808e245bd3}


Returns the number of objects of type \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} that have been instantiated since this J\+V\+M started. 

\begin{DoxyReturn}{Returns}
the number of states instantiated 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a0a89d58bd62a499947f0afac037379dd}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5442b4d2a0f993e07a9bd403ebdcd917}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!get\+Num\+States\+Saved@{get\+Num\+States\+Saved}}
\index{get\+Num\+States\+Saved@{get\+Num\+States\+Saved}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{get\+Num\+States\+Saved}]{\setlength{\rightskip}{0pt plus 5cm}int edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+get\+Num\+States\+Saved (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5442b4d2a0f993e07a9bd403ebdcd917}


Returns the number of states stored by this state factory. 

\begin{DoxyReturn}{Returns}
the number of states stored 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_acd0074abb7544acdde596a2fab96e669}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a03ae05bbe6479f7111e129a649cfed4b}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!get\+Snapshots\+Queue@{get\+Snapshots\+Queue}}
\index{get\+Snapshots\+Queue@{get\+Snapshots\+Queue}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{get\+Snapshots\+Queue}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+Collective\+Snapshots\+Entry} \mbox{[}$\,$\mbox{]} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+get\+Snapshots\+Queue (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{queue\+I\+D}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a03ae05bbe6479f7111e129a649cfed4b}


Returns the corresponding snapshot queue by giving the identifier of an M\+P\+I communicator (The identifier is a component of the \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} M\+P\+I library implementation). 

If there is no such a snapshot queue for the M\+P\+I communicator, returns an empty array.


\begin{DoxyParams}{Parameters}
{\em id} & The identifier of a M\+P\+I communicator \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a2ab7303606615d76222aff56ce7125ef}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a38d4a9ddfedabc175ca4f3339e429ab7}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!increment\+Num\+Symbolic\+Constants@{increment\+Num\+Symbolic\+Constants}}
\index{increment\+Num\+Symbolic\+Constants@{increment\+Num\+Symbolic\+Constants}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{increment\+Num\+Symbolic\+Constants}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+increment\+Num\+Symbolic\+Constants (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a38d4a9ddfedabc175ca4f3339e429ab7}


Increase the number of symbolic constants by one. 


\begin{DoxyParams}{Parameters}
{\em state} & the state whole number of symbolic constants is to be increased. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new state 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a61437ae4ca0fb099c9f79ddceaa5d07c}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_afb5218196825ebba4a22fb05335a008c}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!increment\+Num\+Symbolic\+Inputs@{increment\+Num\+Symbolic\+Inputs}}
\index{increment\+Num\+Symbolic\+Inputs@{increment\+Num\+Symbolic\+Inputs}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{increment\+Num\+Symbolic\+Inputs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+increment\+Num\+Symbolic\+Inputs (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_afb5218196825ebba4a22fb05335a008c}


Increase the number of symbolic constants by one. 


\begin{DoxyParams}{Parameters}
{\em state} & the state whole number of symbolic constants is to be increased. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new state 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a6fd1ae7f315d534836864cc76a4fce0f}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abcd886f831cb9db1dac78c3aee029751}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!initial\+State@{initial\+State}}
\index{initial\+State@{initial\+State}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{initial\+State}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+initial\+State (
\begin{DoxyParamCaption}
\item[{{\bf Model}}]{model}
\end{DoxyParamCaption}
) throws {\bf C\+I\+V\+L\+Heap\+Exception}}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abcd886f831cb9db1dac78c3aee029751}


Returns the canonic, initial state for a \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} Model. 

\begin{DoxyReturn}{Returns}
the initial state 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a6a8e3b14776e73ce1d08b175e3012cbd}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8f666801e5c6522fcdc81b508cf1e10d}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!input\+Variable\+Value\+Map@{input\+Variable\+Value\+Map}}
\index{input\+Variable\+Value\+Map@{input\+Variable\+Value\+Map}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{input\+Variable\+Value\+Map}]{\setlength{\rightskip}{0pt plus 5cm}Map$<${\bf Variable}, Symbolic\+Expression$>$ edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+input\+Variable\+Value\+Map (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8f666801e5c6522fcdc81b508cf1e10d}


Returns the map of variable and value of input variables at the given state. 


\begin{DoxyParams}{Parameters}
{\em state} & \\
\hline
\end{DoxyParams}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_aa4bd3853959303e304debbc2ae22f5a4}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab2ba56b706c95a3afbe32c54504c5b16}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!is\+Descendant\+Of@{is\+Descendant\+Of}}
\index{is\+Descendant\+Of@{is\+Descendant\+Of}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{is\+Descendant\+Of}]{\setlength{\rightskip}{0pt plus 5cm}boolean edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+is\+Descendant\+Of (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{ancestor, }
\item[{int}]{descendant}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab2ba56b706c95a3afbe32c54504c5b16}


Checks if one dyscope is strictly the descendant of the other (not equal to). 


\begin{DoxyParams}{Parameters}
{\em state} & The current state. \\
\hline
{\em ancestor} & The I\+D of the ancestor dyscope. \\
\hline
{\em descendant} & The I\+D of the descendant dyscope. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True iff ancestor dyscope is really an ancestor of the descendant dyscope and they must not be equal to each other. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_af29c3918cae07c8e2689445dde49d065}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ace7452c8c5a59d8862e3fc189577cf8b}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!leave\+Atomic@{leave\+Atomic}}
\index{leave\+Atomic@{leave\+Atomic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{leave\+Atomic}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+leave\+Atomic (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ace7452c8c5a59d8862e3fc189577cf8b}


Process pid leaves an atomic section. 

~\newline
 Precondition\+: in the given state, the process pid holds the atomic lock and its atomic count is greater than zero.~\newline
 The atomic count is decremented by 1 after this method;~\newline
 if the resultant atomic count is 0, then the atomic lock is released as well.


\begin{DoxyParams}{Parameters}
{\em state} & \\
\hline
{\em pid} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the new state after process pid leaves an atomic section 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ac3151f31996c6239ac71a2714ea54724}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8960b6b6ec0ad03227bf46ee17b19ed1}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!locked\+By\+Atomic@{locked\+By\+Atomic}}
\index{locked\+By\+Atomic@{locked\+By\+Atomic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{locked\+By\+Atomic}]{\setlength{\rightskip}{0pt plus 5cm}boolean edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+locked\+By\+Atomic (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8960b6b6ec0ad03227bf46ee17b19ed1}


Checks if any process at the state is holding the atomic lock, i.\+e, the process is executing some atomic blocks. 

This information is maintained as a global variable of {\ttfamily \$proc} type in the root scope in the \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} model (always with index 0), and it gets automatically updated when process id\textquotesingle{}s are renumbered. 


\begin{DoxyParams}{Parameters}
{\em state} & The state to be checked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True iff the value of the variable atomic lock is not undefined. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a5fd6c8dfda79abc673ed958993b8cff2}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7bb8f08bb0e64d60c886d2cd482e9c80}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!lowest\+Common\+Ancestor@{lowest\+Common\+Ancestor}}
\index{lowest\+Common\+Ancestor@{lowest\+Common\+Ancestor}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{lowest\+Common\+Ancestor}]{\setlength{\rightskip}{0pt plus 5cm}int edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+lowest\+Common\+Ancestor (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{one, }
\item[{int}]{another}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a7bb8f08bb0e64d60c886d2cd482e9c80}


Computes the lowest common ancestor of two given dyscopes. 

The returned value is always a dyscope I\+D.


\begin{DoxyParams}{Parameters}
{\em state} & The current state. \\
\hline
{\em one} & One dyscope. \\
\hline
{\em another} & Another dynamic scope. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The dyscope I\+D of the lowest common ancestor of the two given dyscopes. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ad7bebd102aa4e515f7a532cb50751c46}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2d470ef099fa677050a049e6ffb0090f}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!malloc@{malloc}}
\index{malloc@{malloc}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{malloc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pair}$<${\bf State}, Symbolic\+Expression$>$ edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+malloc (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{dyscope\+I\+D, }
\item[{int}]{malloc\+I\+D, }
\item[{Symbolic\+Expression}]{heap\+Object}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2d470ef099fa677050a049e6ffb0090f}


Allocates an object, of the given value, for the given malloc I\+D in the heap of the given dyscope. 

For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc I\+D assigned by the model builder.


\begin{DoxyParams}{Parameters}
{\em state} & The pre-\/state. \\
\hline
{\em dyscope\+I\+D} & The dyscope I\+D. \\
\hline
{\em malloc\+I\+D} & The I\+D the malloc statement. \\
\hline
{\em heap\+Object} & The value of the new heap object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The new state after the new heap object 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a521481b4006af34010ce856f4f539a39}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae7914fbfe856e913a2f9ad694ed01b9b}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!malloc@{malloc}}
\index{malloc@{malloc}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{malloc}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pair}$<${\bf State}, Symbolic\+Expression$>$ edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+malloc (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid, }
\item[{int}]{dyscope\+I\+D, }
\item[{int}]{malloc\+I\+D, }
\item[{Symbolic\+Type}]{element\+Type, }
\item[{Numeric\+Expression}]{element\+Count}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae7914fbfe856e913a2f9ad694ed01b9b}


Allocates an object for the given malloc I\+D in the heap of the given dyscope. 

For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc I\+D assigned by the model builder. Since no value of the heap object is provided, the method will create a symbolic constant representing the heap object.


\begin{DoxyParams}{Parameters}
{\em state} & The pre-\/state. \\
\hline
{\em pid} & The P\+I\+D of the process that triggers this execution. \\
\hline
{\em dyscope\+I\+D} & The dyscope I\+D. \\
\hline
{\em malloc\+I\+D} & The I\+D the malloc statement. \\
\hline
{\em element\+Type} & The symbolic type of the element to be contained in the new heap object. \\
\hline
{\em element\+Count} & The number of elements contained by the new heap object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The new state after the new heap object is added. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a336133449bfe76264c72cc15bb3e0bc3}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a71c4b5efdb8a18f3e9d6e724c0045d4f}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!merge\+Monostates@{merge\+Monostates}}
\index{merge\+Monostates@{merge\+Monostates}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{merge\+Monostates}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+merge\+Monostates (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{{\bf Immutable\+Collective\+Snapshots\+Entry}}]{entry}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a71c4b5efdb8a18f3e9d6e724c0045d4f}


Merges a set of \hyperlink{}{Immutable\+Mono\+State} to a F\+A\+K\+E global \hyperlink{}{Immutable\+State} which should only be used to evaluation. 

\+: For any two mono\+States in the array, they should be owned by different processes. \+: true.


\begin{DoxyParams}{Parameters}
{\em mono\+States} & The array of \hyperlink{}{Immutable\+Mono\+State} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a450c5462e9b7f8eaad36a3d4bbd744d0}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aa25cbfaca9b0e6a1d7aa7e15dc50ec87}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!num\+Symbolic\+Constants@{num\+Symbolic\+Constants}}
\index{num\+Symbolic\+Constants@{num\+Symbolic\+Constants}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{num\+Symbolic\+Constants}]{\setlength{\rightskip}{0pt plus 5cm}int edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+num\+Symbolic\+Constants (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aa25cbfaca9b0e6a1d7aa7e15dc50ec87}


Returns the number of symbolic constants appearing in the given state. 


\begin{DoxyParams}{Parameters}
{\em state} & the given state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of symbolic constants appearing in the given state. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a10e26f9469590145532c69c4ce08fcb1}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a319b79f1cb6f0ca0608b5bccf4a0151c}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!peek\+Collective\+Snapshots\+Entry@{peek\+Collective\+Snapshots\+Entry}}
\index{peek\+Collective\+Snapshots\+Entry@{peek\+Collective\+Snapshots\+Entry}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{peek\+Collective\+Snapshots\+Entry}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Immutable\+Collective\+Snapshots\+Entry} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+peek\+Collective\+Snapshots\+Entry (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{queue\+I\+D}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a319b79f1cb6f0ca0608b5bccf4a0151c}


Copy the top \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry}{Collective\+Snapshots\+Entry} from the specific snapshots queue, returns the copied snapshots entry. 


\begin{DoxyParams}{Parameters}
{\em state} & The current state \\
\hline
{\em queue\+I\+D} & The I\+D identifies a collective queue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ab66323bef446672f1b4de94f0ca09122}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab11e79aef8f8b8b80e830cbf48f03c1e}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!pop\+Call\+Stack@{pop\+Call\+Stack}}
\index{pop\+Call\+Stack@{pop\+Call\+Stack}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{pop\+Call\+Stack}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+pop\+Call\+Stack (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab11e79aef8f8b8b80e830cbf48f03c1e}


Pops an entry off the call stack for a process. 

Does not modify or remove and dynamic scopes (even if they become unreachable). Does not nullify or remove the process state (even if the call stack becomes empty).


\begin{DoxyParams}{Parameters}
{\em state} & The old state. \\
\hline
{\em pid} & The P\+I\+D of the process returning from a call. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state but with the call stack for the given process popped. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a3f70888fd06f2a1c4a72393cc2345531}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abd00efcbcd99ef258a98712c1a5519fd}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!process\+In\+Atomic@{process\+In\+Atomic}}
\index{process\+In\+Atomic@{process\+In\+Atomic}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{process\+In\+Atomic}]{\setlength{\rightskip}{0pt plus 5cm}int edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+process\+In\+Atomic (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_abd00efcbcd99ef258a98712c1a5519fd}


Returns the P\+I\+D of the process that holds the atomic lock at a certain state. 


\begin{DoxyParams}{Parameters}
{\em state} & The state to be checked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/1 iff there is no process holding the atomic lock, otherwise return the process that holds the atomic lock 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_aef485d98a0babfec8acc14a129cc4611}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3c7ba7469eca87e1359b63656f6de1fb}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!push\+Call\+Stack@{push\+Call\+Stack}}
\index{push\+Call\+Stack@{push\+Call\+Stack}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{push\+Call\+Stack}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+push\+Call\+Stack (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid, }
\item[{{\bf C\+I\+V\+L\+Function}}]{function, }
\item[{Symbolic\+Expression\mbox{[}$\,$\mbox{]}}]{arguments}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3c7ba7469eca87e1359b63656f6de1fb}


Pushes a new entry onto the call stack for a process. 

Used when a process calls a function. The process should already exist and have a non-\/empty call stack.


\begin{DoxyParams}{Parameters}
{\em state} & The old state \\
\hline
{\em pid} & The P\+I\+D of the process making the call \\
\hline
{\em function} & The function being called \\
\hline
{\em arguments} & The (actual) arguments to the function being called \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state with the given process having a new entry on its call stack. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a0ff6fe5b054069da0b20967e254b5ae4}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8eae26822f75dc67b3a588a725af7430}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!push\+Call\+Stack@{push\+Call\+Stack}}
\index{push\+Call\+Stack@{push\+Call\+Stack}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{push\+Call\+Stack}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+push\+Call\+Stack (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid, }
\item[{{\bf C\+I\+V\+L\+Function}}]{function, }
\item[{int}]{function\+Parent\+Dyscope, }
\item[{Symbolic\+Expression\mbox{[}$\,$\mbox{]}}]{arguments}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a8eae26822f75dc67b3a588a725af7430}


Pushes a new entry onto the call stack for a process. 

Used when a process calls a function. The process should already exist and have a non-\/empty call stack.


\begin{DoxyParams}{Parameters}
{\em state} & The old state \\
\hline
{\em pid} & The P\+I\+D of the process making the call \\
\hline
{\em function} & The function being called \\
\hline
{\em function\+Parent\+Dyscope} & The dyscope I\+D of the parent of the new function \\
\hline
{\em arguments} & The (actual) arguments to the function being called \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state with the given process having a new entry on its call stack. 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a8fc946088739b623a3ccc49ed2544b11}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a1a81054b9e512c38bcf873ce54c36896}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!release\+Atomic\+Lock@{release\+Atomic\+Lock}}
\index{release\+Atomic\+Lock@{release\+Atomic\+Lock}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{release\+Atomic\+Lock}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+release\+Atomic\+Lock (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a1a81054b9e512c38bcf873ce54c36896}


Releases the atomic lock, by updating the atomic lock variable with the undefined process value. 

If atomic lock of the given state is already released, this is a no op.


\begin{DoxyParams}{Parameters}
{\em state} & any non-\/null \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} state \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a state equivalent to given one except that no state owns the atomic lock 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_aaba1752dba05b39dc8fa982e1ee682d8}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5f969c52d703e39c812dfde91ad68d75}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!remove\+Process@{remove\+Process}}
\index{remove\+Process@{remove\+Process}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{remove\+Process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+remove\+Process (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5f969c52d703e39c812dfde91ad68d75}


Removes a process from the state. 

The process state associated to that process is set to null. No other part of the state is affected. To really get rid of the process state you need to call \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a57003566f5dd8c4905a7e630d90ad5ef}{collect\+Processes}.


\begin{DoxyParams}{Parameters}
{\em state} & The old state \\
\hline
{\em pid} & The P\+I\+D \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state with the process state set to null 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a1c324a5c8166701c1e6037005598f87b}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ad68188e38333826e7f585b5ceb858a08}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!set\+Location@{set\+Location}}
\index{set\+Location@{set\+Location}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{set\+Location}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+set\+Location (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid, }
\item[{{\bf Location}}]{location}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ad68188e38333826e7f585b5ceb858a08}


Sets the location of a process. 

This changes the top stack frame for the process so that it points to the new location. The given process must have a non-\/empty stack (although the location component of that frame is not used, so it is O\+K if it is null). There is no change of the access of variables from the current location to the target location.

This may involve adding and removing scopes, if the scope of the new location differs from the original scope.


\begin{DoxyParams}{Parameters}
{\em state} & The old state. \\
\hline
{\em pid} & The P\+I\+D of the process making the move. \\
\hline
{\em location} & The target location. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state with the given process at a new location, and scopes added and removed as necessary 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a6eca6e2fe2e004ad7b74dd4ffa49846e}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3d545b10a549db49479268ea772245b1}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!set\+Location@{set\+Location}}
\index{set\+Location@{set\+Location}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{set\+Location}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+set\+Location (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid, }
\item[{{\bf Location}}]{location, }
\item[{boolean}]{access\+Changed}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a3d545b10a549db49479268ea772245b1}


Sets the location of a process. 

This changes the top stack frame for the process so that it points to the new location. The given process must have a non-\/empty stack (although the location component of that frame is not used, so it is O\+K if it is null).

This may involve adding and removing scopes, if the scope of the new location differs from the original scope.


\begin{DoxyParams}{Parameters}
{\em state} & The old state. \\
\hline
{\em pid} & The P\+I\+D of the process making the move. \\
\hline
{\em location} & The target location. \\
\hline
{\em access\+Changed} & True iff there is change of variable accessing (write or read-\/only) from the current location to the target location \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the same as the old state with the given process at a new location, and scopes added and removed as necessary 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a02d59626c894538bab15a0e459c7b1ae}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2f48636d5dba0d57c3e7cf63e9980b9d}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!set\+Process\+State@{set\+Process\+State}}
\index{set\+Process\+State@{set\+Process\+State}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{set\+Process\+State}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+set\+Process\+State (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{{\bf Process\+State}}]{process\+State}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a2f48636d5dba0d57c3e7cf63e9980b9d}
Updates the state by replacing the process state with the given one where the P\+I\+D of the old process state is the same as the given process state. 

Precondition\+: the P\+I\+D of the given process state should be in \mbox{[}0, num\+Procs-\/1\mbox{]}. 


\begin{DoxyParams}{Parameters}
{\em state} & \hyperlink{structA}{A} non-\/null \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL}{C\+I\+V\+L} state \\
\hline
{\em process\+State} & The process state to assign to P\+I\+D \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The new state after updating the process with the specified P\+I\+D 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_aa3955ff83bd8eca124041041d8d4fd52}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae266fa51d2dea90e7e5d3ca8b45dd22b}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!set\+Variable@{set\+Variable}}
\index{set\+Variable@{set\+Variable}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{set\+Variable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+set\+Variable (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{{\bf Variable}}]{variable, }
\item[{int}]{pid, }
\item[{Symbolic\+Expression}]{value}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae266fa51d2dea90e7e5d3ca8b45dd22b}


Updates the value assigned to a variable in the state. 

Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value.


\begin{DoxyParams}{Parameters}
{\em state} & The old state \\
\hline
{\em variable} & The variable to update \\
\hline
{\em pid} & The P\+I\+D of the process containing the variable \\
\hline
{\em value} & The new value to be assigned to the variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the old state modified by updating the value of the variable 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a33ef600c8d89d0edb2ae51def702697b}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab1877edd7985bfa3bb4171fed7671472}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!set\+Variable@{set\+Variable}}
\index{set\+Variable@{set\+Variable}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{set\+Variable}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+set\+Variable (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{vid, }
\item[{int}]{scope\+Id, }
\item[{Symbolic\+Expression}]{value}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ab1877edd7985bfa3bb4171fed7671472}
Updates the value assigned to a variable in the state. Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value. 

In this version of the method, the variable is specified by its dynamic scope I\+D and variable I\+D. 


\begin{DoxyParams}{Parameters}
{\em state} & The old state \\
\hline
{\em vid} & variable I\+D number \\
\hline
{\em scope\+I\+D} & The I\+D of the dynamic scope containing the variable. This version of the method is useful when setting the target of a pointer. For a variable in the current lexical scope, use the version of the method without this argument \\
\hline
{\em value} & The new value to assign to the variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structA}{A} new state that is the old state modified by updating the value of the variable 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_ae266fa51d2dea90e7e5d3ca8b45dd22b}{set\+Variable(\+State, Variable, int, Symbolic\+Expression)} 
\end{DoxySeeAlso}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_ae708ff73f1b3327a5deb0b9b5016cd78}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_adbeb8d17faccb408984c62646ad3491d}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!simplify@{simplify}}
\index{simplify@{simplify}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{simplify}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+simplify (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_adbeb8d17faccb408984c62646ad3491d}


Simplifies all variable values in the state, using the path condition as the simplification context. 

\hyperlink{structA}{A} symbolic constant which is determined to have a concrete value (based on the path condition), may be entirely removed from the state by replacing every occurrence of that symbol with the concrete value.


\begin{DoxyParams}{Parameters}
{\em state} & Any \hyperlink{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State}{State} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The simplified state 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a6ad75dbebbe769245d9850b493ef1ce8}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5ca93a5b12557dcb6337cf3cf41862ec}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!symbolic\+Universe@{symbolic\+Universe}}
\index{symbolic\+Universe@{symbolic\+Universe}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{symbolic\+Universe}]{\setlength{\rightskip}{0pt plus 5cm}Symbolic\+Universe edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+symbolic\+Universe (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_a5ca93a5b12557dcb6337cf3cf41862ec}


Returns the symbolic universe used by this factory to manipulate symbolic expressions. 

\begin{DoxyReturn}{Returns}
the symbolic universe 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a545a89e6de9775ca52721c9c794da12b}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.

\hypertarget{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aefff2ccf75944f8eea5c77d95aeb3b5f}{}\index{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}!terminate\+Process@{terminate\+Process}}
\index{terminate\+Process@{terminate\+Process}!edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory@{edu\+::udel\+::cis\+::vsl\+::civl\+::state\+::\+I\+F\+::\+State\+Factory}}
\subsubsection[{terminate\+Process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+I\+F.\+State\+Factory.\+terminate\+Process (
\begin{DoxyParamCaption}
\item[{{\bf State}}]{state, }
\item[{int}]{pid}
\end{DoxyParamCaption}
)}\label{interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory_aefff2ccf75944f8eea5c77d95aeb3b5f}


Sets the process state for the designated process to be the process state with the empty stack. 


\begin{DoxyParams}{Parameters}
{\em state} & the old state \\
\hline
{\em pid} & the P\+I\+D of the process to terminate \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
state that is identical to old except that the process state for process P\+I\+D has been set to the process state with the empty stack 
\end{DoxyReturn}


Implemented in \hyperlink{classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory_a5318c37923f7a29e4ea586e4ed241f25}{edu.\+udel.\+cis.\+vsl.\+civl.\+state.\+common.\+immutable.\+Immutable\+State\+Factory}.



The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/arnabd/workspace/civl/trunk/src/edu/udel/cis/vsl/civl/state/\+I\+F/State\+Factory.\+java\end{DoxyCompactItemize}
