<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   &#160;<span id="projectnumber">CIVL</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>edu</b></li><li class="navelem"><b>udel</b></li><li class="navelem"><b>cis</b></li><li class="navelem"><b>vsl</b></li><li class="navelem"><a class="el" href="namespaceedu_1_1udel_1_1cis_1_1vsl_1_1civl.html">civl</a></li><li class="navelem"><b>state</b></li><li class="navelem"><b>common</b></li><li class="navelem"><b>immutable</b></li><li class="navelem"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html">ImmutableStateFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of StateFactory based on the Immutable Pattern.  
 <a href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory:</div>
<div class="dyncontent">
<div class="center"><img src="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory__inherit__graph.png" border="0" usemap="#edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_inherit__map" id="edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_inherit__map">
<area shape="rect" id="node2" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html" title="The state factory is used to create all state objects. " alt="" coords="64,5,239,47"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory:</div>
<div class="dyncontent">
<div class="center"><img src="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory__coll__graph.png" border="0" usemap="#edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_coll__map" alt="Collaboration graph"/></div>
<map name="edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_coll__map" id="edu_8udel_8cis_8vsl_8civl_8state_8common_8immutable_8ImmutableStateFactory_coll__map">
<area shape="rect" id="node2" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html" title="The state factory is used to create all state objects. " alt="" coords="47,5,222,47"/><area shape="rect" id="node5" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1ModelFactory.html" title="The factory to create all model components. " alt="" coords="45,173,225,215"/><area shape="rect" id="node6" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1dynamic_1_1IF_1_1SymbolicUtility.html" title="A SymbolicUtility provides all the common operations of symbolic expressions. " alt="" coords="37,239,232,280"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aebaa92f449641b63f067f72b1e64a358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebaa92f449641b63f067f72b1e64a358"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aebaa92f449641b63f067f72b1e64a358">ImmutableStateFactory</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1ModelFactory.html">ModelFactory</a> <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a7ec312e23cd9fd266b00fa9ef6bd0bab">modelFactory</a>, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1dynamic_1_1IF_1_1SymbolicUtility.html">SymbolicUtility</a> symbolicUtil, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory.html">MemoryUnitFactory</a> memFactory, GMCConfiguration gmcConfig, <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1config_1_1IF_1_1CIVLConfiguration.html">CIVLConfiguration</a> config)</td></tr>
<tr class="memdesc:aebaa92f449641b63f067f72b1e64a358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create all state objects. <br /></td></tr>
<tr class="separator:aebaa92f449641b63f067f72b1e64a358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0ab2bb34419888f0a80b1a6c9ac756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a1b0ab2bb34419888f0a80b1a6c9ac756">addProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, SymbolicExpression[] arguments, int callerPid)</td></tr>
<tr class="separator:a1b0ab2bb34419888f0a80b1a6c9ac756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a90cec9f8322c9b8abc34cd366f2b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a9a90cec9f8322c9b8abc34cd366f2b9e">addProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, int functionParentDyscope, SymbolicExpression[] arguments, int callerPid)</td></tr>
<tr class="separator:a9a90cec9f8322c9b8abc34cd366f2b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c70f6ea5fb68aaf09cb09087b006b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a62c70f6ea5fb68aaf09cb09087b006b1">canonic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, boolean <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4e0a1ff9fd037a1afdd7e9c6dce4a18b">collectProcesses</a>, boolean <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ac08af796a3dfdb6f0cce6c0c1afb8c68">collectScopes</a>, boolean <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a66fc6a266b28ded9287b0ec6d2621a94">collectHeaps</a>, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLHeapException </td></tr>
<tr class="separator:a62c70f6ea5fb68aaf09cb09087b006b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc6a266b28ded9287b0ec6d2621a94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a66fc6a266b28ded9287b0ec6d2621a94">collectHeaps</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLHeapException </td></tr>
<tr class="memdesc:a66fc6a266b28ded9287b0ec6d2621a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of heaps.  <a href="#a66fc6a266b28ded9287b0ec6d2621a94">More...</a><br /></td></tr>
<tr class="separator:a66fc6a266b28ded9287b0ec6d2621a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08af796a3dfdb6f0cce6c0c1afb8c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ac08af796a3dfdb6f0cce6c0c1afb8c68">collectScopes</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLHeapException </td></tr>
<tr class="memdesc:ac08af796a3dfdb6f0cce6c0c1afb8c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of dynamic scopes.  <a href="#ac08af796a3dfdb6f0cce6c0c1afb8c68">More...</a><br /></td></tr>
<tr class="separator:ac08af796a3dfdb6f0cce6c0c1afb8c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912ed0ca7a4414f2edc2be8e36faefde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a912ed0ca7a4414f2edc2be8e36faefde">getAtomicLock</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a912ed0ca7a4414f2edc2be8e36faefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that the process with the given PID now owns the atomic lock.  <a href="#a912ed0ca7a4414f2edc2be8e36faefde">More...</a><br /></td></tr>
<tr class="separator:a912ed0ca7a4414f2edc2be8e36faefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a89d58bd62a499947f0afac037379dd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a0a89d58bd62a499947f0afac037379dd">getNumStateInstances</a> ()</td></tr>
<tr class="memdesc:a0a89d58bd62a499947f0afac037379dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of objects of type State that have been instantiated since this JVM started.  <a href="#a0a89d58bd62a499947f0afac037379dd">More...</a><br /></td></tr>
<tr class="separator:a0a89d58bd62a499947f0afac037379dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0074abb7544acdde596a2fab96e669"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#acd0074abb7544acdde596a2fab96e669">getNumStatesSaved</a> ()</td></tr>
<tr class="memdesc:acd0074abb7544acdde596a2fab96e669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of states stored by this state factory.  <a href="#acd0074abb7544acdde596a2fab96e669">More...</a><br /></td></tr>
<tr class="separator:acd0074abb7544acdde596a2fab96e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8e3b14776e73ce1d08b175e3012cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6a8e3b14776e73ce1d08b175e3012cbd">initialState</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Model.html">Model</a> model)  throws CIVLHeapException </td></tr>
<tr class="memdesc:a6a8e3b14776e73ce1d08b175e3012cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonic, initial state for a <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> Model.  <a href="#a6a8e3b14776e73ce1d08b175e3012cbd">More...</a><br /></td></tr>
<tr class="separator:a6a8e3b14776e73ce1d08b175e3012cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c3918cae07c8e2689445dde49d065"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#af29c3918cae07c8e2689445dde49d065">isDescendantOf</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int ancestor, int descendant)</td></tr>
<tr class="memdesc:af29c3918cae07c8e2689445dde49d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one dyscope is strictly the descendant of the other (not equal to).  <a href="#af29c3918cae07c8e2689445dde49d065">More...</a><br /></td></tr>
<tr class="separator:af29c3918cae07c8e2689445dde49d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd6c8dfda79abc673ed958993b8cff2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a5fd6c8dfda79abc673ed958993b8cff2">lockedByAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a5fd6c8dfda79abc673ed958993b8cff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any process at the state is holding the atomic lock, i.e, the process is executing some atomic blocks.  <a href="#a5fd6c8dfda79abc673ed958993b8cff2">More...</a><br /></td></tr>
<tr class="separator:a5fd6c8dfda79abc673ed958993b8cff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bebd102aa4e515f7a532cb50751c46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ad7bebd102aa4e515f7a532cb50751c46">lowestCommonAncestor</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int one, int another)</td></tr>
<tr class="memdesc:ad7bebd102aa4e515f7a532cb50751c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lowest common ancestor of two given dyscopes.  <a href="#ad7bebd102aa4e515f7a532cb50751c46">More...</a><br /></td></tr>
<tr class="separator:ad7bebd102aa4e515f7a532cb50751c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f70888fd06f2a1c4a72393cc2345531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a3f70888fd06f2a1c4a72393cc2345531">popCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a3f70888fd06f2a1c4a72393cc2345531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops an entry off the call stack for a process.  <a href="#a3f70888fd06f2a1c4a72393cc2345531">More...</a><br /></td></tr>
<tr class="separator:a3f70888fd06f2a1c4a72393cc2345531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef485d98a0babfec8acc14a129cc4611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aef485d98a0babfec8acc14a129cc4611">processInAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:aef485d98a0babfec8acc14a129cc4611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PID of the process that holds the atomic lock at a certain state.  <a href="#aef485d98a0babfec8acc14a129cc4611">More...</a><br /></td></tr>
<tr class="separator:aef485d98a0babfec8acc14a129cc4611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff6fe5b054069da0b20967e254b5ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a0ff6fe5b054069da0b20967e254b5ae4">pushCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, SymbolicExpression[] arguments)</td></tr>
<tr class="memdesc:a0ff6fe5b054069da0b20967e254b5ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new entry onto the call stack for a process.  <a href="#a0ff6fe5b054069da0b20967e254b5ae4">More...</a><br /></td></tr>
<tr class="separator:a0ff6fe5b054069da0b20967e254b5ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc946088739b623a3ccc49ed2544b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a8fc946088739b623a3ccc49ed2544b11">pushCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, int functionParentDyscope, SymbolicExpression[] arguments)</td></tr>
<tr class="memdesc:a8fc946088739b623a3ccc49ed2544b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new entry onto the call stack for a process.  <a href="#a8fc946088739b623a3ccc49ed2544b11">More...</a><br /></td></tr>
<tr class="separator:a8fc946088739b623a3ccc49ed2544b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0a1ff9fd037a1afdd7e9c6dce4a18b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4e0a1ff9fd037a1afdd7e9c6dce4a18b">collectProcesses</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a4e0a1ff9fd037a1afdd7e9c6dce4a18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of the process states.  <a href="#a4e0a1ff9fd037a1afdd7e9c6dce4a18b">More...</a><br /></td></tr>
<tr class="separator:a4e0a1ff9fd037a1afdd7e9c6dce4a18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5318c37923f7a29e4ea586e4ed241f25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a5318c37923f7a29e4ea586e4ed241f25">terminateProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a5318c37923f7a29e4ea586e4ed241f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process state for the designated process to be the process state with the empty stack.  <a href="#a5318c37923f7a29e4ea586e4ed241f25">More...</a><br /></td></tr>
<tr class="separator:a5318c37923f7a29e4ea586e4ed241f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c324a5c8166701c1e6037005598f87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a1c324a5c8166701c1e6037005598f87b">removeProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a1c324a5c8166701c1e6037005598f87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a process from the state.  <a href="#a1c324a5c8166701c1e6037005598f87b">More...</a><br /></td></tr>
<tr class="separator:a1c324a5c8166701c1e6037005598f87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba1752dba05b39dc8fa982e1ee682d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aaba1752dba05b39dc8fa982e1ee682d8">releaseAtomicLock</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:aaba1752dba05b39dc8fa982e1ee682d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the atomic lock, by updating the atomic lock variable with the undefined process value.  <a href="#aaba1752dba05b39dc8fa982e1ee682d8">More...</a><br /></td></tr>
<tr class="separator:aaba1752dba05b39dc8fa982e1ee682d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d59626c894538bab15a0e459c7b1ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a02d59626c894538bab15a0e459c7b1ae">setLocation</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a> location, boolean accessChanged)</td></tr>
<tr class="memdesc:a02d59626c894538bab15a0e459c7b1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedure:  <a href="#a02d59626c894538bab15a0e459c7b1ae">More...</a><br /></td></tr>
<tr class="separator:a02d59626c894538bab15a0e459c7b1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3955ff83bd8eca124041041d8d4fd52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aa3955ff83bd8eca124041041d8d4fd52">setProcessState</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1ProcessState.html">ProcessState</a> p)</td></tr>
<tr class="separator:aa3955ff83bd8eca124041041d8d4fd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae708ff73f1b3327a5deb0b9b5016cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ae708ff73f1b3327a5deb0b9b5016cd78">setVariable</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int vid, int scopeId, SymbolicExpression value)</td></tr>
<tr class="separator:ae708ff73f1b3327a5deb0b9b5016cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ef600c8d89d0edb2ae51def702697b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a33ef600c8d89d0edb2ae51def702697b">setVariable</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a> variable, int pid, SymbolicExpression value)</td></tr>
<tr class="memdesc:a33ef600c8d89d0edb2ae51def702697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value assigned to a variable in the state.  <a href="#a33ef600c8d89d0edb2ae51def702697b">More...</a><br /></td></tr>
<tr class="separator:a33ef600c8d89d0edb2ae51def702697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad75dbebbe769245d9850b493ef1ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6ad75dbebbe769245d9850b493ef1ce8">simplify</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a6ad75dbebbe769245d9850b493ef1ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies all variable values in the state, using the path condition as the simplification context.  <a href="#a6ad75dbebbe769245d9850b493ef1ce8">More...</a><br /></td></tr>
<tr class="separator:a6ad75dbebbe769245d9850b493ef1ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545a89e6de9775ca52721c9c794da12b"><td class="memItemLeft" align="right" valign="top">SymbolicUniverse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a545a89e6de9775ca52721c9c794da12b">symbolicUniverse</a> ()</td></tr>
<tr class="memdesc:a545a89e6de9775ca52721c9c794da12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbolic universe used by this factory to manipulate symbolic expressions.  <a href="#a545a89e6de9775ca52721c9c794da12b">More...</a><br /></td></tr>
<tr class="separator:a545a89e6de9775ca52721c9c794da12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521481b4006af34010ce856f4f539a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a521481b4006af34010ce856f4f539a39">malloc</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int dyscopeId, int mallocId, SymbolicExpression heapObject)</td></tr>
<tr class="memdesc:a521481b4006af34010ce856f4f539a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope.  <a href="#a521481b4006af34010ce856f4f539a39">More...</a><br /></td></tr>
<tr class="separator:a521481b4006af34010ce856f4f539a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336133449bfe76264c72cc15bb3e0bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a336133449bfe76264c72cc15bb3e0bc3">malloc</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, int dyscopeId, int mallocId, SymbolicType elementType, NumericExpression elementCount)</td></tr>
<tr class="memdesc:a336133449bfe76264c72cc15bb3e0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object for the given malloc ID in the heap of the given dyscope.  <a href="#a336133449bfe76264c72cc15bb3e0bc3">More...</a><br /></td></tr>
<tr class="separator:a336133449bfe76264c72cc15bb3e0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb5cfa400e857cedde973811105fed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#adbb5cfa400e857cedde973811105fed9">deallocate</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, SymbolicExpression heapObjectPointer, int dyscopeId, int mallocId, int index)</td></tr>
<tr class="memdesc:adbb5cfa400e857cedde973811105fed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a heap object from the heap of a given dyscope.  <a href="#adbb5cfa400e857cedde973811105fed9">More...</a><br /></td></tr>
<tr class="separator:adbb5cfa400e857cedde973811105fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca6e2fe2e004ad7b74dd4ffa49846e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6eca6e2fe2e004ad7b74dd4ffa49846e">setLocation</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a> location)</td></tr>
<tr class="memdesc:a6eca6e2fe2e004ad7b74dd4ffa49846e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the location of a process.  <a href="#a6eca6e2fe2e004ad7b74dd4ffa49846e">More...</a><br /></td></tr>
<tr class="separator:a6eca6e2fe2e004ad7b74dd4ffa49846e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56c28e8f145bfc53856b8be3eca9a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac56c28e8f145bfc53856b8be3eca9a01"></a>
<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory.html">MemoryUnitFactory</a>&#160;</td><td class="memItemRight" valign="bottom"><b>memUnitFactory</b> ()</td></tr>
<tr class="separator:ac56c28e8f145bfc53856b8be3eca9a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61437ae4ca0fb099c9f79ddceaa5d07c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a61437ae4ca0fb099c9f79ddceaa5d07c">incrementNumSymbolicConstants</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a61437ae4ca0fb099c9f79ddceaa5d07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of symbolic constants by one.  <a href="#a61437ae4ca0fb099c9f79ddceaa5d07c">More...</a><br /></td></tr>
<tr class="separator:a61437ae4ca0fb099c9f79ddceaa5d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e26f9469590145532c69c4ce08fcb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a10e26f9469590145532c69c4ce08fcb1">numSymbolicConstants</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a10e26f9469590145532c69c4ce08fcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of symbolic constants appearing in the given state.  <a href="#a10e26f9469590145532c69c4ce08fcb1">More...</a><br /></td></tr>
<tr class="separator:a10e26f9469590145532c69c4ce08fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bd3853959303e304debbc2ae22f5a4"><td class="memItemLeft" align="right" valign="top">Map&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aa4bd3853959303e304debbc2ae22f5a4">inputVariableValueMap</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:aa4bd3853959303e304debbc2ae22f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map of variable and value of input variables at the given state.  <a href="#aa4bd3853959303e304debbc2ae22f5a4">More...</a><br /></td></tr>
<tr class="separator:aa4bd3853959303e304debbc2ae22f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948646856ef1cd713a740aecc22d34c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a948646856ef1cd713a740aecc22d34c0">commitUpdatedChannelsToEntries</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueId, SymbolicExpression[] newBuffers)</td></tr>
<tr class="memdesc:a948646856ef1cd713a740aecc22d34c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all entries in a collective queue with a group of message buffers.  <a href="#a948646856ef1cd713a740aecc22d34c0">More...</a><br /></td></tr>
<tr class="separator:a948646856ef1cd713a740aecc22d34c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450c5462e9b7f8eaad36a3d4bbd744d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a450c5462e9b7f8eaad36a3d4bbd744d0">mergeMonostates</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> entry)</td></tr>
<tr class="memdesc:a450c5462e9b7f8eaad36a3d4bbd744d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a set of <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMonoState.html">ImmutableMonoState</a> to a FAKE global <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> which should only be used to evaluation.  <a href="#a450c5462e9b7f8eaad36a3d4bbd744d0">More...</a><br /></td></tr>
<tr class="separator:a450c5462e9b7f8eaad36a3d4bbd744d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7514e9e3d808ecf1b7f5b375cf5cf8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ae7514e9e3d808ecf1b7f5b375cf5cf8f">addToCollectiveSnapshotsEntry</a> (<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> state, int pid, int place, int queueID, int entryPos, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a> assertion)</td></tr>
<tr class="memdesc:ae7514e9e3d808ecf1b7f5b375cf5cf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot on current state then store the snapshot with the collective assertion into an collectiveSnapshotsEntry.  <a href="#ae7514e9e3d808ecf1b7f5b375cf5cf8f">More...</a><br /></td></tr>
<tr class="separator:ae7514e9e3d808ecf1b7f5b375cf5cf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4462151d1c85d4d4a878d88d6cc96350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4462151d1c85d4d4a878d88d6cc96350">createCollectiveSnapshotsEnrty</a> (<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> state, int pid, int numProcesses, int place, int queueID, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a> assertion, SymbolicExpression channels, ContractKind kind, List&lt; <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&gt; pickUpStation)</td></tr>
<tr class="memdesc:a4462151d1c85d4d4a878d88d6cc96350"><td class="mdescLeft">&#160;</td><td class="mdescRight">The process with "pid" creates a fresh new <a class="el" href="">CollectiveSnapshotsEntry</a>, then saves its own snapshot in the new entry.  <a href="#a4462151d1c85d4d4a878d88d6cc96350">More...</a><br /></td></tr>
<tr class="separator:a4462151d1c85d4d4a878d88d6cc96350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d1895551e52122c30a1eb645f7f690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a54d1895551e52122c30a1eb645f7f690">dequeueCollectiveSnapshotsEntry</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:a54d1895551e52122c30a1eb645f7f690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues an <a class="el" href="">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns a new state.  <a href="#a54d1895551e52122c30a1eb645f7f690">More...</a><br /></td></tr>
<tr class="separator:a54d1895551e52122c30a1eb645f7f690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66323bef446672f1b4de94f0ca09122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ab66323bef446672f1b4de94f0ca09122">peekCollectiveSnapshotsEntry</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:ab66323bef446672f1b4de94f0ca09122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the top <a class="el" href="">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns the copied snapshots entry.  <a href="#ab66323bef446672f1b4de94f0ca09122">More...</a><br /></td></tr>
<tr class="separator:ab66323bef446672f1b4de94f0ca09122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab7303606615d76222aff56ce7125ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a2ab7303606615d76222aff56ce7125ef">getSnapshotsQueue</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:a2ab7303606615d76222aff56ce7125ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding snapshot queue by giving the identifier of an MPI communicator (The identifier is a component of the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> MPI library implementation).  <a href="#a2ab7303606615d76222aff56ce7125ef">More...</a><br /></td></tr>
<tr class="separator:a2ab7303606615d76222aff56ce7125ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beeeb4eaf17158d4a87e6ff16f2a0f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6beeeb4eaf17158d4a87e6ff16f2a0f2"></a>
<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copySnapshotsQueues</b> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> fromState, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> toState)</td></tr>
<tr class="separator:a6beeeb4eaf17158d4a87e6ff16f2a0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7539884a484167b2e4c1b658fbcdb44c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7539884a484167b2e4c1b658fbcdb44c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numSymbolicInputs</b> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="separator:a7539884a484167b2e4c1b658fbcdb44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd1ae7f315d534836864cc76a4fce0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6fd1ae7f315d534836864cc76a4fce0f">incrementNumSymbolicInputs</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a6fd1ae7f315d534836864cc76a4fce0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of symbolic constants by one.  <a href="#a6fd1ae7f315d534836864cc76a4fce0f">More...</a><br /></td></tr>
<tr class="separator:a6fd1ae7f315d534836864cc76a4fce0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025b6b9e6b52f0f5a7f47a946e35e02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a025b6b9e6b52f0f5a7f47a946e35e02d">enterAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a025b6b9e6b52f0f5a7f47a946e35e02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pid enters a new atomic section.  <a href="#a025b6b9e6b52f0f5a7f47a946e35e02d">More...</a><br /></td></tr>
<tr class="separator:a025b6b9e6b52f0f5a7f47a946e35e02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3151f31996c6239ac71a2714ea54724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ac3151f31996c6239ac71a2714ea54724">leaveAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:ac3151f31996c6239ac71a2714ea54724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pid leaves an atomic section.  <a href="#ac3151f31996c6239ac71a2714ea54724">More...</a><br /></td></tr>
<tr class="separator:ac3151f31996c6239ac71a2714ea54724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aab7051f4b53cc88f543f90a95805b9a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aab7051f4b53cc88f543f90a95805b9a8">createNewProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:aab7051f4b53cc88f543f90a95805b9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new initial process state to the given state.  <a href="#aab7051f4b53cc88f543f90a95805b9a8">More...</a><br /></td></tr>
<tr class="separator:aab7051f4b53cc88f543f90a95805b9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6ae867cb1e6c559f9deeeccfdc77d2"><td class="memItemLeft" align="right" valign="top">SymbolicExpression[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a7f6ae867cb1e6c559f9deeeccfdc77d2">initialValues</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Scope.html">Scope</a> lexicalScope)</td></tr>
<tr class="memdesc:a7f6ae867cb1e6c559f9deeeccfdc77d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the initial value of a given lexical scope.  <a href="#a7f6ae867cb1e6c559f9deeeccfdc77d2">More...</a><br /></td></tr>
<tr class="separator:a7f6ae867cb1e6c559f9deeeccfdc77d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680a2342922a0e5db447a9f0fd5857f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a680a2342922a0e5db447a9f0fd5857f3">pushCallStack2</a> (<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, int functionParentDyscope, SymbolicExpression[] arguments, int callerPid)</td></tr>
<tr class="memdesc:a680a2342922a0e5db447a9f0fd5857f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">General method for pushing a frame onto a call stack, whether or not the call stack is for a new process (and therefore empty).  <a href="#a680a2342922a0e5db447a9f0fd5857f3">More...</a><br /></td></tr>
<tr class="separator:a680a2342922a0e5db447a9f0fd5857f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756be1f64eb8b339587e93fe4370781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStackEntry.html">ImmutableStackEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a3756be1f64eb8b339587e93fe4370781">stackEntry</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a> location, int dyscopeId)</td></tr>
<tr class="memdesc:a3756be1f64eb8b339587e93fe4370781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new call stack entry.  <a href="#a3756be1f64eb8b339587e93fe4370781">More...</a><br /></td></tr>
<tr class="separator:a3756be1f64eb8b339587e93fe4370781"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7ec312e23cd9fd266b00fa9ef6bd0bab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec312e23cd9fd266b00fa9ef6bd0bab"></a>
<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1ModelFactory.html">ModelFactory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a7ec312e23cd9fd266b00fa9ef6bd0bab">modelFactory</a></td></tr>
<tr class="memdesc:a7ec312e23cd9fd266b00fa9ef6bd0bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The model factory. <br /></td></tr>
<tr class="separator:a7ec312e23cd9fd266b00fa9ef6bd0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4563fce2eb486daf3420b7793167aa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4563fce2eb486daf3420b7793167aa8a"></a>
SymbolicExpression&#160;</td><td class="memItemRight" valign="bottom"><b>undefinedProcessValue</b></td></tr>
<tr class="separator:a4563fce2eb486daf3420b7793167aa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67d4da200ebd4e41724ff0d35681897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67d4da200ebd4e41724ff0d35681897"></a>
SymbolicUniverse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ad67d4da200ebd4e41724ff0d35681897">universe</a></td></tr>
<tr class="memdesc:ad67d4da200ebd4e41724ff0d35681897"><td class="mdescLeft">&#160;</td><td class="mdescRight">The symbolic universe, provided by SARL. <br /></td></tr>
<tr class="separator:ad67d4da200ebd4e41724ff0d35681897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6237d293d5511c71eec8e25bac53ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e6237d293d5511c71eec8e25bac53ed"></a>
<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1dynamic_1_1IF_1_1SymbolicUtility.html">SymbolicUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><b>symbolicUtil</b></td></tr>
<tr class="separator:a3e6237d293d5511c71eec8e25bac53ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4d794bb46aebe402fc0ae86a758145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4d794bb46aebe402fc0ae86a758145"></a>
Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>emptyHeapErrorSet</b> = new HashSet&lt;&gt;(0)</td></tr>
<tr class="separator:abc4d794bb46aebe402fc0ae86a758145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bb101beff17f74873a8ad73d6197b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93bb101beff17f74873a8ad73d6197b6"></a>
GMCConfiguration&#160;</td><td class="memItemRight" valign="bottom"><b>gmcConfig</b></td></tr>
<tr class="separator:a93bb101beff17f74873a8ad73d6197b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of StateFactory based on the Immutable Pattern. </p>
<dl class="section author"><dt>Author</dt><dd>Timothy K. Zirkel (zirkel) </dd>
<dd>
Timothy J. McClory (tmcclory) </dd>
<dd>
Stephen F. Siegel (siegel) </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1b0ab2bb34419888f0a80b1a6c9ac756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.addProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callerPid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an IllegalArgumentException is thrown. Hence the calling process must have a non-empty call stack. </p>
<p>The PID of the new process will be <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html#a1fb9bc3c57e059c2885a73ba4d08b441">State#numProcs()</a>, where state is the pre-state (the given state), not the new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">function</td><td>The function in which the new process starts. </td></tr>
    <tr><td class="paramname">arguments</td><td>The arguments to this function call. </td></tr>
    <tr><td class="paramname">callerPid</td><td>the PID of the process that is creating the new process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2c05d9800df5a48cfd13da18caf24364">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a9a90cec9f8322c9b8abc34cd366f2b9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.addProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>functionParentDyscope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callerPid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an IllegalArgumentException is thrown. Hence the calling process must have a non-empty call stack. </p>
<p>The PID of the new process will be <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html#a1fb9bc3c57e059c2885a73ba4d08b441">State#numProcs()</a>, where state is the pre-state (the given state), not the new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">function</td><td>The function in which the new process starts. </td></tr>
    <tr><td class="paramname">functionParentDyscope</td><td>The dyscope ID of the parent of the new function </td></tr>
    <tr><td class="paramname">arguments</td><td>The arguments to this function call. </td></tr>
    <tr><td class="paramname">callerPid</td><td>the PID of the process that is creating the new process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#af2a497fca3857a16cda6ddda36d2eb49">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ae7514e9e3d808ecf1b7f5b375cf5cf8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.addToCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entryPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>assertion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a snapshot on current state then store the snapshot with the collective assertion into an collectiveSnapshotsEntry. </p>
<p>If the global state has a queue, then either create a new entry then enqueue, or modify a existing entry, otherwise create both a queue and a entry. Return the new or modified entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process </td></tr>
    <tr><td class="paramname">place</td><td>The place of the process in the collective entry </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective entry </td></tr>
    <tr><td class="paramname">entryPos</td><td>The position of the entry in the collective queue </td></tr>
    <tr><td class="paramname">assertion</td><td>The expression of a assertion asserted by the process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a7948dbf498b93bb9e67a757450dfc421">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a62c70f6ea5fb68aaf09cb09087b006b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.canonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectProcesses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectScopes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectHeaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In this implementation of canonic: process states are collected, heaps are collected, dynamic scopes are collected, the flyweight representative is taken, simplify is called if that option is selected, then the flyweight representative is taken again. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CIVLStateException</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a99001c497b2ff46cd098525744a7d0c1">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a66fc6a266b28ded9287b0ec6d2621a94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.collectHeaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of heaps. </p>
<p>Computes the set of reachable heap objects, and removes all unreachable heap objects. Renumbers heap objects in a canonic way. Updates all pointers in the state accordingly. This operation should be completely invisible to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state after canonicalizing heaps, which may be this state or a new one </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a78a17339ebd0be7dacaf1f06e78626d7">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a4e0a1ff9fd037a1afdd7e9c6dce4a18b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.collectProcesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of the process states. </p>
<p>Removes any process state that is null. Renumbers the PIDs so that there are no gaps (and start from 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state with processes collected </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a57003566f5dd8c4905a7e630d90ad5ef">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ac08af796a3dfdb6f0cce6c0c1afb8c68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.collectScopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of dynamic scopes. </p>
<p>Compute the set of reachable dynamic scopes, and removes any which are unreachable. Renumbers the dynamic scopes in a canonic way. Updates all scope references in the state. This operation should be completely invisible to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state after canonicalizing scopes, which may be this state or a new one </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a4ffda85305907c945cc3ffb2d3339eeb">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a948646856ef1cd713a740aecc22d34c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.commitUpdatedChannelsToEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>newChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all entries in a collective queue with a group of message buffers. </p>
<p>Note: The entry in position i will be updated with the message buffers in newBuffers[i]. The 0 position in collective queue is the head of the queue. The reason of using an array of message buffers to update the collective queue is to prevent the queue in state be changed for other purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueId</td><td>The ID of the collective queue </td></tr>
    <tr><td class="paramname">newChannels</td><td>The array of new message buffers. see <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html#a41f3b2e873b8f0e650cab149bbe4f129">CollectiveSnapshotsEntry#getMsgBuffers()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abb62af481c4c0f8bbc5091b16f1d9d75">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a4462151d1c85d4d4a878d88d6cc96350"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.createCollectiveSnapshotsEnrty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numProcesses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>assertion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContractKind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&gt;&#160;</td>
          <td class="paramname"><em>pickUpStation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The process with "pid" creates a fresh new <a class="el" href="">CollectiveSnapshotsEntry</a>, then saves its own snapshot in the new entry. </p>
<p>This function returns the new state with a new entry in one of its snapshots queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process </td></tr>
    <tr><td class="paramname">numProcesses</td><td>The number of processes participating this collective entry </td></tr>
    <tr><td class="paramname">place</td><td>The place of the process in the collective entry </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
    <tr><td class="paramname">assertion</td><td>The expression of the assertion asserted by the processes </td></tr>
    <tr><td class="paramname">channels</td><td>Message buffer snapshot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aaa4576f13147144139eb71f61c506c7b">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aab7051f4b53cc88f543f90a95805b9a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.createNewProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new initial process state to the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new instance of state with only the process states changed. </dd></dl>

</div>
</div>
<a class="anchor" id="adbb5cfa400e857cedde973811105fed9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>heapObjectPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates a heap object from the heap of a given dyscope. </p>
<p>It marks the heap object as INVALID instead of removing it, updates any pointer to that removed object to be an UNDEFINED pointer, which is defined by the symbolic utility. The removal of the heap object happens later when the heap gets collected during state canonicalization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a521481b4006af34010ce856f4f539a39" title="Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope...">malloc</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">heapObjectPointer</td><td>The pointer which points to the heap object to be removed. </td></tr>
    <tr><td class="paramname">dyscopeId</td><td>The ID of the dyscope where the pointer points to. </td></tr>
    <tr><td class="paramname">mallocId</td><td>The malloc ID of the heap object to be removed, i.e., the index of the heap field in the heap. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the heap object in the heap field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state after the heap object is removed from the heap, and corresponding pointers updated. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae67ff5361d7dda8a7b1ca1b3a7d6ad48">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a54d1895551e52122c30a1eb645f7f690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.dequeueCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues an <a class="el" href="">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns a new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a79263e51d0e37343b1211adb8f1f19f1">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a025b6b9e6b52f0f5a7f47a946e35e02d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.enterAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process pid enters a new atomic section. </p>
<p><br />
 Precondition: no other processes hold the atomic lock<br />
 If the process already holds the atomic lock, then its atomic count is incremented; <br />
 if the process doesn't hold the atomic lock, then the atomic lock is obtained and its atomic count is set to be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state after process pid enters a new atomic section </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a20c86533f0d632ee5258f90c464d596e">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a912ed0ca7a4414f2edc2be8e36faefde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.getAtomicLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declares that the process with the given PID now owns the atomic lock. </p>
<p>Precondition: no process is holding the atomic lock in the given state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process that is going to take the atomic lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a state equivalent to given one except that process PID now owns the atomic lock </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aeba2dd3ec097f8086d633109f66419df">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a0a89d58bd62a499947f0afac037379dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.getNumStateInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of objects of type State that have been instantiated since this JVM started. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of states instantiated </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2e8deab13e632331d44f30808e245bd3">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="acd0074abb7544acdde596a2fab96e669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.getNumStatesSaved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of states stored by this state factory. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of states stored </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5442b4d2a0f993e07a9bd403ebdcd917">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab7303606615d76222aff56ce7125ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> [] edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.getSnapshotsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the corresponding snapshot queue by giving the identifier of an MPI communicator (The identifier is a component of the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> MPI library implementation). </p>
<p>If there is no such a snapshot queue for the MPI communicator, returns an empty array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of a MPI communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a03ae05bbe6479f7111e129a649cfed4b">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a61437ae4ca0fb099c9f79ddceaa5d07c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.incrementNumSymbolicConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the number of symbolic constants by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state whole number of symbolic constants is to be increased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a38d4a9ddfedabc175ca4f3339e429ab7">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a6fd1ae7f315d534836864cc76a4fce0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.incrementNumSymbolicInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increase the number of symbolic constants by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state whole number of symbolic constants is to be increased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#afb5218196825ebba4a22fb05335a008c">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a6a8e3b14776e73ce1d08b175e3012cbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.initialState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Model.html">Model</a>&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the canonic, initial state for a <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> Model. </p>
<dl class="section return"><dt>Returns</dt><dd>the initial state </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abcd886f831cb9db1dac78c3aee029751">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a7f6ae867cb1e6c559f9deeeccfdc77d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SymbolicExpression [] edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.initialValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Scope.html">Scope</a>&#160;</td>
          <td class="paramname"><em>lexicalScope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the initial value of a given lexical scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lexicalScope</td><td>The lexical scope whose variables are to be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of initial values of variables of the given lexical scope. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4bd3853959303e304debbc2ae22f5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Map&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.inputVariableValueMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the map of variable and value of input variables at the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8f666801e5c6522fcdc81b508cf1e10d">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="af29c3918cae07c8e2689445dde49d065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boolean edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.isDescendantOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ancestor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descendant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if one dyscope is strictly the descendant of the other (not equal to). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state. </td></tr>
    <tr><td class="paramname">ancestor</td><td>The ID of the ancestor dyscope. </td></tr>
    <tr><td class="paramname">descendant</td><td>The ID of the descendant dyscope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff ancestor dyscope is really an ancestor of the descendant dyscope and they must not be equal to each other. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab2ba56b706c95a3afbe32c54504c5b16">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ac3151f31996c6239ac71a2714ea54724"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.leaveAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process pid leaves an atomic section. </p>
<p><br />
 Precondition: in the given state, the process pid holds the atomic lock and its atomic count is greater than zero.<br />
 The atomic count is decremented by 1 after this method;<br />
 if the resultant atomic count is 0, then the atomic lock is released as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state after process pid leaves an atomic section </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ace7452c8c5a59d8862e3fc189577cf8b">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a5fd6c8dfda79abc673ed958993b8cff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boolean edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.lockedByAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if any process at the state is holding the atomic lock, i.e, the process is executing some atomic blocks. </p>
<p>This information is maintained as a global variable of <code>$proc</code> type in the root scope in the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> model (always with index 0), and it gets automatically updated when process id's are renumbered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the value of the variable atomic lock is not undefined. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8960b6b6ec0ad03227bf46ee17b19ed1">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ad7bebd102aa4e515f7a532cb50751c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.lowestCommonAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the lowest common ancestor of two given dyscopes. </p>
<p>The returned value is always a dyscope ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state. </td></tr>
    <tr><td class="paramname">one</td><td>One dyscope. </td></tr>
    <tr><td class="paramname">another</td><td>Another dynamic scope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dyscope ID of the lowest common ancestor of the two given dyscopes. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a7bb8f08bb0e64d60c886d2cd482e9c80">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a521481b4006af34010ce856f4f539a39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>heapObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope. </p>
<p>For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc ID assigned by the model builder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">dyscopeID</td><td>The dyscope ID. </td></tr>
    <tr><td class="paramname">mallocID</td><td>The ID the malloc statement. </td></tr>
    <tr><td class="paramname">heapObject</td><td>The value of the new heap object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after the new heap object </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2d470ef099fa677050a049e6ffb0090f">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a336133449bfe76264c72cc15bb3e0bc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicType&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericExpression&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object for the given malloc ID in the heap of the given dyscope. </p>
<p>For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc ID assigned by the model builder. Since no value of the heap object is provided, the method will create a symbolic constant representing the heap object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process that triggers this execution. </td></tr>
    <tr><td class="paramname">dyscopeID</td><td>The dyscope ID. </td></tr>
    <tr><td class="paramname">mallocID</td><td>The ID the malloc statement. </td></tr>
    <tr><td class="paramname">elementType</td><td>The symbolic type of the element to be contained in the new heap object. </td></tr>
    <tr><td class="paramname">elementCount</td><td>The number of elements contained by the new heap object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after the new heap object is added. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae7914fbfe856e913a2f9ad694ed01b9b">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a450c5462e9b7f8eaad36a3d4bbd744d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.mergeMonostates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges a set of <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMonoState.html">ImmutableMonoState</a> to a FAKE global <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> which should only be used to evaluation. </p>
<p>: For any two monoStates in the array, they should be owned by different processes. : true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monoStates</td><td>The array of <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableMonoState.html">ImmutableMonoState</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a71c4b5efdb8a18f3e9d6e724c0045d4f">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a10e26f9469590145532c69c4ce08fcb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.numSymbolicConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of symbolic constants appearing in the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the given state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of symbolic constants appearing in the given state. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aa25cbfaca9b0e6a1d7aa7e15dc50ec87">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ab66323bef446672f1b4de94f0ca09122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.peekCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the top <a class="el" href="">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns the copied snapshots entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a319b79f1cb6f0ca0608b5bccf4a0151c">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a3f70888fd06f2a1c4a72393cc2345531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.popCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops an entry off the call stack for a process. </p>
<p>Does not modify or remove and dynamic scopes (even if they become unreachable). Does not nullify or remove the process state (even if the call stack becomes empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process returning from a call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state but with the call stack for the given process popped. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab11e79aef8f8b8b80e830cbf48f03c1e">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aef485d98a0babfec8acc14a129cc4611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.processInAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the PID of the process that holds the atomic lock at a certain state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 iff there is no process holding the atomic lock, otherwise return the process that holds the atomic lock </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abd00efcbcd99ef258a98712c1a5519fd">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a0ff6fe5b054069da0b20967e254b5ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.pushCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new entry onto the call stack for a process. </p>
<p>Used when a process calls a function. The process should already exist and have a non-empty call stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the call </td></tr>
    <tr><td class="paramname">function</td><td>The function being called </td></tr>
    <tr><td class="paramname">arguments</td><td>The (actual) arguments to the function being called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process having a new entry on its call stack. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a3c7ba7469eca87e1359b63656f6de1fb">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc946088739b623a3ccc49ed2544b11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.pushCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>functionParentDyscope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new entry onto the call stack for a process. </p>
<p>Used when a process calls a function. The process should already exist and have a non-empty call stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the call </td></tr>
    <tr><td class="paramname">function</td><td>The function being called </td></tr>
    <tr><td class="paramname">functionParentDyscope</td><td>The dyscope ID of the parent of the new function </td></tr>
    <tr><td class="paramname">arguments</td><td>The (actual) arguments to the function being called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process having a new entry on its call stack. </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8eae26822f75dc67b3a588a725af7430">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a680a2342922a0e5db447a9f0fd5857f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.pushCallStack2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>functionParentDyscope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callerPid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General method for pushing a frame onto a call stack, whether or not the call stack is for a new process (and therefore empty). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the initial state </td></tr>
    <tr><td class="paramname">pid</td><td>the PID of the process whose stack is to be modified; this stack may be empty </td></tr>
    <tr><td class="paramname">function</td><td>the called function that will be pushed onto the stack </td></tr>
    <tr><td class="paramname">functionParentDyscope</td><td>The dyscope ID of the parent of the new function </td></tr>
    <tr><td class="paramname">arguments</td><td>the arguments to the function </td></tr>
    <tr><td class="paramname">callerPid</td><td>the PID of the process that is creating the new frame. For an ordinary function call, this will be the same as pid. For a "spawn" command, callerPid will be different from pid and process pid will be new and have an empty stack. Exception: if callerPid is -1 then the new dynamic scope will have no parent; this is used for pushing the original system function, which has no caller </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new stack with new frame on call stack of process pid </dd></dl>

</div>
</div>
<a class="anchor" id="aaba1752dba05b39dc8fa982e1ee682d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.releaseAtomicLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the atomic lock, by updating the atomic lock variable with the undefined process value. </p>
<p>If atomic lock of the given state is already released, this is a no op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a state equivalent to given one except that no state owns the atomic lock </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a1a81054b9e512c38bcf873ce54c36896">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a1c324a5c8166701c1e6037005598f87b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.removeProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a process from the state. </p>
<p>The process state associated to that process is set to null. No other part of the state is affected. To really get rid of the process state you need to call <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4e0a1ff9fd037a1afdd7e9c6dce4a18b">collectProcesses</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the process state set to null </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5f969c52d703e39c812dfde91ad68d75">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a02d59626c894538bab15a0e459c7b1ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.setLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>accessChanged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Procedure: </p>
<ol>
<li>
get the current dynamic scope ds0 of the process. Let ss0 be the static scope associated to ds0. </li>
<li>
Let ss1 be the static scope of the new location to move to. </li>
<li>
Compute the join (youngest common ancestor) of ss0 and ss1. Also save the sequence of static scopes from join to ss1. </li>
<li>
Iterate UP over dynamic scopes from ds0 up (using parent field) to the first dynamic scope whose static scope is join. </li>
<li>
Iterate DOWN from join to ss1, creating NEW dynamic scopes along the way. </li>
<li>
Set the frame pointer to the new dynamic scope corresponding to ss1, and set the location to the given location. </li>
<li>
Remove all unreachable scopes. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
    <tr><td class="paramname">pid</td><td></td></tr>
    <tr><td class="paramname">location</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a3d545b10a549db49479268ea772245b1">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a6eca6e2fe2e004ad7b74dd4ffa49846e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.setLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the location of a process. </p>
<p>This changes the top stack frame for the process so that it points to the new location. The given process must have a non-empty stack (although the location component of that frame is not used, so it is OK if it is null). There is no change of the access of variables from the current location to the target location.</p>
<p>This may involve adding and removing scopes, if the scope of the new location differs from the original scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the move. </td></tr>
    <tr><td class="paramname">location</td><td>The target location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process at a new location, and scopes added and removed as necessary </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ad68188e38333826e7f585b5ceb858a08">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aa3955ff83bd8eca124041041d8d4fd52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.setProcessState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1ProcessState.html">ProcessState</a>&#160;</td>
          <td class="paramname"><em>processState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the state by replacing the process state with the given one where the PID of the old process state is the same as the given process state. </p>
<p>Precondition: the PID of the given process state should be in [0, numProcs-1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="structA.html">A</a> non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
    <tr><td class="paramname">processState</td><td>The process state to assign to PID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after updating the process with the specified PID </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2f48636d5dba0d57c3e7cf63e9980b9d">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ae708ff73f1b3327a5deb0b9b5016cd78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scopeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the value assigned to a variable in the state. Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value. </p>
<p>In this version of the method, the variable is specified by its dynamic scope ID and variable ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">vid</td><td>variable ID number </td></tr>
    <tr><td class="paramname">scopeID</td><td>The ID of the dynamic scope containing the variable. This version of the method is useful when setting the target of a pointer. For a variable in the current lexical scope, use the version of the method without this argument </td></tr>
    <tr><td class="paramname">value</td><td>The new value to assign to the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by updating the value of the variable </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a33ef600c8d89d0edb2ae51def702697b" title="Updates the value assigned to a variable in the state. ">setVariable(State, Variable, int, SymbolicExpression)</a> </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab1877edd7985bfa3bb4171fed7671472">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a33ef600c8d89d0edb2ae51def702697b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value assigned to a variable in the state. </p>
<p>Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">variable</td><td>The variable to update </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process containing the variable </td></tr>
    <tr><td class="paramname">value</td><td>The new value to be assigned to the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by updating the value of the variable </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae266fa51d2dea90e7e5d3ca8b45dd22b">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad75dbebbe769245d9850b493ef1ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplifies all variable values in the state, using the path condition as the simplification context. </p>
<p><a class="el" href="structA.html">A</a> symbolic constant which is determined to have a concrete value (based on the path condition), may be entirely removed from the state by replacing every occurrence of that symbol with the concrete value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Any State </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The simplified state </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#adbeb8d17faccb408984c62646ad3491d">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a3756be1f64eb8b339587e93fe4370781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStackEntry.html">ImmutableStackEntry</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.stackEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new call stack entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location to go to after returning from this call. </td></tr>
    <tr><td class="paramname">dyscopeId</td><td>The dynamic scope the process is in before the call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a545a89e6de9775ca52721c9c794da12b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SymbolicUniverse edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.symbolicUniverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbolic universe used by this factory to manipulate symbolic expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>the symbolic universe </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5ca93a5b12557dcb6337cf3cf41862ec">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a5318c37923f7a29e4ea586e4ed241f25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory.terminateProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the process state for the designated process to be the process state with the empty stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the old state </td></tr>
    <tr><td class="paramname">pid</td><td>the PID of the process to terminate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>state that is identical to old except that the process state for process PID has been set to the process state with the empty stack </dd></dl>

<p>Implements <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aefff2ccf75944f8eea5c77d95aeb3b5f">edu.udel.cis.vsl.civl.state.IF.StateFactory</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/arnabd/workspace/civl/trunk/src/edu/udel/cis/vsl/civl/state/common/immutable/ImmutableStateFactory.java</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
