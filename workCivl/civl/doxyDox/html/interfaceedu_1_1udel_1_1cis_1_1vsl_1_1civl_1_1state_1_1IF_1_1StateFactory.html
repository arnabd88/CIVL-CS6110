<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: edu.udel.cis.vsl.civl.state.IF.StateFactory Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   &#160;<span id="projectnumber">CIVL</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>edu</b></li><li class="navelem"><b>udel</b></li><li class="navelem"><b>cis</b></li><li class="navelem"><b>vsl</b></li><li class="navelem"><a class="el" href="namespaceedu_1_1udel_1_1cis_1_1vsl_1_1civl.html">civl</a></li><li class="navelem"><b>state</b></li><li class="navelem"><a class="el" href="namespaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF.html">IF</a></li><li class="navelem"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html">StateFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">edu.udel.cis.vsl.civl.state.IF.StateFactory Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The state factory is used to create all state objects.  
 <a href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for edu.udel.cis.vsl.civl.state.IF.StateFactory:</div>
<div class="dyncontent">
<div class="center"><img src="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory__inherit__graph.png" border="0" usemap="#edu_8udel_8cis_8vsl_8civl_8state_8IF_8StateFactory_inherit__map" alt="Inheritance graph"/></div>
<map name="edu_8udel_8cis_8vsl_8civl_8state_8IF_8StateFactory_inherit__map" id="edu_8udel_8cis_8vsl_8civl_8state_8IF_8StateFactory_inherit__map">
<area shape="rect" id="node2" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html" title="An implementation of StateFactory based on the Immutable Pattern. " alt="" coords="5,95,297,136"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ca93a5b12557dcb6337cf3cf41862ec"><td class="memItemLeft" align="right" valign="top">SymbolicUniverse&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5ca93a5b12557dcb6337cf3cf41862ec">symbolicUniverse</a> ()</td></tr>
<tr class="memdesc:a5ca93a5b12557dcb6337cf3cf41862ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbolic universe used by this factory to manipulate symbolic expressions.  <a href="#a5ca93a5b12557dcb6337cf3cf41862ec">More...</a><br /></td></tr>
<tr class="separator:a5ca93a5b12557dcb6337cf3cf41862ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99001c497b2ff46cd098525744a7d0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a99001c497b2ff46cd098525744a7d0c1">canonic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, boolean <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a57003566f5dd8c4905a7e630d90ad5ef">collectProcesses</a>, boolean <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a4ffda85305907c945cc3ffb2d3339eeb">collectScopes</a>, boolean <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a78a17339ebd0be7dacaf1f06e78626d7">collectHeaps</a>, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLHeapException</td></tr>
<tr class="memdesc:a99001c497b2ff46cd098525744a7d0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the "canonical" version of the given state.  <a href="#a99001c497b2ff46cd098525744a7d0c1">More...</a><br /></td></tr>
<tr class="separator:a99001c497b2ff46cd098525744a7d0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd886f831cb9db1dac78c3aee029751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abcd886f831cb9db1dac78c3aee029751">initialState</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Model.html">Model</a> model)  throws CIVLHeapException</td></tr>
<tr class="memdesc:abcd886f831cb9db1dac78c3aee029751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonic, initial state for a <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> Model.  <a href="#abcd886f831cb9db1dac78c3aee029751">More...</a><br /></td></tr>
<tr class="separator:abcd886f831cb9db1dac78c3aee029751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae266fa51d2dea90e7e5d3ca8b45dd22b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae266fa51d2dea90e7e5d3ca8b45dd22b">setVariable</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a> variable, int pid, SymbolicExpression value)</td></tr>
<tr class="memdesc:ae266fa51d2dea90e7e5d3ca8b45dd22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value assigned to a variable in the state.  <a href="#ae266fa51d2dea90e7e5d3ca8b45dd22b">More...</a><br /></td></tr>
<tr class="separator:ae266fa51d2dea90e7e5d3ca8b45dd22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1877edd7985bfa3bb4171fed7671472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab1877edd7985bfa3bb4171fed7671472">setVariable</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int vid, int scopeId, SymbolicExpression value)</td></tr>
<tr class="separator:ab1877edd7985bfa3bb4171fed7671472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c05d9800df5a48cfd13da18caf24364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2c05d9800df5a48cfd13da18caf24364">addProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, SymbolicExpression[] arguments, int callerPid)</td></tr>
<tr class="separator:a2c05d9800df5a48cfd13da18caf24364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a497fca3857a16cda6ddda36d2eb49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#af2a497fca3857a16cda6ddda36d2eb49">addProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, int functionParentDyscope, SymbolicExpression[] arguments, int callerPid)</td></tr>
<tr class="separator:af2a497fca3857a16cda6ddda36d2eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefff2ccf75944f8eea5c77d95aeb3b5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aefff2ccf75944f8eea5c77d95aeb3b5f">terminateProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:aefff2ccf75944f8eea5c77d95aeb3b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the process state for the designated process to be the process state with the empty stack.  <a href="#aefff2ccf75944f8eea5c77d95aeb3b5f">More...</a><br /></td></tr>
<tr class="separator:aefff2ccf75944f8eea5c77d95aeb3b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f969c52d703e39c812dfde91ad68d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5f969c52d703e39c812dfde91ad68d75">removeProcess</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a5f969c52d703e39c812dfde91ad68d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a process from the state.  <a href="#a5f969c52d703e39c812dfde91ad68d75">More...</a><br /></td></tr>
<tr class="separator:a5f969c52d703e39c812dfde91ad68d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68188e38333826e7f585b5ceb858a08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ad68188e38333826e7f585b5ceb858a08">setLocation</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a> location)</td></tr>
<tr class="memdesc:ad68188e38333826e7f585b5ceb858a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the location of a process.  <a href="#ad68188e38333826e7f585b5ceb858a08">More...</a><br /></td></tr>
<tr class="separator:ad68188e38333826e7f585b5ceb858a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d545b10a549db49479268ea772245b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a3d545b10a549db49479268ea772245b1">setLocation</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a> location, boolean accessChanged)</td></tr>
<tr class="memdesc:a3d545b10a549db49479268ea772245b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the location of a process.  <a href="#a3d545b10a549db49479268ea772245b1">More...</a><br /></td></tr>
<tr class="separator:a3d545b10a549db49479268ea772245b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7ba7469eca87e1359b63656f6de1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a3c7ba7469eca87e1359b63656f6de1fb">pushCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, SymbolicExpression[] arguments)</td></tr>
<tr class="memdesc:a3c7ba7469eca87e1359b63656f6de1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new entry onto the call stack for a process.  <a href="#a3c7ba7469eca87e1359b63656f6de1fb">More...</a><br /></td></tr>
<tr class="separator:a3c7ba7469eca87e1359b63656f6de1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eae26822f75dc67b3a588a725af7430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8eae26822f75dc67b3a588a725af7430">pushCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a> function, int functionParentDyscope, SymbolicExpression[] arguments)</td></tr>
<tr class="memdesc:a8eae26822f75dc67b3a588a725af7430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new entry onto the call stack for a process.  <a href="#a8eae26822f75dc67b3a588a725af7430">More...</a><br /></td></tr>
<tr class="separator:a8eae26822f75dc67b3a588a725af7430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11e79aef8f8b8b80e830cbf48f03c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab11e79aef8f8b8b80e830cbf48f03c1e">popCallStack</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:ab11e79aef8f8b8b80e830cbf48f03c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops an entry off the call stack for a process.  <a href="#ab11e79aef8f8b8b80e830cbf48f03c1e">More...</a><br /></td></tr>
<tr class="separator:ab11e79aef8f8b8b80e830cbf48f03c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb8d17faccb408984c62646ad3491d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#adbeb8d17faccb408984c62646ad3491d">simplify</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:adbeb8d17faccb408984c62646ad3491d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies all variable values in the state, using the path condition as the simplification context.  <a href="#adbeb8d17faccb408984c62646ad3491d">More...</a><br /></td></tr>
<tr class="separator:adbeb8d17faccb408984c62646ad3491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8deab13e632331d44f30808e245bd3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2e8deab13e632331d44f30808e245bd3">getNumStateInstances</a> ()</td></tr>
<tr class="memdesc:a2e8deab13e632331d44f30808e245bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of objects of type <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html" title="A State represents the (global) state of a CIVL Model. ">State</a> that have been instantiated since this JVM started.  <a href="#a2e8deab13e632331d44f30808e245bd3">More...</a><br /></td></tr>
<tr class="separator:a2e8deab13e632331d44f30808e245bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5442b4d2a0f993e07a9bd403ebdcd917"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a5442b4d2a0f993e07a9bd403ebdcd917">getNumStatesSaved</a> ()</td></tr>
<tr class="memdesc:a5442b4d2a0f993e07a9bd403ebdcd917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of states stored by this state factory.  <a href="#a5442b4d2a0f993e07a9bd403ebdcd917">More...</a><br /></td></tr>
<tr class="separator:a5442b4d2a0f993e07a9bd403ebdcd917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a17339ebd0be7dacaf1f06e78626d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a78a17339ebd0be7dacaf1f06e78626d7">collectHeaps</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLStateException</td></tr>
<tr class="memdesc:a78a17339ebd0be7dacaf1f06e78626d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of heaps.  <a href="#a78a17339ebd0be7dacaf1f06e78626d7">More...</a><br /></td></tr>
<tr class="separator:a78a17339ebd0be7dacaf1f06e78626d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffda85305907c945cc3ffb2d3339eeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a4ffda85305907c945cc3ffb2d3339eeb">collectScopes</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt; toBeIgnored)  throws CIVLStateException</td></tr>
<tr class="memdesc:a4ffda85305907c945cc3ffb2d3339eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of dynamic scopes.  <a href="#a4ffda85305907c945cc3ffb2d3339eeb">More...</a><br /></td></tr>
<tr class="separator:a4ffda85305907c945cc3ffb2d3339eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57003566f5dd8c4905a7e630d90ad5ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a57003566f5dd8c4905a7e630d90ad5ef">collectProcesses</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a57003566f5dd8c4905a7e630d90ad5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a garbage collection and canonicalization of the process states.  <a href="#a57003566f5dd8c4905a7e630d90ad5ef">More...</a><br /></td></tr>
<tr class="separator:a57003566f5dd8c4905a7e630d90ad5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8960b6b6ec0ad03227bf46ee17b19ed1"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8960b6b6ec0ad03227bf46ee17b19ed1">lockedByAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a8960b6b6ec0ad03227bf46ee17b19ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any process at the state is holding the atomic lock, i.e, the process is executing some atomic blocks.  <a href="#a8960b6b6ec0ad03227bf46ee17b19ed1">More...</a><br /></td></tr>
<tr class="separator:a8960b6b6ec0ad03227bf46ee17b19ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd00efcbcd99ef258a98712c1a5519fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abd00efcbcd99ef258a98712c1a5519fd">processInAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:abd00efcbcd99ef258a98712c1a5519fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PID of the process that holds the atomic lock at a certain state.  <a href="#abd00efcbcd99ef258a98712c1a5519fd">More...</a><br /></td></tr>
<tr class="separator:abd00efcbcd99ef258a98712c1a5519fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba2dd3ec097f8086d633109f66419df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aeba2dd3ec097f8086d633109f66419df">getAtomicLock</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:aeba2dd3ec097f8086d633109f66419df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares that the process with the given PID now owns the atomic lock.  <a href="#aeba2dd3ec097f8086d633109f66419df">More...</a><br /></td></tr>
<tr class="separator:aeba2dd3ec097f8086d633109f66419df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c86533f0d632ee5258f90c464d596e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a20c86533f0d632ee5258f90c464d596e">enterAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:a20c86533f0d632ee5258f90c464d596e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pid enters a new atomic section.  <a href="#a20c86533f0d632ee5258f90c464d596e">More...</a><br /></td></tr>
<tr class="separator:a20c86533f0d632ee5258f90c464d596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7452c8c5a59d8862e3fc189577cf8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ace7452c8c5a59d8862e3fc189577cf8b">leaveAtomic</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid)</td></tr>
<tr class="memdesc:ace7452c8c5a59d8862e3fc189577cf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process pid leaves an atomic section.  <a href="#ace7452c8c5a59d8862e3fc189577cf8b">More...</a><br /></td></tr>
<tr class="separator:ace7452c8c5a59d8862e3fc189577cf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a81054b9e512c38bcf873ce54c36896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a1a81054b9e512c38bcf873ce54c36896">releaseAtomicLock</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a1a81054b9e512c38bcf873ce54c36896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the atomic lock, by updating the atomic lock variable with the undefined process value.  <a href="#a1a81054b9e512c38bcf873ce54c36896">More...</a><br /></td></tr>
<tr class="separator:a1a81054b9e512c38bcf873ce54c36896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f48636d5dba0d57c3e7cf63e9980b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2f48636d5dba0d57c3e7cf63e9980b9d">setProcessState</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1ProcessState.html">ProcessState</a> processState)</td></tr>
<tr class="separator:a2f48636d5dba0d57c3e7cf63e9980b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ba56b706c95a3afbe32c54504c5b16"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ab2ba56b706c95a3afbe32c54504c5b16">isDescendantOf</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int ancestor, int descendant)</td></tr>
<tr class="memdesc:ab2ba56b706c95a3afbe32c54504c5b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if one dyscope is strictly the descendant of the other (not equal to).  <a href="#ab2ba56b706c95a3afbe32c54504c5b16">More...</a><br /></td></tr>
<tr class="separator:ab2ba56b706c95a3afbe32c54504c5b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb8f08bb0e64d60c886d2cd482e9c80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a7bb8f08bb0e64d60c886d2cd482e9c80">lowestCommonAncestor</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int one, int another)</td></tr>
<tr class="memdesc:a7bb8f08bb0e64d60c886d2cd482e9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lowest common ancestor of two given dyscopes.  <a href="#a7bb8f08bb0e64d60c886d2cd482e9c80">More...</a><br /></td></tr>
<tr class="separator:a7bb8f08bb0e64d60c886d2cd482e9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d470ef099fa677050a049e6ffb0090f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2d470ef099fa677050a049e6ffb0090f">malloc</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int dyscopeID, int mallocID, SymbolicExpression heapObject)</td></tr>
<tr class="memdesc:a2d470ef099fa677050a049e6ffb0090f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope.  <a href="#a2d470ef099fa677050a049e6ffb0090f">More...</a><br /></td></tr>
<tr class="separator:a2d470ef099fa677050a049e6ffb0090f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7914fbfe856e913a2f9ad694ed01b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae7914fbfe856e913a2f9ad694ed01b9b">malloc</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int pid, int dyscopeID, int mallocID, SymbolicType elementType, NumericExpression elementCount)</td></tr>
<tr class="memdesc:ae7914fbfe856e913a2f9ad694ed01b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object for the given malloc ID in the heap of the given dyscope.  <a href="#ae7914fbfe856e913a2f9ad694ed01b9b">More...</a><br /></td></tr>
<tr class="separator:ae7914fbfe856e913a2f9ad694ed01b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ff5361d7dda8a7b1ca1b3a7d6ad48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae67ff5361d7dda8a7b1ca1b3a7d6ad48">deallocate</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, SymbolicExpression heapObjectPointer, int dyscopeId, int mallocId, int index)</td></tr>
<tr class="memdesc:ae67ff5361d7dda8a7b1ca1b3a7d6ad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a heap object from the heap of a given dyscope.  <a href="#ae67ff5361d7dda8a7b1ca1b3a7d6ad48">More...</a><br /></td></tr>
<tr class="separator:ae67ff5361d7dda8a7b1ca1b3a7d6ad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d4a9ddfedabc175ca4f3339e429ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a38d4a9ddfedabc175ca4f3339e429ab7">incrementNumSymbolicConstants</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a38d4a9ddfedabc175ca4f3339e429ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of symbolic constants by one.  <a href="#a38d4a9ddfedabc175ca4f3339e429ab7">More...</a><br /></td></tr>
<tr class="separator:a38d4a9ddfedabc175ca4f3339e429ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25cbfaca9b0e6a1d7aa7e15dc50ec87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aa25cbfaca9b0e6a1d7aa7e15dc50ec87">numSymbolicConstants</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:aa25cbfaca9b0e6a1d7aa7e15dc50ec87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of symbolic constants appearing in the given state.  <a href="#aa25cbfaca9b0e6a1d7aa7e15dc50ec87">More...</a><br /></td></tr>
<tr class="separator:aa25cbfaca9b0e6a1d7aa7e15dc50ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae846f055fce4e5a5ad400c92d2ef6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adae846f055fce4e5a5ad400c92d2ef6d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numSymbolicInputs</b> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="separator:adae846f055fce4e5a5ad400c92d2ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5218196825ebba4a22fb05335a008c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#afb5218196825ebba4a22fb05335a008c">incrementNumSymbolicInputs</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:afb5218196825ebba4a22fb05335a008c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the number of symbolic constants by one.  <a href="#afb5218196825ebba4a22fb05335a008c">More...</a><br /></td></tr>
<tr class="separator:afb5218196825ebba4a22fb05335a008c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb2c92c0b77f2549d36fd17469b42b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadbb2c92c0b77f2549d36fd17469b42b"></a>
<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1MemoryUnitFactory.html">MemoryUnitFactory</a>&#160;</td><td class="memItemRight" valign="bottom"><b>memUnitFactory</b> ()</td></tr>
<tr class="separator:aadbb2c92c0b77f2549d36fd17469b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f666801e5c6522fcdc81b508cf1e10d"><td class="memItemLeft" align="right" valign="top">Map&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a8f666801e5c6522fcdc81b508cf1e10d">inputVariableValueMap</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state)</td></tr>
<tr class="memdesc:a8f666801e5c6522fcdc81b508cf1e10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map of variable and value of input variables at the given state.  <a href="#a8f666801e5c6522fcdc81b508cf1e10d">More...</a><br /></td></tr>
<tr class="separator:a8f666801e5c6522fcdc81b508cf1e10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c4b5efdb8a18f3e9d6e724c0045d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a71c4b5efdb8a18f3e9d6e724c0045d4f">mergeMonostates</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> entry)</td></tr>
<tr class="memdesc:a71c4b5efdb8a18f3e9d6e724c0045d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges a set of <a class="el" href="">ImmutableMonoState</a> to a FAKE global <a class="el" href="">ImmutableState</a> which should only be used to evaluation.  <a href="#a71c4b5efdb8a18f3e9d6e724c0045d4f">More...</a><br /></td></tr>
<tr class="separator:a71c4b5efdb8a18f3e9d6e724c0045d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948dbf498b93bb9e67a757450dfc421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a7948dbf498b93bb9e67a757450dfc421">addToCollectiveSnapshotsEntry</a> (<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> state, int pid, int place, int queueID, int entryPos, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a> assertion)</td></tr>
<tr class="memdesc:a7948dbf498b93bb9e67a757450dfc421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot on current state then store the snapshot with the collective assertion into an collectiveSnapshotsEntry.  <a href="#a7948dbf498b93bb9e67a757450dfc421">More...</a><br /></td></tr>
<tr class="separator:a7948dbf498b93bb9e67a757450dfc421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4576f13147144139eb71f61c506c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#aaa4576f13147144139eb71f61c506c7b">createCollectiveSnapshotsEnrty</a> (<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> state, int pid, int numProcesses, int place, int queueID, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a> assertion, SymbolicExpression channels, ContractKind kind, List&lt; <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&gt; pickUpStation)</td></tr>
<tr class="memdesc:aaa4576f13147144139eb71f61c506c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The process with "pid" creates a fresh new <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a>, then saves its own snapshot in the new entry.  <a href="#aaa4576f13147144139eb71f61c506c7b">More...</a><br /></td></tr>
<tr class="separator:aaa4576f13147144139eb71f61c506c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79263e51d0e37343b1211adb8f1f19f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a79263e51d0e37343b1211adb8f1f19f1">dequeueCollectiveSnapshotsEntry</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:a79263e51d0e37343b1211adb8f1f19f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues an <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns a new state.  <a href="#a79263e51d0e37343b1211adb8f1f19f1">More...</a><br /></td></tr>
<tr class="separator:a79263e51d0e37343b1211adb8f1f19f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319b79f1cb6f0ca0608b5bccf4a0151c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a319b79f1cb6f0ca0608b5bccf4a0151c">peekCollectiveSnapshotsEntry</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:a319b79f1cb6f0ca0608b5bccf4a0151c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the top <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns the copied snapshots entry.  <a href="#a319b79f1cb6f0ca0608b5bccf4a0151c">More...</a><br /></td></tr>
<tr class="separator:a319b79f1cb6f0ca0608b5bccf4a0151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb62af481c4c0f8bbc5091b16f1d9d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#abb62af481c4c0f8bbc5091b16f1d9d75">commitUpdatedChannelsToEntries</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueId, SymbolicExpression[] newChannels)</td></tr>
<tr class="memdesc:abb62af481c4c0f8bbc5091b16f1d9d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all entries in a collective queue with a group of message buffers.  <a href="#abb62af481c4c0f8bbc5091b16f1d9d75">More...</a><br /></td></tr>
<tr class="separator:abb62af481c4c0f8bbc5091b16f1d9d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ae05bbe6479f7111e129a649cfed4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a03ae05bbe6479f7111e129a649cfed4b">getSnapshotsQueue</a> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> state, int queueID)</td></tr>
<tr class="memdesc:a03ae05bbe6479f7111e129a649cfed4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the corresponding snapshot queue by giving the identifier of an MPI communicator (The identifier is a component of the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> MPI library implementation).  <a href="#a03ae05bbe6479f7111e129a649cfed4b">More...</a><br /></td></tr>
<tr class="separator:a03ae05bbe6479f7111e129a649cfed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c232147650e90b66e1675de991ef84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c232147650e90b66e1675de991ef84"></a>
<a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copySnapshotsQueues</b> (<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> fromState, <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> toState)</td></tr>
<tr class="separator:ad7c232147650e90b66e1675de991ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The state factory is used to create all state objects. </p>
<dl class="section author"><dt>Author</dt><dd>Timothy K. Zirkel (zirkel) </dd>
<dd>
Timothy J. McClory (tmcclory) </dd>
<dd>
Stephen F. Siegel (siegel) </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2c05d9800df5a48cfd13da18caf24364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.addProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callerPid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an IllegalArgumentException is thrown. Hence the calling process must have a non-empty call stack. </p>
<p>The PID of the new process will be <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html#a1fb9bc3c57e059c2885a73ba4d08b441">State#numProcs()</a>, where state is the pre-state (the given state), not the new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">function</td><td>The function in which the new process starts. </td></tr>
    <tr><td class="paramname">arguments</td><td>The arguments to this function call. </td></tr>
    <tr><td class="paramname">callerPid</td><td>the PID of the process that is creating the new process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a1b0ab2bb34419888f0a80b1a6c9ac756">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="af2a497fca3857a16cda6ddda36d2eb49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.addProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>functionParentDyscope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>callerPid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new process. The new process is created and one entry is pushed onto its call stack. That entry will have a dynamic scope whose parent is determined by the calling process (the process that is executing the spawn command to create this new process) and the given function. The parent dynamic scope is computed by starting with the current dynamic scope of the caller, and working up the parent chain, stopping at the first dynamic scope whose static scope matches the containing scope of the function. If no such dynamic scope is found in the chain, an IllegalArgumentException is thrown. Hence the calling process must have a non-empty call stack. </p>
<p>The PID of the new process will be <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html#a1fb9bc3c57e059c2885a73ba4d08b441">State#numProcs()</a>, where state is the pre-state (the given state), not the new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">function</td><td>The function in which the new process starts. </td></tr>
    <tr><td class="paramname">functionParentDyscope</td><td>The dyscope ID of the parent of the new function </td></tr>
    <tr><td class="paramname">arguments</td><td>The arguments to this function call. </td></tr>
    <tr><td class="paramname">callerPid</td><td>the PID of the process that is creating the new process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by adding a process whose location is the start location of the function and with a new dynamic scope corresponding to the outermost lexical scope of the function. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a9a90cec9f8322c9b8abc34cd366f2b9e">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a7948dbf498b93bb9e67a757450dfc421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.addToCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>entryPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>assertion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a snapshot on current state then store the snapshot with the collective assertion into an collectiveSnapshotsEntry. </p>
<p>If the global state has a queue, then either create a new entry then enqueue, or modify a existing entry, otherwise create both a queue and a entry. Return the new or modified entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process </td></tr>
    <tr><td class="paramname">place</td><td>The place of the process in the collective entry </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective entry </td></tr>
    <tr><td class="paramname">entryPos</td><td>The position of the entry in the collective queue </td></tr>
    <tr><td class="paramname">assertion</td><td>The expression of a assertion asserted by the process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ae7514e9e3d808ecf1b7f5b375cf5cf8f">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a99001c497b2ff46cd098525744a7d0c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.canonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectProcesses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectScopes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>collectHeaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the "canonical" version of the given state. </p>
<p>The state returned will satisfy all of the following: </p><ul>
<li>
it will be observationally equivalent to the given state, i.e., there is no way a CIVL-C program can distinguish between the two states </li>
<li>
there will be no gaps in the dynamic scope IDs and no null dynamic scopes </li>
<li>
there will be no gaps in the PIDs and no null process states </li>
<li>
every dynamic scope will be reachable (starting from the frame of the call stack of one of the processes and following parent edges in the dyscope tree) </li>
<li>
the state returned will be the unique representative of its equivalence class, i.e., if this method is invoked with two equivalent states, it will return the same object </li>
</ul>
<p>Note that the state returned may in fact be the same as the one given.</p>
<p>Note that this does everything that methods <a class="el" href="">collectScopes(State)</a> and <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a57003566f5dd8c4905a7e630d90ad5ef">collectProcesses</a> do. So there is no need to call those methods if you are already calling this method.</p>
<p>This method may go further in simplifying the state. This is up to the particular implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
    <tr><td class="paramname">collectProcesses</td><td>shall processes be collected? </td></tr>
    <tr><td class="paramname">collectScopes</td><td>shall scopes be collected? </td></tr>
    <tr><td class="paramname">collectHeaps</td><td>shall heaps be collected?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the canonical version of the given state </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a62c70f6ea5fb68aaf09cb09087b006b1">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a78a17339ebd0be7dacaf1f06e78626d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.collectHeaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLStateException.html">CIVLStateException</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of heaps. </p>
<p>Computes the set of reachable heap objects, and removes all unreachable heap objects. Renumbers heap objects in a canonic way. Updates all pointers in the state accordingly. This operation should be completely invisible to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state after canonicalizing heaps, which may be this state or a new one </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a66fc6a266b28ded9287b0ec6d2621a94">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a57003566f5dd8c4905a7e630d90ad5ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.collectProcesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of the process states. </p>
<p>Removes any process state that is null. Renumbers the PIDs so that there are no gaps (and start from 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state with processes collected </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4e0a1ff9fd037a1afdd7e9c6dce4a18b">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a4ffda85305907c945cc3ffb2d3339eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.collectScopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Set&lt; <a class="el" href="enumedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException_1_1HeapErrorKind.html">HeapErrorKind</a> &gt;&#160;</td>
          <td class="paramname"><em>toBeIgnored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLStateException.html">CIVLStateException</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a garbage collection and canonicalization of dynamic scopes. </p>
<p>Compute the set of reachable dynamic scopes, and removes any which are unreachable. Renumbers the dynamic scopes in a canonic way. Updates all scope references in the state. This operation should be completely invisible to the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>a state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state after canonicalizing scopes, which may be this state or a new one </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ac08af796a3dfdb6f0cce6c0c1afb8c68">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="abb62af481c4c0f8bbc5091b16f1d9d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.commitUpdatedChannelsToEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>newChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update all entries in a collective queue with a group of message buffers. </p>
<p>Note: The entry in position i will be updated with the message buffers in newBuffers[i]. The 0 position in collective queue is the head of the queue. The reason of using an array of message buffers to update the collective queue is to prevent the queue in state be changed for other purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueId</td><td>The ID of the collective queue </td></tr>
    <tr><td class="paramname">newChannels</td><td>The array of new message buffers. see <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html#a41f3b2e873b8f0e650cab149bbe4f129">CollectiveSnapshotsEntry#getMsgBuffers()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a948646856ef1cd713a740aecc22d34c0">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aaa4576f13147144139eb71f61c506c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.createCollectiveSnapshotsEnrty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numProcesses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>place</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1expression_1_1Expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>assertion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContractKind&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt; <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression &gt;&gt;&#160;</td>
          <td class="paramname"><em>pickUpStation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The process with "pid" creates a fresh new <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a>, then saves its own snapshot in the new entry. </p>
<p>This function returns the new state with a new entry in one of its snapshots queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process </td></tr>
    <tr><td class="paramname">numProcesses</td><td>The number of processes participating this collective entry </td></tr>
    <tr><td class="paramname">place</td><td>The place of the process in the collective entry </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
    <tr><td class="paramname">assertion</td><td>The expression of the assertion asserted by the processes </td></tr>
    <tr><td class="paramname">channels</td><td>Message buffer snapshot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a4462151d1c85d4d4a878d88d6cc96350">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ae67ff5361d7dda8a7b1ca1b3a7d6ad48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>heapObjectPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates a heap object from the heap of a given dyscope. </p>
<p>It marks the heap object as INVALID instead of removing it, updates any pointer to that removed object to be an UNDEFINED pointer, which is defined by the symbolic utility. The removal of the heap object happens later when the heap gets collected during state canonicalization.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a2d470ef099fa677050a049e6ffb0090f" title="Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope...">malloc</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">heapObjectPointer</td><td>The pointer which points to the heap object to be removed. </td></tr>
    <tr><td class="paramname">dyscopeId</td><td>The ID of the dyscope where the pointer points to. </td></tr>
    <tr><td class="paramname">mallocId</td><td>The malloc ID of the heap object to be removed, i.e., the index of the heap field in the heap. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the heap object in the heap field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state after the heap object is removed from the heap, and corresponding pointers updated. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#adbb5cfa400e857cedde973811105fed9">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a79263e51d0e37343b1211adb8f1f19f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.dequeueCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeues an <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns a new state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a54d1895551e52122c30a1eb645f7f690">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a20c86533f0d632ee5258f90c464d596e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.enterAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process pid enters a new atomic section. </p>
<p><br />
 Precondition: no other processes hold the atomic lock<br />
 If the process already holds the atomic lock, then its atomic count is incremented; <br />
 if the process doesn't hold the atomic lock, then the atomic lock is obtained and its atomic count is set to be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state after process pid enters a new atomic section </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a025b6b9e6b52f0f5a7f47a946e35e02d">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aeba2dd3ec097f8086d633109f66419df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.getAtomicLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares that the process with the given PID now owns the atomic lock. </p>
<p>Precondition: no process is holding the atomic lock in the given state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process that is going to take the atomic lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a state equivalent to given one except that process PID now owns the atomic lock </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a912ed0ca7a4414f2edc2be8e36faefde">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a2e8deab13e632331d44f30808e245bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long edu.udel.cis.vsl.civl.state.IF.StateFactory.getNumStateInstances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of objects of type <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html" title="A State represents the (global) state of a CIVL Model. ">State</a> that have been instantiated since this JVM started. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of states instantiated </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a0a89d58bd62a499947f0afac037379dd">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a5442b4d2a0f993e07a9bd403ebdcd917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.IF.StateFactory.getNumStatesSaved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of states stored by this state factory. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of states stored </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#acd0074abb7544acdde596a2fab96e669">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a03ae05bbe6479f7111e129a649cfed4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> [] edu.udel.cis.vsl.civl.state.IF.StateFactory.getSnapshotsQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the corresponding snapshot queue by giving the identifier of an MPI communicator (The identifier is a component of the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> MPI library implementation). </p>
<p>If there is no such a snapshot queue for the MPI communicator, returns an empty array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of a MPI communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a2ab7303606615d76222aff56ce7125ef">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a38d4a9ddfedabc175ca4f3339e429ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.incrementNumSymbolicConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of symbolic constants by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state whole number of symbolic constants is to be increased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a61437ae4ca0fb099c9f79ddceaa5d07c">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="afb5218196825ebba4a22fb05335a008c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.incrementNumSymbolicInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the number of symbolic constants by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the state whole number of symbolic constants is to be increased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6fd1ae7f315d534836864cc76a4fce0f">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="abcd886f831cb9db1dac78c3aee029751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.initialState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1Model.html">Model</a>&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td> throws <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CIVLHeapException.html">CIVLHeapException</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonic, initial state for a <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> Model. </p>
<dl class="section return"><dt>Returns</dt><dd>the initial state </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6a8e3b14776e73ce1d08b175e3012cbd">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a8f666801e5c6522fcdc81b508cf1e10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Map&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.IF.StateFactory.inputVariableValueMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map of variable and value of input variables at the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aa4bd3853959303e304debbc2ae22f5a4">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ab2ba56b706c95a3afbe32c54504c5b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean edu.udel.cis.vsl.civl.state.IF.StateFactory.isDescendantOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ancestor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descendant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if one dyscope is strictly the descendant of the other (not equal to). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state. </td></tr>
    <tr><td class="paramname">ancestor</td><td>The ID of the ancestor dyscope. </td></tr>
    <tr><td class="paramname">descendant</td><td>The ID of the descendant dyscope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff ancestor dyscope is really an ancestor of the descendant dyscope and they must not be equal to each other. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#af29c3918cae07c8e2689445dde49d065">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ace7452c8c5a59d8862e3fc189577cf8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.leaveAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process pid leaves an atomic section. </p>
<p><br />
 Precondition: in the given state, the process pid holds the atomic lock and its atomic count is greater than zero.<br />
 The atomic count is decremented by 1 after this method;<br />
 if the resultant atomic count is 0, then the atomic lock is released as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td></td></tr>
    <tr><td class="paramname">pid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new state after process pid leaves an atomic section </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ac3151f31996c6239ac71a2714ea54724">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a8960b6b6ec0ad03227bf46ee17b19ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean edu.udel.cis.vsl.civl.state.IF.StateFactory.lockedByAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any process at the state is holding the atomic lock, i.e, the process is executing some atomic blocks. </p>
<p>This information is maintained as a global variable of <code>$proc</code> type in the root scope in the <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> model (always with index 0), and it gets automatically updated when process id's are renumbered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the value of the variable atomic lock is not undefined. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a5fd6c8dfda79abc673ed958993b8cff2">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a7bb8f08bb0e64d60c886d2cd482e9c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.IF.StateFactory.lowestCommonAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the lowest common ancestor of two given dyscopes. </p>
<p>The returned value is always a dyscope ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state. </td></tr>
    <tr><td class="paramname">one</td><td>One dyscope. </td></tr>
    <tr><td class="paramname">another</td><td>Another dynamic scope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dyscope ID of the lowest common ancestor of the two given dyscopes. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ad7bebd102aa4e515f7a532cb50751c46">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a2d470ef099fa677050a049e6ffb0090f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.IF.StateFactory.malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>heapObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an object, of the given value, for the given malloc ID in the heap of the given dyscope. </p>
<p>For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc ID assigned by the model builder.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">dyscopeID</td><td>The dyscope ID. </td></tr>
    <tr><td class="paramname">mallocID</td><td>The ID the malloc statement. </td></tr>
    <tr><td class="paramname">heapObject</td><td>The value of the new heap object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after the new heap object </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a521481b4006af34010ce856f4f539a39">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ae7914fbfe856e913a2f9ad694ed01b9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1util_1_1IF_1_1Pair.html">Pair</a>&lt;<a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>, SymbolicExpression&gt; edu.udel.cis.vsl.civl.state.IF.StateFactory.malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dyscopeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mallocID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicType&#160;</td>
          <td class="paramname"><em>elementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumericExpression&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an object for the given malloc ID in the heap of the given dyscope. </p>
<p>For handle objects that are allocated by system functions instead of malloc statement, they all have a corresponding fake malloc ID assigned by the model builder. Since no value of the heap object is provided, the method will create a symbolic constant representing the heap object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The pre-state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process that triggers this execution. </td></tr>
    <tr><td class="paramname">dyscopeID</td><td>The dyscope ID. </td></tr>
    <tr><td class="paramname">mallocID</td><td>The ID the malloc statement. </td></tr>
    <tr><td class="paramname">elementType</td><td>The symbolic type of the element to be contained in the new heap object. </td></tr>
    <tr><td class="paramname">elementCount</td><td>The number of elements contained by the new heap object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after the new heap object is added. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a336133449bfe76264c72cc15bb3e0bc3">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a71c4b5efdb8a18f3e9d6e724c0045d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableState.html">ImmutableState</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.mergeMonostates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges a set of <a class="el" href="">ImmutableMonoState</a> to a FAKE global <a class="el" href="">ImmutableState</a> which should only be used to evaluation. </p>
<p>: For any two monoStates in the array, they should be owned by different processes. : true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monoStates</td><td>The array of <a class="el" href="">ImmutableMonoState</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a450c5462e9b7f8eaad36a3d4bbd744d0">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aa25cbfaca9b0e6a1d7aa7e15dc50ec87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.IF.StateFactory.numSymbolicConstants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of symbolic constants appearing in the given state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the given state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of symbolic constants appearing in the given state. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a10e26f9469590145532c69c4ce08fcb1">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a319b79f1cb6f0ca0608b5bccf4a0151c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableCollectiveSnapshotsEntry.html">ImmutableCollectiveSnapshotsEntry</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.peekCollectiveSnapshotsEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>queueID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the top <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1CollectiveSnapshotsEntry.html">CollectiveSnapshotsEntry</a> from the specific snapshots queue, returns the copied snapshots entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The current state </td></tr>
    <tr><td class="paramname">queueID</td><td>The ID identifies a collective queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ab66323bef446672f1b4de94f0ca09122">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ab11e79aef8f8b8b80e830cbf48f03c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.popCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops an entry off the call stack for a process. </p>
<p>Does not modify or remove and dynamic scopes (even if they become unreachable). Does not nullify or remove the process state (even if the call stack becomes empty).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process returning from a call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state but with the call stack for the given process popped. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a3f70888fd06f2a1c4a72393cc2345531">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="abd00efcbcd99ef258a98712c1a5519fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int edu.udel.cis.vsl.civl.state.IF.StateFactory.processInAtomic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PID of the process that holds the atomic lock at a certain state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 iff there is no process holding the atomic lock, otherwise return the process that holds the atomic lock </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aef485d98a0babfec8acc14a129cc4611">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a3c7ba7469eca87e1359b63656f6de1fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.pushCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a new entry onto the call stack for a process. </p>
<p>Used when a process calls a function. The process should already exist and have a non-empty call stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the call </td></tr>
    <tr><td class="paramname">function</td><td>The function being called </td></tr>
    <tr><td class="paramname">arguments</td><td>The (actual) arguments to the function being called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process having a new entry on its call stack. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a0ff6fe5b054069da0b20967e254b5ae4">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a8eae26822f75dc67b3a588a725af7430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.pushCallStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1CIVLFunction.html">CIVLFunction</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>functionParentDyscope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression[]&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a new entry onto the call stack for a process. </p>
<p>Used when a process calls a function. The process should already exist and have a non-empty call stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the call </td></tr>
    <tr><td class="paramname">function</td><td>The function being called </td></tr>
    <tr><td class="paramname">functionParentDyscope</td><td>The dyscope ID of the parent of the new function </td></tr>
    <tr><td class="paramname">arguments</td><td>The (actual) arguments to the function being called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process having a new entry on its call stack. </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a8fc946088739b623a3ccc49ed2544b11">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a1a81054b9e512c38bcf873ce54c36896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.releaseAtomicLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the atomic lock, by updating the atomic lock variable with the undefined process value. </p>
<p>If atomic lock of the given state is already released, this is a no op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>any non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a state equivalent to given one except that no state owns the atomic lock </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aaba1752dba05b39dc8fa982e1ee682d8">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a5f969c52d703e39c812dfde91ad68d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.removeProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a process from the state. </p>
<p>The process state associated to that process is set to null. No other part of the state is affected. To really get rid of the process state you need to call <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#a57003566f5dd8c4905a7e630d90ad5ef">collectProcesses</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">pid</td><td>The PID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the process state set to null </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a1c324a5c8166701c1e6037005598f87b">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ad68188e38333826e7f585b5ceb858a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.setLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the location of a process. </p>
<p>This changes the top stack frame for the process so that it points to the new location. The given process must have a non-empty stack (although the location component of that frame is not used, so it is OK if it is null). There is no change of the access of variables from the current location to the target location.</p>
<p>This may involve adding and removing scopes, if the scope of the new location differs from the original scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the move. </td></tr>
    <tr><td class="paramname">location</td><td>The target location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process at a new location, and scopes added and removed as necessary </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6eca6e2fe2e004ad7b74dd4ffa49846e">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a3d545b10a549db49479268ea772245b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.setLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1location_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>accessChanged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the location of a process. </p>
<p>This changes the top stack frame for the process so that it points to the new location. The given process must have a non-empty stack (although the location component of that frame is not used, so it is OK if it is null).</p>
<p>This may involve adding and removing scopes, if the scope of the new location differs from the original scope.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state. </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process making the move. </td></tr>
    <tr><td class="paramname">location</td><td>The target location. </td></tr>
    <tr><td class="paramname">accessChanged</td><td>True iff there is change of variable accessing (write or read-only) from the current location to the target location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the same as the old state with the given process at a new location, and scopes added and removed as necessary </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a02d59626c894538bab15a0e459c7b1ae">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a2f48636d5dba0d57c3e7cf63e9980b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.setProcessState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1ProcessState.html">ProcessState</a>&#160;</td>
          <td class="paramname"><em>processState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the state by replacing the process state with the given one where the PID of the old process state is the same as the given process state. </p>
<p>Precondition: the PID of the given process state should be in [0, numProcs-1]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="structA.html">A</a> non-null <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1CIVL.html" title="The main CIVL class, containing the main method, which provides the command line interface for using ...">CIVL</a> state </td></tr>
    <tr><td class="paramname">processState</td><td>The process state to assign to PID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new state after updating the process with the specified PID </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#aa3955ff83bd8eca124041041d8d4fd52">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ae266fa51d2dea90e7e5d3ca8b45dd22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1model_1_1IF_1_1variable_1_1Variable.html">Variable</a>&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the value assigned to a variable in the state. </p>
<p>Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">variable</td><td>The variable to update </td></tr>
    <tr><td class="paramname">pid</td><td>The PID of the process containing the variable </td></tr>
    <tr><td class="paramname">value</td><td>The new value to be assigned to the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by updating the value of the variable </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a33ef600c8d89d0edb2ae51def702697b">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="ab1877edd7985bfa3bb4171fed7671472"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.setVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scopeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolicExpression&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the value assigned to a variable in the state. Specifically, returns a state which is equivalent to the given one, except that the value assigned to the specified variable is replaced by the given value. </p>
<p>In this version of the method, the variable is specified by its dynamic scope ID and variable ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The old state </td></tr>
    <tr><td class="paramname">vid</td><td>variable ID number </td></tr>
    <tr><td class="paramname">scopeID</td><td>The ID of the dynamic scope containing the variable. This version of the method is useful when setting the target of a pointer. For a variable in the current lexical scope, use the version of the method without this argument </td></tr>
    <tr><td class="paramname">value</td><td>The new value to assign to the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structA.html">A</a> new state that is the old state modified by updating the value of the variable </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1StateFactory.html#ae266fa51d2dea90e7e5d3ca8b45dd22b" title="Updates the value assigned to a variable in the state. ">setVariable(State, Variable, int, SymbolicExpression)</a> </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#ae708ff73f1b3327a5deb0b9b5016cd78">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="adbeb8d17faccb408984c62646ad3491d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies all variable values in the state, using the path condition as the simplification context. </p>
<p><a class="el" href="structA.html">A</a> symbolic constant which is determined to have a concrete value (based on the path condition), may be entirely removed from the state by replacing every occurrence of that symbol with the concrete value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Any <a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html" title="A State represents the (global) state of a CIVL Model. ">State</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The simplified state </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a6ad75dbebbe769245d9850b493ef1ce8">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="a5ca93a5b12557dcb6337cf3cf41862ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SymbolicUniverse edu.udel.cis.vsl.civl.state.IF.StateFactory.symbolicUniverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the symbolic universe used by this factory to manipulate symbolic expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>the symbolic universe </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a545a89e6de9775ca52721c9c794da12b">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<a class="anchor" id="aefff2ccf75944f8eea5c77d95aeb3b5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a> edu.udel.cis.vsl.civl.state.IF.StateFactory.terminateProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfaceedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1IF_1_1State.html">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the process state for the designated process to be the process state with the empty stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>the old state </td></tr>
    <tr><td class="paramname">pid</td><td>the PID of the process to terminate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>state that is identical to old except that the process state for process PID has been set to the process state with the empty stack </dd></dl>

<p>Implemented in <a class="el" href="classedu_1_1udel_1_1cis_1_1vsl_1_1civl_1_1state_1_1common_1_1immutable_1_1ImmutableStateFactory.html#a5318c37923f7a29e4ea586e4ed241f25">edu.udel.cis.vsl.civl.state.common.immutable.ImmutableStateFactory</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>/home/arnabd/workspace/civl/trunk/src/edu/udel/cis/vsl/civl/state/IF/StateFactory.java</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
