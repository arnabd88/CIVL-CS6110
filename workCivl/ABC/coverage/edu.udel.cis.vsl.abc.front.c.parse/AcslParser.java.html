<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AcslParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test Coverage Report for ABC ${revision}</a> &gt; <a href="index.source.html" class="el_package">edu.udel.cis.vsl.abc.front.c.parse</a> &gt; <span class="el_source">AcslParser.java</span></div><h1>AcslParser.java</h1><pre class="source lang-java linenums">// $ANTLR 3.5.2 AcslParser.g 2016-04-11 02:06:43

package edu.udel.cis.vsl.abc.front.c.parse;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings(&quot;all&quot;)
public class AcslParser extends Parser {
<span class="nc" id="L18">	public static final String[] tokenNames = new String[] {</span>
		&quot;&lt;invalid&gt;&quot;, &quot;&lt;EOR&gt;&quot;, &quot;&lt;DOWN&gt;&quot;, &quot;&lt;UP&gt;&quot;, &quot;ALLOC&quot;, &quot;AMPERSAND&quot;, &quot;ANYACT&quot;, 
		&quot;ARROW&quot;, &quot;ASSIGN&quot;, &quot;ASSIGNS&quot;, &quot;ASSUMES&quot;, &quot;AT&quot;, &quot;BAR&quot;, &quot;BEHAVIOR&quot;, &quot;BEHAVIORS&quot;, 
		&quot;BITXOR&quot;, &quot;BOOLEAN&quot;, &quot;BOTH&quot;, &quot;BinaryExponentPart&quot;, &quot;CALL&quot;, &quot;CHAR&quot;, &quot;COL&quot;, 
		&quot;COLON&quot;, &quot;COMMA&quot;, &quot;COMP&quot;, &quot;COMPLETE&quot;, &quot;DECREASES&quot;, &quot;DEPENDS&quot;, &quot;DISJOINT&quot;, 
		&quot;DIVIDE&quot;, &quot;DOT&quot;, &quot;DOTDOT&quot;, &quot;DOUBLE&quot;, &quot;DecimalConstant&quot;, &quot;DecimalFloatingConstant&quot;, 
		&quot;Digit&quot;, &quot;ELLIPSIS&quot;, &quot;EMPTY&quot;, &quot;ENSURES&quot;, &quot;EQ&quot;, &quot;EQUIV&quot;, &quot;EXISTS&quot;, &quot;EscapeSequence&quot;, 
		&quot;ExponentPart&quot;, &quot;FALSE&quot;, &quot;FLOAT&quot;, &quot;FLOATING_CONSTANT&quot;, &quot;FOR&quot;, &quot;FORALL&quot;, 
		&quot;FREES&quot;, &quot;FloatingSuffix&quot;, &quot;FractionalConstant&quot;, &quot;GT&quot;, &quot;GTE&quot;, &quot;GUARDS&quot;, 
		&quot;HASH&quot;, &quot;HexFractionalConstant&quot;, &quot;HexPrefix&quot;, &quot;HexQuad&quot;, &quot;HexadecimalConstant&quot;, 
		&quot;HexadecimalDigit&quot;, &quot;HexadecimalFloatingConstant&quot;, &quot;ID&quot;, &quot;IMPLY&quot;, &quot;INT&quot;, 
		&quot;INTEGER&quot;, &quot;INTEGER_CONSTANT&quot;, &quot;INTER&quot;, &quot;INVARIANT&quot;, &quot;IdentifierNonDigit&quot;, 
		&quot;IntegerSuffix&quot;, &quot;LAND&quot;, &quot;LCOMMENT&quot;, &quot;LCURLY&quot;, &quot;LET&quot;, &quot;LONG&quot;, &quot;LOOP&quot;, 
		&quot;LOR&quot;, &quot;LPAREN&quot;, &quot;LSQUARE&quot;, &quot;LT&quot;, &quot;LTE&quot;, &quot;LongLongSuffix&quot;, &quot;LongSuffix&quot;, 
		&quot;MOD&quot;, &quot;MPI_AGREE&quot;, &quot;MPI_COLLECTIVE&quot;, &quot;MPI_COMM_RANK&quot;, &quot;MPI_COMM_SIZE&quot;, 
		&quot;MPI_EMPTY_IN&quot;, &quot;MPI_EMPTY_OUT&quot;, &quot;MPI_EQUALS&quot;, &quot;MPI_REGION&quot;, &quot;NEQ&quot;, &quot;NEWLINE&quot;, 
		&quot;NOACT&quot;, &quot;NOT&quot;, &quot;NOTHING&quot;, &quot;NULL&quot;, &quot;NewLine&quot;, &quot;NonDigit&quot;, &quot;NonZeroDigit&quot;, 
		&quot;OLD&quot;, &quot;OctalConstant&quot;, &quot;OctalDigit&quot;, &quot;OctalEscape&quot;, &quot;P2P&quot;, &quot;PLUS&quot;, &quot;PP_NUMBER&quot;, 
		&quot;PURE&quot;, &quot;QUESTION&quot;, &quot;RCOMMENT&quot;, &quot;RCURLY&quot;, &quot;REACH&quot;, &quot;READ&quot;, &quot;READS&quot;, &quot;REAL&quot;, 
		&quot;REMOTE_ACCESS&quot;, &quot;REQUIRES&quot;, &quot;RESULT&quot;, &quot;RPAREN&quot;, &quot;RSQUARE&quot;, &quot;SChar&quot;, &quot;SELF&quot;, 
		&quot;SEMICOL&quot;, &quot;SHIFTLEFT&quot;, &quot;SHIFTRIGHT&quot;, &quot;SHORT&quot;, &quot;SIZEOF&quot;, &quot;STAR&quot;, &quot;STRING_LITERAL&quot;, 
		&quot;SUB&quot;, &quot;TERMINATES&quot;, &quot;TRUE&quot;, &quot;UNION&quot;, &quot;UniversalCharacterName&quot;, &quot;UnsignedSuffix&quot;, 
		&quot;VALID&quot;, &quot;VARIANT&quot;, &quot;VOID&quot;, &quot;WITH&quot;, &quot;WRITE&quot;, &quot;WS&quot;, &quot;XOR&quot;, &quot;Zero&quot;, &quot;ARGUMENT_LIST&quot;, 
		&quot;BEHAVIOR_BODY&quot;, &quot;BEHAVIOR_COMPLETE&quot;, &quot;BEHAVIOR_DISJOINT&quot;, &quot;BINDER&quot;, &quot;BINDER_LIST&quot;, 
		&quot;CAST&quot;, &quot;CHARACTER_CONSTANT&quot;, &quot;CLAUSE_BEHAVIOR&quot;, &quot;CLAUSE_COMPLETE&quot;, &quot;CLAUSE_NORMAL&quot;, 
		&quot;CONTRACT&quot;, &quot;C_TYPE&quot;, &quot;EVENT_BASE&quot;, &quot;EVENT_INTS&quot;, &quot;EVENT_LIST&quot;, &quot;EVENT_PARENTHESIZED&quot;, 
		&quot;EVENT_PLUS&quot;, &quot;EVENT_SUB&quot;, &quot;FUNC_CALL&quot;, &quot;FUNC_CONTRACT&quot;, &quot;FUNC_CONTRACT_BLOCK&quot;, 
		&quot;ID_LIST&quot;, &quot;INDEX&quot;, &quot;LOGIC_TYPE&quot;, &quot;LOOP_ALLOC&quot;, &quot;LOOP_ASSIGNS&quot;, &quot;LOOP_BEHAVIOR&quot;, 
		&quot;LOOP_CLAUSE&quot;, &quot;LOOP_CONTRACT&quot;, &quot;LOOP_CONTRACT_BLOCK&quot;, &quot;LOOP_FREE&quot;, &quot;LOOP_INVARIANT&quot;, 
		&quot;LOOP_VARIANT&quot;, &quot;LSHIFT&quot;, &quot;MINUS&quot;, &quot;MPI_CONSTANT&quot;, &quot;MPI_EXPRESSION&quot;, &quot;OPERATOR&quot;, 
		&quot;RSHIFT&quot;, &quot;SET_BINDERS&quot;, &quot;SET_SIMPLE&quot;, &quot;SIZEOF_EXPR&quot;, &quot;SIZEOF_TYPE&quot;, &quot;TEMINATES&quot;, 
		&quot;TERM_PARENTHESIZED&quot;, &quot;TYPE_BUILTIN&quot;, &quot;TYPE_ID&quot;, &quot;VAR_ID&quot;, &quot;VAR_ID_BASE&quot;, 
		&quot;VAR_ID_SQUARE&quot;, &quot;VAR_ID_STAR&quot;
	};
	public static final int EOF=-1;
	public static final int ALLOC=4;
	public static final int AMPERSAND=5;
	public static final int ANYACT=6;
	public static final int ARROW=7;
	public static final int ASSIGN=8;
	public static final int ASSIGNS=9;
	public static final int ASSUMES=10;
	public static final int AT=11;
	public static final int BAR=12;
	public static final int BEHAVIOR=13;
	public static final int BEHAVIORS=14;
	public static final int BITXOR=15;
	public static final int BOOLEAN=16;
	public static final int BOTH=17;
	public static final int BinaryExponentPart=18;
	public static final int CALL=19;
	public static final int CHAR=20;
	public static final int COL=21;
	public static final int COLON=22;
	public static final int COMMA=23;
	public static final int COMP=24;
	public static final int COMPLETE=25;
	public static final int DECREASES=26;
	public static final int DEPENDS=27;
	public static final int DISJOINT=28;
	public static final int DIVIDE=29;
	public static final int DOT=30;
	public static final int DOTDOT=31;
	public static final int DOUBLE=32;
	public static final int DecimalConstant=33;
	public static final int DecimalFloatingConstant=34;
	public static final int Digit=35;
	public static final int ELLIPSIS=36;
	public static final int EMPTY=37;
	public static final int ENSURES=38;
	public static final int EQ=39;
	public static final int EQUIV=40;
	public static final int EXISTS=41;
	public static final int EscapeSequence=42;
	public static final int ExponentPart=43;
	public static final int FALSE=44;
	public static final int FLOAT=45;
	public static final int FLOATING_CONSTANT=46;
	public static final int FOR=47;
	public static final int FORALL=48;
	public static final int FREES=49;
	public static final int FloatingSuffix=50;
	public static final int FractionalConstant=51;
	public static final int GT=52;
	public static final int GTE=53;
	public static final int GUARDS=54;
	public static final int HASH=55;
	public static final int HexFractionalConstant=56;
	public static final int HexPrefix=57;
	public static final int HexQuad=58;
	public static final int HexadecimalConstant=59;
	public static final int HexadecimalDigit=60;
	public static final int HexadecimalFloatingConstant=61;
	public static final int ID=62;
	public static final int IMPLY=63;
	public static final int INT=64;
	public static final int INTEGER=65;
	public static final int INTEGER_CONSTANT=66;
	public static final int INTER=67;
	public static final int INVARIANT=68;
	public static final int IdentifierNonDigit=69;
	public static final int IntegerSuffix=70;
	public static final int LAND=71;
	public static final int LCOMMENT=72;
	public static final int LCURLY=73;
	public static final int LET=74;
	public static final int LONG=75;
	public static final int LOOP=76;
	public static final int LOR=77;
	public static final int LPAREN=78;
	public static final int LSQUARE=79;
	public static final int LT=80;
	public static final int LTE=81;
	public static final int LongLongSuffix=82;
	public static final int LongSuffix=83;
	public static final int MOD=84;
	public static final int MPI_AGREE=85;
	public static final int MPI_COLLECTIVE=86;
	public static final int MPI_COMM_RANK=87;
	public static final int MPI_COMM_SIZE=88;
	public static final int MPI_EMPTY_IN=89;
	public static final int MPI_EMPTY_OUT=90;
	public static final int MPI_EQUALS=91;
	public static final int MPI_REGION=92;
	public static final int NEQ=93;
	public static final int NEWLINE=94;
	public static final int NOACT=95;
	public static final int NOT=96;
	public static final int NOTHING=97;
	public static final int NULL=98;
	public static final int NewLine=99;
	public static final int NonDigit=100;
	public static final int NonZeroDigit=101;
	public static final int OLD=102;
	public static final int OctalConstant=103;
	public static final int OctalDigit=104;
	public static final int OctalEscape=105;
	public static final int P2P=106;
	public static final int PLUS=107;
	public static final int PP_NUMBER=108;
	public static final int PURE=109;
	public static final int QUESTION=110;
	public static final int RCOMMENT=111;
	public static final int RCURLY=112;
	public static final int REACH=113;
	public static final int READ=114;
	public static final int READS=115;
	public static final int REAL=116;
	public static final int REMOTE_ACCESS=117;
	public static final int REQUIRES=118;
	public static final int RESULT=119;
	public static final int RPAREN=120;
	public static final int RSQUARE=121;
	public static final int SChar=122;
	public static final int SELF=123;
	public static final int SEMICOL=124;
	public static final int SHIFTLEFT=125;
	public static final int SHIFTRIGHT=126;
	public static final int SHORT=127;
	public static final int SIZEOF=128;
	public static final int STAR=129;
	public static final int STRING_LITERAL=130;
	public static final int SUB=131;
	public static final int TERMINATES=132;
	public static final int TRUE=133;
	public static final int UNION=134;
	public static final int UniversalCharacterName=135;
	public static final int UnsignedSuffix=136;
	public static final int VALID=137;
	public static final int VARIANT=138;
	public static final int VOID=139;
	public static final int WITH=140;
	public static final int WRITE=141;
	public static final int WS=142;
	public static final int XOR=143;
	public static final int Zero=144;
	public static final int ARGUMENT_LIST=145;
	public static final int BEHAVIOR_BODY=146;
	public static final int BEHAVIOR_COMPLETE=147;
	public static final int BEHAVIOR_DISJOINT=148;
	public static final int BINDER=149;
	public static final int BINDER_LIST=150;
	public static final int CAST=151;
	public static final int CHARACTER_CONSTANT=152;
	public static final int CLAUSE_BEHAVIOR=153;
	public static final int CLAUSE_COMPLETE=154;
	public static final int CLAUSE_NORMAL=155;
	public static final int CONTRACT=156;
	public static final int C_TYPE=157;
	public static final int EVENT_BASE=158;
	public static final int EVENT_INTS=159;
	public static final int EVENT_LIST=160;
	public static final int EVENT_PARENTHESIZED=161;
	public static final int EVENT_PLUS=162;
	public static final int EVENT_SUB=163;
	public static final int FUNC_CALL=164;
	public static final int FUNC_CONTRACT=165;
	public static final int FUNC_CONTRACT_BLOCK=166;
	public static final int ID_LIST=167;
	public static final int INDEX=168;
	public static final int LOGIC_TYPE=169;
	public static final int LOOP_ALLOC=170;
	public static final int LOOP_ASSIGNS=171;
	public static final int LOOP_BEHAVIOR=172;
	public static final int LOOP_CLAUSE=173;
	public static final int LOOP_CONTRACT=174;
	public static final int LOOP_CONTRACT_BLOCK=175;
	public static final int LOOP_FREE=176;
	public static final int LOOP_INVARIANT=177;
	public static final int LOOP_VARIANT=178;
	public static final int LSHIFT=179;
	public static final int MINUS=180;
	public static final int MPI_CONSTANT=181;
	public static final int MPI_EXPRESSION=182;
	public static final int OPERATOR=183;
	public static final int RSHIFT=184;
	public static final int SET_BINDERS=185;
	public static final int SET_SIMPLE=186;
	public static final int SIZEOF_EXPR=187;
	public static final int SIZEOF_TYPE=188;
	public static final int TEMINATES=189;
	public static final int TERM_PARENTHESIZED=190;
	public static final int TYPE_BUILTIN=191;
	public static final int TYPE_ID=192;
	public static final int VAR_ID=193;
	public static final int VAR_ID_BASE=194;
	public static final int VAR_ID_SQUARE=195;
	public static final int VAR_ID_STAR=196;

	// delegates
	public Parser[] getDelegates() {
<span class="nc" id="L249">		return new Parser[] {};</span>
	}

	// delegators


	public AcslParser(TokenStream input) {
<span class="nc" id="L256">		this(input, new RecognizerSharedState());</span>
<span class="nc" id="L257">	}</span>
	public AcslParser(TokenStream input, RecognizerSharedState state) {
<span class="nc" id="L259">		super(input, state);</span>
<span class="nc" id="L260">	}</span>

<span class="nc" id="L262">	protected TreeAdaptor adaptor = new CommonTreeAdaptor();</span>

	public void setTreeAdaptor(TreeAdaptor adaptor) {
<span class="nc" id="L265">		this.adaptor = adaptor;</span>
<span class="nc" id="L266">	}</span>
	public TreeAdaptor getTreeAdaptor() {
<span class="nc" id="L268">		return adaptor;</span>
	}
<span class="nc" id="L270">	@Override public String[] getTokenNames() { return AcslParser.tokenNames; }</span>
<span class="nc" id="L271">	@Override public String getGrammarFileName() { return &quot;AcslParser.g&quot;; }</span>


<span class="nc" id="L274">	public static class contract_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L277">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;contract&quot;
	// AcslParser.g:75:1: contract : ( function_contract -&gt; ^( CONTRACT function_contract ) | loop_contract -&gt; ^( CONTRACT loop_contract ) );
	public final AcslParser.contract_return contract() throws RecognitionException {
<span class="nc" id="L284">		AcslParser.contract_return retval = new AcslParser.contract_return();</span>
<span class="nc" id="L285">		retval.start = input.LT(1);</span>

<span class="nc" id="L287">		Object root_0 = null;</span>

<span class="nc" id="L289">		ParserRuleReturnScope function_contract1 =null;</span>
<span class="nc" id="L290">		ParserRuleReturnScope loop_contract2 =null;</span>

<span class="nc" id="L292">		RewriteRuleSubtreeStream stream_function_contract=new RewriteRuleSubtreeStream(adaptor,&quot;rule function_contract&quot;);</span>
<span class="nc" id="L293">		RewriteRuleSubtreeStream stream_loop_contract=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_contract&quot;);</span>

		try {
			// AcslParser.g:76:5: ( function_contract -&gt; ^( CONTRACT function_contract ) | loop_contract -&gt; ^( CONTRACT loop_contract ) )
<span class="nc" id="L297">			int alt1=2;</span>
<span class="nc" id="L298">			int LA1_0 = input.LA(1);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">			if ( (LA1_0==LCOMMENT) ) {</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">				switch ( input.LA(2) ) {</span>
				case ALLOC:
				case ASSIGNS:
				case BEHAVIOR:
				case COMPLETE:
				case DEPENDS:
				case DISJOINT:
				case ENSURES:
				case FREES:
				case GUARDS:
				case MPI_COLLECTIVE:
				case PURE:
				case READS:
				case REQUIRES:
				case TEMINATES:
					{
<span class="nc" id="L316">					alt1=1;</span>
					}
<span class="nc" id="L318">					break;</span>
				case RCOMMENT:
					{
<span class="nc" id="L321">					int LA1_3 = input.LA(3);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">					if ( (synpred1_AcslParser()) ) {</span>
<span class="nc" id="L323">						alt1=1;</span>
					}
					else if ( (true) ) {
<span class="nc" id="L326">						alt1=2;</span>
					}

					}
<span class="nc" id="L330">					break;</span>
				case FOR:
				case LOOP:
					{
<span class="nc" id="L334">					alt1=2;</span>
					}
<span class="nc" id="L336">					break;</span>
				default:
<span class="nc bnc" id="L338" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L339">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L341">						input.consume();</span>
<span class="nc" id="L342">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 1, 1, input);
<span class="nc" id="L344">						throw nvae;</span>
					} finally {
<span class="nc" id="L346">						input.rewind(nvaeMark);</span>
					}
				}
			}

			else {
<span class="nc bnc" id="L352" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L353">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 1, 0, input);
<span class="nc" id="L355">				throw nvae;</span>
			}

<span class="nc bnc" id="L358" title="All 3 branches missed.">			switch (alt1) {</span>
				case 1 :
					// AcslParser.g:76:7: function_contract
					{
<span class="nc" id="L362">					pushFollow(FOLLOW_function_contract_in_contract391);</span>
<span class="nc" id="L363">					function_contract1=function_contract();</span>
<span class="nc" id="L364">					state._fsp--;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_function_contract.add(function_contract1.getTree());</span>
					// AST REWRITE
					// elements: function_contract
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L374" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L375">					retval.tree = root_0;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L378">					root_0 = (Object)adaptor.nil();</span>
					// 77:9: -&gt; ^( CONTRACT function_contract )
					{
						// AcslParser.g:77:12: ^( CONTRACT function_contract )
						{
<span class="nc" id="L383">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L384">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CONTRACT, &quot;CONTRACT&quot;), root_1);</span>
<span class="nc" id="L385">						adaptor.addChild(root_1, stream_function_contract.nextTree());</span>
<span class="nc" id="L386">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L392">					retval.tree = root_0;</span>
<span class="nc" id="L393">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:78:7: loop_contract
					{
<span class="nc" id="L400">					pushFollow(FOLLOW_loop_contract_in_contract415);</span>
<span class="nc" id="L401">					loop_contract2=loop_contract();</span>
<span class="nc" id="L402">					state._fsp--;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_contract.add(loop_contract2.getTree());</span>
					// AST REWRITE
					// elements: loop_contract
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L412" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L413">					retval.tree = root_0;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L416">					root_0 = (Object)adaptor.nil();</span>
					// 79:9: -&gt; ^( CONTRACT loop_contract )
					{
						// AcslParser.g:79:12: ^( CONTRACT loop_contract )
						{
<span class="nc" id="L421">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L422">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CONTRACT, &quot;CONTRACT&quot;), root_1);</span>
<span class="nc" id="L423">						adaptor.addChild(root_1, stream_loop_contract.nextTree());</span>
<span class="nc" id="L424">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L430">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L437">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L439" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L440">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L441">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L444">		catch (RecognitionException re) {</span>
<span class="nc" id="L445">			reportError(re);</span>
<span class="nc" id="L446">			recover(input,re);</span>
<span class="nc" id="L447">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L449">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L451">		}</span>
<span class="nc" id="L452">		return retval;</span>
	}
	// $ANTLR end &quot;contract&quot;


<span class="nc" id="L457">	public static class loop_contract_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L460">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_contract&quot;
	// AcslParser.g:82:1: loop_contract : LCOMMENT loop_contract_block RCOMMENT -&gt; ^( LOOP_CONTRACT loop_contract_block ) ;
	public final AcslParser.loop_contract_return loop_contract() throws RecognitionException {
<span class="nc" id="L467">		AcslParser.loop_contract_return retval = new AcslParser.loop_contract_return();</span>
<span class="nc" id="L468">		retval.start = input.LT(1);</span>

<span class="nc" id="L470">		Object root_0 = null;</span>

<span class="nc" id="L472">		Token LCOMMENT3=null;</span>
<span class="nc" id="L473">		Token RCOMMENT5=null;</span>
<span class="nc" id="L474">		ParserRuleReturnScope loop_contract_block4 =null;</span>

<span class="nc" id="L476">		Object LCOMMENT3_tree=null;</span>
<span class="nc" id="L477">		Object RCOMMENT5_tree=null;</span>
<span class="nc" id="L478">		RewriteRuleTokenStream stream_LCOMMENT=new RewriteRuleTokenStream(adaptor,&quot;token LCOMMENT&quot;);</span>
<span class="nc" id="L479">		RewriteRuleTokenStream stream_RCOMMENT=new RewriteRuleTokenStream(adaptor,&quot;token RCOMMENT&quot;);</span>
<span class="nc" id="L480">		RewriteRuleSubtreeStream stream_loop_contract_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_contract_block&quot;);</span>

		try {
			// AcslParser.g:83:5: ( LCOMMENT loop_contract_block RCOMMENT -&gt; ^( LOOP_CONTRACT loop_contract_block ) )
			// AcslParser.g:83:7: LCOMMENT loop_contract_block RCOMMENT
			{
<span class="nc bnc" id="L486" title="All 2 branches missed.">			LCOMMENT3=(Token)match(input,LCOMMENT,FOLLOW_LCOMMENT_in_loop_contract448); if (state.failed) return retval; </span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_LCOMMENT.add(LCOMMENT3);</span>

<span class="nc" id="L489">			pushFollow(FOLLOW_loop_contract_block_in_loop_contract450);</span>
<span class="nc" id="L490">			loop_contract_block4=loop_contract_block();</span>
<span class="nc" id="L491">			state._fsp--;</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_loop_contract_block.add(loop_contract_block4.getTree());</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">			RCOMMENT5=(Token)match(input,RCOMMENT,FOLLOW_RCOMMENT_in_loop_contract452); if (state.failed) return retval; </span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_RCOMMENT.add(RCOMMENT5);</span>

			// AST REWRITE
			// elements: loop_contract_block
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L504" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L505">			retval.tree = root_0;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L508">			root_0 = (Object)adaptor.nil();</span>
			// 84:9: -&gt; ^( LOOP_CONTRACT loop_contract_block )
			{
				// AcslParser.g:84:11: ^( LOOP_CONTRACT loop_contract_block )
				{
<span class="nc" id="L513">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L514">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_CONTRACT, &quot;LOOP_CONTRACT&quot;), root_1);</span>
<span class="nc" id="L515">				adaptor.addChild(root_1, stream_loop_contract_block.nextTree());</span>
<span class="nc" id="L516">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L522">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L527">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L530">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L531">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L534">		catch (RecognitionException re) {</span>
<span class="nc" id="L535">			reportError(re);</span>
<span class="nc" id="L536">			recover(input,re);</span>
<span class="nc" id="L537">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L539">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L541">		}</span>
<span class="nc" id="L542">		return retval;</span>
	}
	// $ANTLR end &quot;loop_contract&quot;


<span class="nc" id="L547">	public static class loop_contract_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L550">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_contract_block&quot;
	// AcslParser.g:87:1: loop_contract_block : (lc+= loop_clause )* (lb+= loop_behavior )* (lv= loop_variant )? -&gt; ^( LOOP_CONTRACT_BLOCK ( $lc)* ( $lb)* ( $lv)? ) ;
	public final AcslParser.loop_contract_block_return loop_contract_block() throws RecognitionException {
<span class="nc" id="L557">		AcslParser.loop_contract_block_return retval = new AcslParser.loop_contract_block_return();</span>
<span class="nc" id="L558">		retval.start = input.LT(1);</span>

<span class="nc" id="L560">		Object root_0 = null;</span>

<span class="nc" id="L562">		List&lt;Object&gt; list_lc=null;</span>
<span class="nc" id="L563">		List&lt;Object&gt; list_lb=null;</span>
<span class="nc" id="L564">		ParserRuleReturnScope lv =null;</span>
<span class="nc" id="L565">		RuleReturnScope lc = null;</span>
<span class="nc" id="L566">		RuleReturnScope lb = null;</span>
<span class="nc" id="L567">		RewriteRuleSubtreeStream stream_loop_variant=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_variant&quot;);</span>
<span class="nc" id="L568">		RewriteRuleSubtreeStream stream_loop_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_clause&quot;);</span>
<span class="nc" id="L569">		RewriteRuleSubtreeStream stream_loop_behavior=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_behavior&quot;);</span>

		try {
			// AcslParser.g:88:5: ( (lc+= loop_clause )* (lb+= loop_behavior )* (lv= loop_variant )? -&gt; ^( LOOP_CONTRACT_BLOCK ( $lc)* ( $lb)* ( $lv)? ) )
			// AcslParser.g:88:7: (lc+= loop_clause )* (lb+= loop_behavior )* (lv= loop_variant )?
			{
			// AcslParser.g:88:9: (lc+= loop_clause )*
			loop2:
			while (true) {
<span class="nc" id="L578">				int alt2=2;</span>
<span class="nc" id="L579">				int LA2_0 = input.LA(1);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">				if ( (LA2_0==LOOP) ) {</span>
<span class="nc" id="L581">					int LA2_2 = input.LA(2);</span>
<span class="nc bnc" id="L582" title="All 8 branches missed.">					if ( (LA2_2==ALLOC||LA2_2==ASSIGNS||LA2_2==FREES||LA2_2==INVARIANT) ) {</span>
<span class="nc" id="L583">						alt2=1;</span>
					}

				}

<span class="nc bnc" id="L588" title="All 2 branches missed.">				switch (alt2) {</span>
				case 1 :
					// AcslParser.g:88:9: lc+= loop_clause
					{
<span class="nc" id="L592">					pushFollow(FOLLOW_loop_clause_in_loop_contract_block486);</span>
<span class="nc" id="L593">					lc=loop_clause();</span>
<span class="nc" id="L594">					state._fsp--;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_clause.add(lc.getTree());</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">					if (list_lc==null) list_lc=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L598">					list_lc.add(lc.getTree());</span>
					}
<span class="nc" id="L600">					break;</span>

				default :
<span class="nc" id="L603">					break loop2;</span>
				}
<span class="nc" id="L605">			}</span>

			// AcslParser.g:88:26: (lb+= loop_behavior )*
			loop3:
			while (true) {
<span class="nc" id="L610">				int alt3=2;</span>
<span class="nc" id="L611">				int LA3_0 = input.LA(1);</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">				if ( (LA3_0==FOR) ) {</span>
<span class="nc" id="L613">					alt3=1;</span>
				}

<span class="nc bnc" id="L616" title="All 2 branches missed.">				switch (alt3) {</span>
				case 1 :
					// AcslParser.g:88:26: lb+= loop_behavior
					{
<span class="nc" id="L620">					pushFollow(FOLLOW_loop_behavior_in_loop_contract_block491);</span>
<span class="nc" id="L621">					lb=loop_behavior();</span>
<span class="nc" id="L622">					state._fsp--;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_behavior.add(lb.getTree());</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">					if (list_lb==null) list_lb=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L626">					list_lb.add(lb.getTree());</span>
					}
<span class="nc" id="L628">					break;</span>

				default :
<span class="nc" id="L631">					break loop3;</span>
				}
<span class="nc" id="L633">			}</span>

			// AcslParser.g:88:45: (lv= loop_variant )?
<span class="nc" id="L636">			int alt4=2;</span>
<span class="nc" id="L637">			int LA4_0 = input.LA(1);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">			if ( (LA4_0==LOOP) ) {</span>
<span class="nc" id="L639">				alt4=1;</span>
			}
<span class="nc bnc" id="L641" title="All 2 branches missed.">			switch (alt4) {</span>
				case 1 :
					// AcslParser.g:88:45: lv= loop_variant
					{
<span class="nc" id="L645">					pushFollow(FOLLOW_loop_variant_in_loop_contract_block496);</span>
<span class="nc" id="L646">					lv=loop_variant();</span>
<span class="nc" id="L647">					state._fsp--;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_variant.add(lv.getTree());</span>
					}
					break;

			}

			// AST REWRITE
			// elements: lb, lv, lc
			// token labels: 
			// rule labels: retval, lv
			// token list labels: 
			// rule list labels: lc, lb
			// wildcard labels: 
<span class="nc bnc" id="L662" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L663">			retval.tree = root_0;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_lv=new RewriteRuleSubtreeStream(adaptor,&quot;rule lv&quot;,lv!=null?lv.getTree():null);</span>
<span class="nc" id="L666">			RewriteRuleSubtreeStream stream_lc=new RewriteRuleSubtreeStream(adaptor,&quot;token lc&quot;,list_lc);</span>
<span class="nc" id="L667">			RewriteRuleSubtreeStream stream_lb=new RewriteRuleSubtreeStream(adaptor,&quot;token lb&quot;,list_lb);</span>
<span class="nc" id="L668">			root_0 = (Object)adaptor.nil();</span>
			// 89:9: -&gt; ^( LOOP_CONTRACT_BLOCK ( $lc)* ( $lb)* ( $lv)? )
			{
				// AcslParser.g:89:11: ^( LOOP_CONTRACT_BLOCK ( $lc)* ( $lb)* ( $lv)? )
				{
<span class="nc" id="L673">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L674">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_CONTRACT_BLOCK, &quot;LOOP_CONTRACT_BLOCK&quot;), root_1);</span>
				// AcslParser.g:89:34: ( $lc)*
<span class="nc bnc" id="L676" title="All 2 branches missed.">				while ( stream_lc.hasNext() ) {</span>
<span class="nc" id="L677">					adaptor.addChild(root_1, stream_lc.nextTree());</span>
				}
<span class="nc" id="L679">				stream_lc.reset();</span>

				// AcslParser.g:89:39: ( $lb)*
<span class="nc bnc" id="L682" title="All 2 branches missed.">				while ( stream_lb.hasNext() ) {</span>
<span class="nc" id="L683">					adaptor.addChild(root_1, stream_lb.nextTree());</span>
				}
<span class="nc" id="L685">				stream_lb.reset();</span>

				// AcslParser.g:89:44: ( $lv)?
<span class="nc bnc" id="L688" title="All 2 branches missed.">				if ( stream_lv.hasNext() ) {</span>
<span class="nc" id="L689">					adaptor.addChild(root_1, stream_lv.nextTree());</span>
				}
<span class="nc" id="L691">				stream_lv.reset();</span>

<span class="nc" id="L693">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L699">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L704">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L706" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L707">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L708">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L711">		catch (RecognitionException re) {</span>
<span class="nc" id="L712">			reportError(re);</span>
<span class="nc" id="L713">			recover(input,re);</span>
<span class="nc" id="L714">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L716">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L718">		}</span>
<span class="nc" id="L719">		return retval;</span>
	}
	// $ANTLR end &quot;loop_contract_block&quot;


<span class="nc" id="L724">	public static class loop_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L727">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_clause&quot;
	// AcslParser.g:92:1: loop_clause : ( loop_invariant SEMICOL -&gt; ^( LOOP_CLAUSE loop_invariant ) | loop_assigns SEMICOL -&gt; ^( LOOP_CLAUSE loop_assigns ) | loop_allocation SEMICOL -&gt; ^( LOOP_CLAUSE loop_allocation ) );
	public final AcslParser.loop_clause_return loop_clause() throws RecognitionException {
<span class="nc" id="L734">		AcslParser.loop_clause_return retval = new AcslParser.loop_clause_return();</span>
<span class="nc" id="L735">		retval.start = input.LT(1);</span>

<span class="nc" id="L737">		Object root_0 = null;</span>

<span class="nc" id="L739">		Token SEMICOL7=null;</span>
<span class="nc" id="L740">		Token SEMICOL9=null;</span>
<span class="nc" id="L741">		Token SEMICOL11=null;</span>
<span class="nc" id="L742">		ParserRuleReturnScope loop_invariant6 =null;</span>
<span class="nc" id="L743">		ParserRuleReturnScope loop_assigns8 =null;</span>
<span class="nc" id="L744">		ParserRuleReturnScope loop_allocation10 =null;</span>

<span class="nc" id="L746">		Object SEMICOL7_tree=null;</span>
<span class="nc" id="L747">		Object SEMICOL9_tree=null;</span>
<span class="nc" id="L748">		Object SEMICOL11_tree=null;</span>
<span class="nc" id="L749">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L750">		RewriteRuleSubtreeStream stream_loop_invariant=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_invariant&quot;);</span>
<span class="nc" id="L751">		RewriteRuleSubtreeStream stream_loop_assigns=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_assigns&quot;);</span>
<span class="nc" id="L752">		RewriteRuleSubtreeStream stream_loop_allocation=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_allocation&quot;);</span>

		try {
			// AcslParser.g:93:5: ( loop_invariant SEMICOL -&gt; ^( LOOP_CLAUSE loop_invariant ) | loop_assigns SEMICOL -&gt; ^( LOOP_CLAUSE loop_assigns ) | loop_allocation SEMICOL -&gt; ^( LOOP_CLAUSE loop_allocation ) )
<span class="nc" id="L756">			int alt5=3;</span>
<span class="nc" id="L757">			int LA5_0 = input.LA(1);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">			if ( (LA5_0==LOOP) ) {</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">				switch ( input.LA(2) ) {</span>
				case INVARIANT:
					{
<span class="nc" id="L762">					alt5=1;</span>
					}
<span class="nc" id="L764">					break;</span>
				case ASSIGNS:
					{
<span class="nc" id="L767">					alt5=2;</span>
					}
<span class="nc" id="L769">					break;</span>
				case ALLOC:
				case FREES:
					{
<span class="nc" id="L773">					alt5=3;</span>
					}
<span class="nc" id="L775">					break;</span>
				default:
<span class="nc bnc" id="L777" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L778">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L780">						input.consume();</span>
<span class="nc" id="L781">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 5, 1, input);
<span class="nc" id="L783">						throw nvae;</span>
					} finally {
<span class="nc" id="L785">						input.rewind(nvaeMark);</span>
					}
				}
			}

			else {
<span class="nc bnc" id="L791" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L792">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 5, 0, input);
<span class="nc" id="L794">				throw nvae;</span>
			}

<span class="nc bnc" id="L797" title="All 4 branches missed.">			switch (alt5) {</span>
				case 1 :
					// AcslParser.g:93:7: loop_invariant SEMICOL
					{
<span class="nc" id="L801">					pushFollow(FOLLOW_loop_invariant_in_loop_clause539);</span>
<span class="nc" id="L802">					loop_invariant6=loop_invariant();</span>
<span class="nc" id="L803">					state._fsp--;</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_invariant.add(loop_invariant6.getTree());</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">					SEMICOL7=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_loop_clause541); if (state.failed) return retval; </span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL7);</span>

					// AST REWRITE
					// elements: loop_invariant
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L816" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L817">					retval.tree = root_0;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L820">					root_0 = (Object)adaptor.nil();</span>
					// 94:9: -&gt; ^( LOOP_CLAUSE loop_invariant )
					{
						// AcslParser.g:94:11: ^( LOOP_CLAUSE loop_invariant )
						{
<span class="nc" id="L825">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L826">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_CLAUSE, &quot;LOOP_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L827">						adaptor.addChild(root_1, stream_loop_invariant.nextTree());</span>
<span class="nc" id="L828">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L834">					retval.tree = root_0;</span>
<span class="nc" id="L835">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:95:7: loop_assigns SEMICOL
					{
<span class="nc" id="L842">					pushFollow(FOLLOW_loop_assigns_in_loop_clause564);</span>
<span class="nc" id="L843">					loop_assigns8=loop_assigns();</span>
<span class="nc" id="L844">					state._fsp--;</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_assigns.add(loop_assigns8.getTree());</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">					SEMICOL9=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_loop_clause566); if (state.failed) return retval; </span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL9);</span>

					// AST REWRITE
					// elements: loop_assigns
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L857" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L858">					retval.tree = root_0;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L861">					root_0 = (Object)adaptor.nil();</span>
					// 96:9: -&gt; ^( LOOP_CLAUSE loop_assigns )
					{
						// AcslParser.g:96:11: ^( LOOP_CLAUSE loop_assigns )
						{
<span class="nc" id="L866">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L867">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_CLAUSE, &quot;LOOP_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L868">						adaptor.addChild(root_1, stream_loop_assigns.nextTree());</span>
<span class="nc" id="L869">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L875">					retval.tree = root_0;</span>
<span class="nc" id="L876">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:97:7: loop_allocation SEMICOL
					{
<span class="nc" id="L883">					pushFollow(FOLLOW_loop_allocation_in_loop_clause589);</span>
<span class="nc" id="L884">					loop_allocation10=loop_allocation();</span>
<span class="nc" id="L885">					state._fsp--;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_allocation.add(loop_allocation10.getTree());</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">					SEMICOL11=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_loop_clause591); if (state.failed) return retval; </span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL11);</span>

					// AST REWRITE
					// elements: loop_allocation
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L898" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L899">					retval.tree = root_0;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L902">					root_0 = (Object)adaptor.nil();</span>
					// 98:9: -&gt; ^( LOOP_CLAUSE loop_allocation )
					{
						// AcslParser.g:98:11: ^( LOOP_CLAUSE loop_allocation )
						{
<span class="nc" id="L907">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L908">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_CLAUSE, &quot;LOOP_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L909">						adaptor.addChild(root_1, stream_loop_allocation.nextTree());</span>
<span class="nc" id="L910">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L916">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L923">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L925" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L926">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L927">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L930">		catch (RecognitionException re) {</span>
<span class="nc" id="L931">			reportError(re);</span>
<span class="nc" id="L932">			recover(input,re);</span>
<span class="nc" id="L933">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L935">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L937">		}</span>
<span class="nc" id="L938">		return retval;</span>
	}
	// $ANTLR end &quot;loop_clause&quot;


<span class="nc" id="L943">	public static class loop_invariant_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L946">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_invariant&quot;
	// AcslParser.g:101:1: loop_invariant : LOOP INVARIANT term -&gt; ^( LOOP_INVARIANT term ) ;
	public final AcslParser.loop_invariant_return loop_invariant() throws RecognitionException {
<span class="nc" id="L953">		AcslParser.loop_invariant_return retval = new AcslParser.loop_invariant_return();</span>
<span class="nc" id="L954">		retval.start = input.LT(1);</span>

<span class="nc" id="L956">		Object root_0 = null;</span>

<span class="nc" id="L958">		Token LOOP12=null;</span>
<span class="nc" id="L959">		Token INVARIANT13=null;</span>
<span class="nc" id="L960">		ParserRuleReturnScope term14 =null;</span>

<span class="nc" id="L962">		Object LOOP12_tree=null;</span>
<span class="nc" id="L963">		Object INVARIANT13_tree=null;</span>
<span class="nc" id="L964">		RewriteRuleTokenStream stream_LOOP=new RewriteRuleTokenStream(adaptor,&quot;token LOOP&quot;);</span>
<span class="nc" id="L965">		RewriteRuleTokenStream stream_INVARIANT=new RewriteRuleTokenStream(adaptor,&quot;token INVARIANT&quot;);</span>
<span class="nc" id="L966">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:102:5: ( LOOP INVARIANT term -&gt; ^( LOOP_INVARIANT term ) )
			// AcslParser.g:102:7: LOOP INVARIANT term
			{
<span class="nc bnc" id="L972" title="All 2 branches missed.">			LOOP12=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_invariant623); if (state.failed) return retval; </span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_LOOP.add(LOOP12);</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">			INVARIANT13=(Token)match(input,INVARIANT,FOLLOW_INVARIANT_in_loop_invariant625); if (state.failed) return retval; </span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_INVARIANT.add(INVARIANT13);</span>

<span class="nc" id="L978">			pushFollow(FOLLOW_term_in_loop_invariant627);</span>
<span class="nc" id="L979">			term14=term();</span>
<span class="nc" id="L980">			state._fsp--;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term14.getTree());</span>
			// AST REWRITE
			// elements: term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L990" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L991">			retval.tree = root_0;</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L994">			root_0 = (Object)adaptor.nil();</span>
			// 103:9: -&gt; ^( LOOP_INVARIANT term )
			{
				// AcslParser.g:103:11: ^( LOOP_INVARIANT term )
				{
<span class="nc" id="L999">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1000">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_INVARIANT, &quot;LOOP_INVARIANT&quot;), root_1);</span>
<span class="nc" id="L1001">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L1002">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1008">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L1013">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1016">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1017">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1020">		catch (RecognitionException re) {</span>
<span class="nc" id="L1021">			reportError(re);</span>
<span class="nc" id="L1022">			recover(input,re);</span>
<span class="nc" id="L1023">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1025">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1027">		}</span>
<span class="nc" id="L1028">		return retval;</span>
	}
	// $ANTLR end &quot;loop_invariant&quot;


<span class="nc" id="L1033">	public static class loop_assigns_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1036">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_assigns&quot;
	// AcslParser.g:106:1: loop_assigns : LOOP ASSIGNS argumentExpressionList -&gt; ^( LOOP_ASSIGNS argumentExpressionList ) ;
	public final AcslParser.loop_assigns_return loop_assigns() throws RecognitionException {
<span class="nc" id="L1043">		AcslParser.loop_assigns_return retval = new AcslParser.loop_assigns_return();</span>
<span class="nc" id="L1044">		retval.start = input.LT(1);</span>

<span class="nc" id="L1046">		Object root_0 = null;</span>

<span class="nc" id="L1048">		Token LOOP15=null;</span>
<span class="nc" id="L1049">		Token ASSIGNS16=null;</span>
<span class="nc" id="L1050">		ParserRuleReturnScope argumentExpressionList17 =null;</span>

<span class="nc" id="L1052">		Object LOOP15_tree=null;</span>
<span class="nc" id="L1053">		Object ASSIGNS16_tree=null;</span>
<span class="nc" id="L1054">		RewriteRuleTokenStream stream_LOOP=new RewriteRuleTokenStream(adaptor,&quot;token LOOP&quot;);</span>
<span class="nc" id="L1055">		RewriteRuleTokenStream stream_ASSIGNS=new RewriteRuleTokenStream(adaptor,&quot;token ASSIGNS&quot;);</span>
<span class="nc" id="L1056">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:107:5: ( LOOP ASSIGNS argumentExpressionList -&gt; ^( LOOP_ASSIGNS argumentExpressionList ) )
			// AcslParser.g:107:7: LOOP ASSIGNS argumentExpressionList
			{
<span class="nc bnc" id="L1062" title="All 2 branches missed.">			LOOP15=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_assigns659); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_LOOP.add(LOOP15);</span>

<span class="nc bnc" id="L1065" title="All 2 branches missed.">			ASSIGNS16=(Token)match(input,ASSIGNS,FOLLOW_ASSIGNS_in_loop_assigns661); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ASSIGNS.add(ASSIGNS16);</span>

<span class="nc" id="L1068">			pushFollow(FOLLOW_argumentExpressionList_in_loop_assigns663);</span>
<span class="nc" id="L1069">			argumentExpressionList17=argumentExpressionList();</span>
<span class="nc" id="L1070">			state._fsp--;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList17.getTree());</span>
			// AST REWRITE
			// elements: argumentExpressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L1080" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1081">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1084">			root_0 = (Object)adaptor.nil();</span>
			// 108:9: -&gt; ^( LOOP_ASSIGNS argumentExpressionList )
			{
				// AcslParser.g:108:11: ^( LOOP_ASSIGNS argumentExpressionList )
				{
<span class="nc" id="L1089">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1090">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_ASSIGNS, &quot;LOOP_ASSIGNS&quot;), root_1);</span>
<span class="nc" id="L1091">				adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L1092">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1098">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L1103">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1105" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1106">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1107">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1110">		catch (RecognitionException re) {</span>
<span class="nc" id="L1111">			reportError(re);</span>
<span class="nc" id="L1112">			recover(input,re);</span>
<span class="nc" id="L1113">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1115">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1117">		}</span>
<span class="nc" id="L1118">		return retval;</span>
	}
	// $ANTLR end &quot;loop_assigns&quot;


<span class="nc" id="L1123">	public static class loop_allocation_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1126">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_allocation&quot;
	// AcslParser.g:111:1: loop_allocation : ( LOOP ALLOC argumentExpressionList ( COMMA term )? -&gt; ^( LOOP_ALLOC argumentExpressionList ( term )? ) | LOOP FREES argumentExpressionList -&gt; ^( LOOP_FREE argumentExpressionList ) );
	public final AcslParser.loop_allocation_return loop_allocation() throws RecognitionException {
<span class="nc" id="L1133">		AcslParser.loop_allocation_return retval = new AcslParser.loop_allocation_return();</span>
<span class="nc" id="L1134">		retval.start = input.LT(1);</span>

<span class="nc" id="L1136">		Object root_0 = null;</span>

<span class="nc" id="L1138">		Token LOOP18=null;</span>
<span class="nc" id="L1139">		Token ALLOC19=null;</span>
<span class="nc" id="L1140">		Token COMMA21=null;</span>
<span class="nc" id="L1141">		Token LOOP23=null;</span>
<span class="nc" id="L1142">		Token FREES24=null;</span>
<span class="nc" id="L1143">		ParserRuleReturnScope argumentExpressionList20 =null;</span>
<span class="nc" id="L1144">		ParserRuleReturnScope term22 =null;</span>
<span class="nc" id="L1145">		ParserRuleReturnScope argumentExpressionList25 =null;</span>

<span class="nc" id="L1147">		Object LOOP18_tree=null;</span>
<span class="nc" id="L1148">		Object ALLOC19_tree=null;</span>
<span class="nc" id="L1149">		Object COMMA21_tree=null;</span>
<span class="nc" id="L1150">		Object LOOP23_tree=null;</span>
<span class="nc" id="L1151">		Object FREES24_tree=null;</span>
<span class="nc" id="L1152">		RewriteRuleTokenStream stream_FREES=new RewriteRuleTokenStream(adaptor,&quot;token FREES&quot;);</span>
<span class="nc" id="L1153">		RewriteRuleTokenStream stream_ALLOC=new RewriteRuleTokenStream(adaptor,&quot;token ALLOC&quot;);</span>
<span class="nc" id="L1154">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L1155">		RewriteRuleTokenStream stream_LOOP=new RewriteRuleTokenStream(adaptor,&quot;token LOOP&quot;);</span>
<span class="nc" id="L1156">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L1157">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:112:5: ( LOOP ALLOC argumentExpressionList ( COMMA term )? -&gt; ^( LOOP_ALLOC argumentExpressionList ( term )? ) | LOOP FREES argumentExpressionList -&gt; ^( LOOP_FREE argumentExpressionList ) )
<span class="nc" id="L1161">			int alt7=2;</span>
<span class="nc" id="L1162">			int LA7_0 = input.LA(1);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			if ( (LA7_0==LOOP) ) {</span>
<span class="nc" id="L1164">				int LA7_1 = input.LA(2);</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">				if ( (LA7_1==ALLOC) ) {</span>
<span class="nc" id="L1166">					alt7=1;</span>
				}
<span class="nc bnc" id="L1168" title="All 2 branches missed.">				else if ( (LA7_1==FREES) ) {</span>
<span class="nc" id="L1169">					alt7=2;</span>
				}

				else {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L1174">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L1176">						input.consume();</span>
<span class="nc" id="L1177">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 7, 1, input);
<span class="nc" id="L1179">						throw nvae;</span>
					} finally {
<span class="nc" id="L1181">						input.rewind(nvaeMark);</span>
					}
				}

<span class="nc" id="L1185">			}</span>

			else {
<span class="nc bnc" id="L1188" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L1189">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 7, 0, input);
<span class="nc" id="L1191">				throw nvae;</span>
			}

<span class="nc bnc" id="L1194" title="All 3 branches missed.">			switch (alt7) {</span>
				case 1 :
					// AcslParser.g:112:7: LOOP ALLOC argumentExpressionList ( COMMA term )?
					{
<span class="nc bnc" id="L1198" title="All 2 branches missed.">					LOOP18=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_allocation695); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LOOP.add(LOOP18);</span>

<span class="nc bnc" id="L1201" title="All 2 branches missed.">					ALLOC19=(Token)match(input,ALLOC,FOLLOW_ALLOC_in_loop_allocation697); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ALLOC.add(ALLOC19);</span>

<span class="nc" id="L1204">					pushFollow(FOLLOW_argumentExpressionList_in_loop_allocation699);</span>
<span class="nc" id="L1205">					argumentExpressionList20=argumentExpressionList();</span>
<span class="nc" id="L1206">					state._fsp--;</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList20.getTree());</span>
					// AcslParser.g:112:41: ( COMMA term )?
<span class="nc" id="L1210">					int alt6=2;</span>
<span class="nc" id="L1211">					int LA6_0 = input.LA(1);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">					if ( (LA6_0==COMMA) ) {</span>
<span class="nc" id="L1213">						alt6=1;</span>
					}
<span class="nc bnc" id="L1215" title="All 2 branches missed.">					switch (alt6) {</span>
						case 1 :
							// AcslParser.g:112:42: COMMA term
							{
<span class="nc bnc" id="L1219" title="All 2 branches missed.">							COMMA21=(Token)match(input,COMMA,FOLLOW_COMMA_in_loop_allocation702); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_COMMA.add(COMMA21);</span>

<span class="nc" id="L1222">							pushFollow(FOLLOW_term_in_loop_allocation704);</span>
<span class="nc" id="L1223">							term22=term();</span>
<span class="nc" id="L1224">							state._fsp--;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_term.add(term22.getTree());</span>
							}
							break;

					}

					// AST REWRITE
					// elements: argumentExpressionList, term
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L1239" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1240">					retval.tree = root_0;</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1243">					root_0 = (Object)adaptor.nil();</span>
					// 113:9: -&gt; ^( LOOP_ALLOC argumentExpressionList ( term )? )
					{
						// AcslParser.g:113:11: ^( LOOP_ALLOC argumentExpressionList ( term )? )
						{
<span class="nc" id="L1248">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1249">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_ALLOC, &quot;LOOP_ALLOC&quot;), root_1);</span>
<span class="nc" id="L1250">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
						// AcslParser.g:113:47: ( term )?
<span class="nc bnc" id="L1252" title="All 2 branches missed.">						if ( stream_term.hasNext() ) {</span>
<span class="nc" id="L1253">							adaptor.addChild(root_1, stream_term.nextTree());</span>
						}
<span class="nc" id="L1255">						stream_term.reset();</span>

<span class="nc" id="L1257">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L1263">					retval.tree = root_0;</span>
					}

					}
<span class="nc" id="L1267">					break;</span>
				case 2 :
					// AcslParser.g:114:7: LOOP FREES argumentExpressionList
					{
<span class="nc bnc" id="L1271" title="All 2 branches missed.">					LOOP23=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_allocation732); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LOOP.add(LOOP23);</span>

<span class="nc bnc" id="L1274" title="All 2 branches missed.">					FREES24=(Token)match(input,FREES,FOLLOW_FREES_in_loop_allocation734); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_FREES.add(FREES24);</span>

<span class="nc" id="L1277">					pushFollow(FOLLOW_argumentExpressionList_in_loop_allocation736);</span>
<span class="nc" id="L1278">					argumentExpressionList25=argumentExpressionList();</span>
<span class="nc" id="L1279">					state._fsp--;</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList25.getTree());</span>
					// AST REWRITE
					// elements: argumentExpressionList
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L1289" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1290">					retval.tree = root_0;</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1293">					root_0 = (Object)adaptor.nil();</span>
					// 115:9: -&gt; ^( LOOP_FREE argumentExpressionList )
					{
						// AcslParser.g:115:11: ^( LOOP_FREE argumentExpressionList )
						{
<span class="nc" id="L1298">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1299">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_FREE, &quot;LOOP_FREE&quot;), root_1);</span>
<span class="nc" id="L1300">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L1301">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L1307">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L1314">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1316" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1317">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1318">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1321">		catch (RecognitionException re) {</span>
<span class="nc" id="L1322">			reportError(re);</span>
<span class="nc" id="L1323">			recover(input,re);</span>
<span class="nc" id="L1324">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1326">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1328">		}</span>
<span class="nc" id="L1329">		return retval;</span>
	}
	// $ANTLR end &quot;loop_allocation&quot;


<span class="nc" id="L1334">	public static class loop_behavior_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1337">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_behavior&quot;
	// AcslParser.g:118:1: loop_behavior : FOR ilist= id_list COLON (lc+= loop_clause )* -&gt; ^( LOOP_BEHAVIOR $ilist ( $lc)* ) ;
	public final AcslParser.loop_behavior_return loop_behavior() throws RecognitionException {
<span class="nc" id="L1344">		AcslParser.loop_behavior_return retval = new AcslParser.loop_behavior_return();</span>
<span class="nc" id="L1345">		retval.start = input.LT(1);</span>

<span class="nc" id="L1347">		Object root_0 = null;</span>

<span class="nc" id="L1349">		Token FOR26=null;</span>
<span class="nc" id="L1350">		Token COLON27=null;</span>
<span class="nc" id="L1351">		List&lt;Object&gt; list_lc=null;</span>
<span class="nc" id="L1352">		ParserRuleReturnScope ilist =null;</span>
<span class="nc" id="L1353">		RuleReturnScope lc = null;</span>
<span class="nc" id="L1354">		Object FOR26_tree=null;</span>
<span class="nc" id="L1355">		Object COLON27_tree=null;</span>
<span class="nc" id="L1356">		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,&quot;token COLON&quot;);</span>
<span class="nc" id="L1357">		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,&quot;token FOR&quot;);</span>
<span class="nc" id="L1358">		RewriteRuleSubtreeStream stream_loop_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule loop_clause&quot;);</span>
<span class="nc" id="L1359">		RewriteRuleSubtreeStream stream_id_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule id_list&quot;);</span>

		try {
			// AcslParser.g:119:5: ( FOR ilist= id_list COLON (lc+= loop_clause )* -&gt; ^( LOOP_BEHAVIOR $ilist ( $lc)* ) )
			// AcslParser.g:119:7: FOR ilist= id_list COLON (lc+= loop_clause )*
			{
<span class="nc bnc" id="L1365" title="All 2 branches missed.">			FOR26=(Token)match(input,FOR,FOLLOW_FOR_in_loop_behavior768); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_FOR.add(FOR26);</span>

<span class="nc" id="L1368">			pushFollow(FOLLOW_id_list_in_loop_behavior772);</span>
<span class="nc" id="L1369">			ilist=id_list();</span>
<span class="nc" id="L1370">			state._fsp--;</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_id_list.add(ilist.getTree());</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">			COLON27=(Token)match(input,COLON,FOLLOW_COLON_in_loop_behavior774); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_COLON.add(COLON27);</span>

			// AcslParser.g:119:33: (lc+= loop_clause )*
			loop8:
			while (true) {
<span class="nc" id="L1379">				int alt8=2;</span>
<span class="nc" id="L1380">				int LA8_0 = input.LA(1);</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">				if ( (LA8_0==LOOP) ) {</span>
<span class="nc" id="L1382">					int LA8_1 = input.LA(2);</span>
<span class="nc bnc" id="L1383" title="All 8 branches missed.">					if ( (LA8_1==ALLOC||LA8_1==ASSIGNS||LA8_1==FREES||LA8_1==INVARIANT) ) {</span>
<span class="nc" id="L1384">						alt8=1;</span>
					}

				}

<span class="nc bnc" id="L1389" title="All 2 branches missed.">				switch (alt8) {</span>
				case 1 :
					// AcslParser.g:119:33: lc+= loop_clause
					{
<span class="nc" id="L1393">					pushFollow(FOLLOW_loop_clause_in_loop_behavior778);</span>
<span class="nc" id="L1394">					lc=loop_clause();</span>
<span class="nc" id="L1395">					state._fsp--;</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_loop_clause.add(lc.getTree());</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">					if (list_lc==null) list_lc=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1399">					list_lc.add(lc.getTree());</span>
					}
<span class="nc" id="L1401">					break;</span>

				default :
<span class="nc" id="L1404">					break loop8;</span>
				}
<span class="nc" id="L1406">			}</span>

			// AST REWRITE
			// elements: lc, ilist
			// token labels: 
			// rule labels: retval, ilist
			// token list labels: 
			// rule list labels: lc
			// wildcard labels: 
<span class="nc bnc" id="L1415" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1416">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_ilist=new RewriteRuleSubtreeStream(adaptor,&quot;rule ilist&quot;,ilist!=null?ilist.getTree():null);</span>
<span class="nc" id="L1419">			RewriteRuleSubtreeStream stream_lc=new RewriteRuleSubtreeStream(adaptor,&quot;token lc&quot;,list_lc);</span>
<span class="nc" id="L1420">			root_0 = (Object)adaptor.nil();</span>
			// 120:9: -&gt; ^( LOOP_BEHAVIOR $ilist ( $lc)* )
			{
				// AcslParser.g:120:11: ^( LOOP_BEHAVIOR $ilist ( $lc)* )
				{
<span class="nc" id="L1425">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1426">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_BEHAVIOR, &quot;LOOP_BEHAVIOR&quot;), root_1);</span>
<span class="nc" id="L1427">				adaptor.addChild(root_1, stream_ilist.nextTree());</span>
				// AcslParser.g:120:35: ( $lc)*
<span class="nc bnc" id="L1429" title="All 2 branches missed.">				while ( stream_lc.hasNext() ) {</span>
<span class="nc" id="L1430">					adaptor.addChild(root_1, stream_lc.nextTree());</span>
				}
<span class="nc" id="L1432">				stream_lc.reset();</span>

<span class="nc" id="L1434">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1440">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L1445">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1447" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1448">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1449">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1452">		catch (RecognitionException re) {</span>
<span class="nc" id="L1453">			reportError(re);</span>
<span class="nc" id="L1454">			recover(input,re);</span>
<span class="nc" id="L1455">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1457">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1459">		}</span>
<span class="nc" id="L1460">		return retval;</span>
	}
	// $ANTLR end &quot;loop_behavior&quot;


<span class="nc" id="L1465">	public static class loop_variant_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1468">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;loop_variant&quot;
	// AcslParser.g:123:1: loop_variant : ( LOOP VARIANT term -&gt; ^( LOOP_VARIANT term ) | LOOP VARIANT term FOR ID -&gt; ^( LOOP_VARIANT term ID ) );
	public final AcslParser.loop_variant_return loop_variant() throws RecognitionException {
<span class="nc" id="L1475">		AcslParser.loop_variant_return retval = new AcslParser.loop_variant_return();</span>
<span class="nc" id="L1476">		retval.start = input.LT(1);</span>

<span class="nc" id="L1478">		Object root_0 = null;</span>

<span class="nc" id="L1480">		Token LOOP28=null;</span>
<span class="nc" id="L1481">		Token VARIANT29=null;</span>
<span class="nc" id="L1482">		Token LOOP31=null;</span>
<span class="nc" id="L1483">		Token VARIANT32=null;</span>
<span class="nc" id="L1484">		Token FOR34=null;</span>
<span class="nc" id="L1485">		Token ID35=null;</span>
<span class="nc" id="L1486">		ParserRuleReturnScope term30 =null;</span>
<span class="nc" id="L1487">		ParserRuleReturnScope term33 =null;</span>

<span class="nc" id="L1489">		Object LOOP28_tree=null;</span>
<span class="nc" id="L1490">		Object VARIANT29_tree=null;</span>
<span class="nc" id="L1491">		Object LOOP31_tree=null;</span>
<span class="nc" id="L1492">		Object VARIANT32_tree=null;</span>
<span class="nc" id="L1493">		Object FOR34_tree=null;</span>
<span class="nc" id="L1494">		Object ID35_tree=null;</span>
<span class="nc" id="L1495">		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,&quot;token FOR&quot;);</span>
<span class="nc" id="L1496">		RewriteRuleTokenStream stream_VARIANT=new RewriteRuleTokenStream(adaptor,&quot;token VARIANT&quot;);</span>
<span class="nc" id="L1497">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L1498">		RewriteRuleTokenStream stream_LOOP=new RewriteRuleTokenStream(adaptor,&quot;token LOOP&quot;);</span>
<span class="nc" id="L1499">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:124:5: ( LOOP VARIANT term -&gt; ^( LOOP_VARIANT term ) | LOOP VARIANT term FOR ID -&gt; ^( LOOP_VARIANT term ID ) )
<span class="nc" id="L1503">			int alt9=2;</span>
<span class="nc" id="L1504">			int LA9_0 = input.LA(1);</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">			if ( (LA9_0==LOOP) ) {</span>
<span class="nc" id="L1506">				int LA9_1 = input.LA(2);</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">				if ( (synpred10_AcslParser()) ) {</span>
<span class="nc" id="L1508">					alt9=1;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L1511">					alt9=2;</span>
				}

<span class="nc" id="L1514">			}</span>

			else {
<span class="nc bnc" id="L1517" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L1518">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 9, 0, input);
<span class="nc" id="L1520">				throw nvae;</span>
			}

<span class="nc bnc" id="L1523" title="All 3 branches missed.">			switch (alt9) {</span>
				case 1 :
					// AcslParser.g:124:7: LOOP VARIANT term
					{
<span class="nc bnc" id="L1527" title="All 2 branches missed.">					LOOP28=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_variant816); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LOOP.add(LOOP28);</span>

<span class="nc bnc" id="L1530" title="All 2 branches missed.">					VARIANT29=(Token)match(input,VARIANT,FOLLOW_VARIANT_in_loop_variant818); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_VARIANT.add(VARIANT29);</span>

<span class="nc" id="L1533">					pushFollow(FOLLOW_term_in_loop_variant820);</span>
<span class="nc" id="L1534">					term30=term();</span>
<span class="nc" id="L1535">					state._fsp--;</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term30.getTree());</span>
					// AST REWRITE
					// elements: term
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L1545" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1546">					retval.tree = root_0;</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1549">					root_0 = (Object)adaptor.nil();</span>
					// 125:9: -&gt; ^( LOOP_VARIANT term )
					{
						// AcslParser.g:125:11: ^( LOOP_VARIANT term )
						{
<span class="nc" id="L1554">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1555">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_VARIANT, &quot;LOOP_VARIANT&quot;), root_1);</span>
<span class="nc" id="L1556">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L1557">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L1563">					retval.tree = root_0;</span>
<span class="nc" id="L1564">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:126:7: LOOP VARIANT term FOR ID
					{
<span class="nc bnc" id="L1571" title="All 2 branches missed.">					LOOP31=(Token)match(input,LOOP,FOLLOW_LOOP_in_loop_variant843); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LOOP.add(LOOP31);</span>

<span class="nc bnc" id="L1574" title="All 2 branches missed.">					VARIANT32=(Token)match(input,VARIANT,FOLLOW_VARIANT_in_loop_variant845); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_VARIANT.add(VARIANT32);</span>

<span class="nc" id="L1577">					pushFollow(FOLLOW_term_in_loop_variant847);</span>
<span class="nc" id="L1578">					term33=term();</span>
<span class="nc" id="L1579">					state._fsp--;</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term33.getTree());</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">					FOR34=(Token)match(input,FOR,FOLLOW_FOR_in_loop_variant849); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_FOR.add(FOR34);</span>

<span class="nc bnc" id="L1585" title="All 2 branches missed.">					ID35=(Token)match(input,ID,FOLLOW_ID_in_loop_variant851); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID35);</span>

					// AST REWRITE
					// elements: term, ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L1595" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1596">					retval.tree = root_0;</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1599">					root_0 = (Object)adaptor.nil();</span>
					// 127:9: -&gt; ^( LOOP_VARIANT term ID )
					{
						// AcslParser.g:127:11: ^( LOOP_VARIANT term ID )
						{
<span class="nc" id="L1604">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1605">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOOP_VARIANT, &quot;LOOP_VARIANT&quot;), root_1);</span>
<span class="nc" id="L1606">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L1607">						adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L1608">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L1614">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L1621">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1623" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1624">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1625">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1628">		catch (RecognitionException re) {</span>
<span class="nc" id="L1629">			reportError(re);</span>
<span class="nc" id="L1630">			recover(input,re);</span>
<span class="nc" id="L1631">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1633">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1635">		}</span>
<span class="nc" id="L1636">		return retval;</span>
	}
	// $ANTLR end &quot;loop_variant&quot;


<span class="nc" id="L1641">	public static class function_contract_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1644">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;function_contract&quot;
	// AcslParser.g:131:1: function_contract : LCOMMENT ( pure_function )? full_contract_block RCOMMENT -&gt; ^( FUNC_CONTRACT full_contract_block ( pure_function )? ) ;
	public final AcslParser.function_contract_return function_contract() throws RecognitionException {
<span class="nc" id="L1651">		AcslParser.function_contract_return retval = new AcslParser.function_contract_return();</span>
<span class="nc" id="L1652">		retval.start = input.LT(1);</span>

<span class="nc" id="L1654">		Object root_0 = null;</span>

<span class="nc" id="L1656">		Token LCOMMENT36=null;</span>
<span class="nc" id="L1657">		Token RCOMMENT39=null;</span>
<span class="nc" id="L1658">		ParserRuleReturnScope pure_function37 =null;</span>
<span class="nc" id="L1659">		ParserRuleReturnScope full_contract_block38 =null;</span>

<span class="nc" id="L1661">		Object LCOMMENT36_tree=null;</span>
<span class="nc" id="L1662">		Object RCOMMENT39_tree=null;</span>
<span class="nc" id="L1663">		RewriteRuleTokenStream stream_LCOMMENT=new RewriteRuleTokenStream(adaptor,&quot;token LCOMMENT&quot;);</span>
<span class="nc" id="L1664">		RewriteRuleTokenStream stream_RCOMMENT=new RewriteRuleTokenStream(adaptor,&quot;token RCOMMENT&quot;);</span>
<span class="nc" id="L1665">		RewriteRuleSubtreeStream stream_pure_function=new RewriteRuleSubtreeStream(adaptor,&quot;rule pure_function&quot;);</span>
<span class="nc" id="L1666">		RewriteRuleSubtreeStream stream_full_contract_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule full_contract_block&quot;);</span>

		try {
			// AcslParser.g:132:5: ( LCOMMENT ( pure_function )? full_contract_block RCOMMENT -&gt; ^( FUNC_CONTRACT full_contract_block ( pure_function )? ) )
			// AcslParser.g:132:7: LCOMMENT ( pure_function )? full_contract_block RCOMMENT
			{
<span class="nc bnc" id="L1672" title="All 2 branches missed.">			LCOMMENT36=(Token)match(input,LCOMMENT,FOLLOW_LCOMMENT_in_function_contract887); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_LCOMMENT.add(LCOMMENT36);</span>

			// AcslParser.g:132:16: ( pure_function )?
<span class="nc" id="L1676">			int alt10=2;</span>
<span class="nc" id="L1677">			int LA10_0 = input.LA(1);</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">			if ( (LA10_0==PURE) ) {</span>
<span class="nc" id="L1679">				alt10=1;</span>
			}
<span class="nc bnc" id="L1681" title="All 2 branches missed.">			switch (alt10) {</span>
				case 1 :
					// AcslParser.g:132:16: pure_function
					{
<span class="nc" id="L1685">					pushFollow(FOLLOW_pure_function_in_function_contract889);</span>
<span class="nc" id="L1686">					pure_function37=pure_function();</span>
<span class="nc" id="L1687">					state._fsp--;</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_pure_function.add(pure_function37.getTree());</span>
					}
					break;

			}

<span class="nc" id="L1695">			pushFollow(FOLLOW_full_contract_block_in_function_contract892);</span>
<span class="nc" id="L1696">			full_contract_block38=full_contract_block();</span>
<span class="nc" id="L1697">			state._fsp--;</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_full_contract_block.add(full_contract_block38.getTree());</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">			RCOMMENT39=(Token)match(input,RCOMMENT,FOLLOW_RCOMMENT_in_function_contract894); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_RCOMMENT.add(RCOMMENT39);</span>

			// AST REWRITE
			// elements: pure_function, full_contract_block
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L1710" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1711">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1714">			root_0 = (Object)adaptor.nil();</span>
			// 133:7: -&gt; ^( FUNC_CONTRACT full_contract_block ( pure_function )? )
			{
				// AcslParser.g:133:10: ^( FUNC_CONTRACT full_contract_block ( pure_function )? )
				{
<span class="nc" id="L1719">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1720">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNC_CONTRACT, &quot;FUNC_CONTRACT&quot;), root_1);</span>
<span class="nc" id="L1721">				adaptor.addChild(root_1, stream_full_contract_block.nextTree());</span>
				// AcslParser.g:133:46: ( pure_function )?
<span class="nc bnc" id="L1723" title="All 2 branches missed.">				if ( stream_pure_function.hasNext() ) {</span>
<span class="nc" id="L1724">					adaptor.addChild(root_1, stream_pure_function.nextTree());</span>
				}
<span class="nc" id="L1726">				stream_pure_function.reset();</span>

<span class="nc" id="L1728">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1734">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L1739">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1741" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1742">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1743">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1746">		catch (RecognitionException re) {</span>
<span class="nc" id="L1747">			reportError(re);</span>
<span class="nc" id="L1748">			recover(input,re);</span>
<span class="nc" id="L1749">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1751">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1753">		}</span>
<span class="nc" id="L1754">		return retval;</span>
	}
	// $ANTLR end &quot;function_contract&quot;


<span class="nc" id="L1759">	public static class pure_function_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1762">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;pure_function&quot;
	// AcslParser.g:136:1: pure_function : PURE SEMICOL -&gt; ^( PURE ) ;
	public final AcslParser.pure_function_return pure_function() throws RecognitionException {
<span class="nc" id="L1769">		AcslParser.pure_function_return retval = new AcslParser.pure_function_return();</span>
<span class="nc" id="L1770">		retval.start = input.LT(1);</span>

<span class="nc" id="L1772">		Object root_0 = null;</span>

<span class="nc" id="L1774">		Token PURE40=null;</span>
<span class="nc" id="L1775">		Token SEMICOL41=null;</span>

<span class="nc" id="L1777">		Object PURE40_tree=null;</span>
<span class="nc" id="L1778">		Object SEMICOL41_tree=null;</span>
<span class="nc" id="L1779">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L1780">		RewriteRuleTokenStream stream_PURE=new RewriteRuleTokenStream(adaptor,&quot;token PURE&quot;);</span>

		try {
			// AcslParser.g:137:5: ( PURE SEMICOL -&gt; ^( PURE ) )
			// AcslParser.g:137:7: PURE SEMICOL
			{
<span class="nc bnc" id="L1786" title="All 2 branches missed.">			PURE40=(Token)match(input,PURE,FOLLOW_PURE_in_pure_function928); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_PURE.add(PURE40);</span>

<span class="nc bnc" id="L1789" title="All 2 branches missed.">			SEMICOL41=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_pure_function930); if (state.failed) return retval; </span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL41);</span>

			// AST REWRITE
			// elements: PURE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L1799" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1800">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1803">			root_0 = (Object)adaptor.nil();</span>
			// 138:7: -&gt; ^( PURE )
			{
				// AcslParser.g:138:9: ^( PURE )
				{
<span class="nc" id="L1808">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1809">				root_1 = (Object)adaptor.becomeRoot(stream_PURE.nextNode(), root_1);</span>
<span class="nc" id="L1810">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1816">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L1821">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L1823" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1824">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1825">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L1828">		catch (RecognitionException re) {</span>
<span class="nc" id="L1829">			reportError(re);</span>
<span class="nc" id="L1830">			recover(input,re);</span>
<span class="nc" id="L1831">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1833">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1835">		}</span>
<span class="nc" id="L1836">		return retval;</span>
	}
	// $ANTLR end &quot;pure_function&quot;


<span class="nc" id="L1841">	public static class full_contract_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1844">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;full_contract_block&quot;
	// AcslParser.g:143:1: full_contract_block : (f+= function_clause )* (m+= contract_block )* (c+= completeness_clause_block )* -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $m)* ( $c)* ) ;
	public final AcslParser.full_contract_block_return full_contract_block() throws RecognitionException {
<span class="nc" id="L1851">		AcslParser.full_contract_block_return retval = new AcslParser.full_contract_block_return();</span>
<span class="nc" id="L1852">		retval.start = input.LT(1);</span>

<span class="nc" id="L1854">		Object root_0 = null;</span>

<span class="nc" id="L1856">		List&lt;Object&gt; list_f=null;</span>
<span class="nc" id="L1857">		List&lt;Object&gt; list_m=null;</span>
<span class="nc" id="L1858">		List&lt;Object&gt; list_c=null;</span>
<span class="nc" id="L1859">		RuleReturnScope f = null;</span>
<span class="nc" id="L1860">		RuleReturnScope m = null;</span>
<span class="nc" id="L1861">		RuleReturnScope c = null;</span>
<span class="nc" id="L1862">		RewriteRuleSubtreeStream stream_completeness_clause_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule completeness_clause_block&quot;);</span>
<span class="nc" id="L1863">		RewriteRuleSubtreeStream stream_function_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule function_clause&quot;);</span>
<span class="nc" id="L1864">		RewriteRuleSubtreeStream stream_contract_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule contract_block&quot;);</span>

		try {
			// AcslParser.g:144:5: ( (f+= function_clause )* (m+= contract_block )* (c+= completeness_clause_block )* -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $m)* ( $c)* ) )
			// AcslParser.g:144:7: (f+= function_clause )* (m+= contract_block )* (c+= completeness_clause_block )*
			{
			// AcslParser.g:144:7: (f+= function_clause )*
			loop11:
			while (true) {
<span class="nc" id="L1873">				int alt11=2;</span>
<span class="nc" id="L1874">				int LA11_0 = input.LA(1);</span>
<span class="nc bnc" id="L1875" title="All 18 branches missed.">				if ( (LA11_0==ALLOC||LA11_0==ASSIGNS||LA11_0==DEPENDS||LA11_0==ENSURES||LA11_0==FREES||LA11_0==GUARDS||LA11_0==READS||LA11_0==REQUIRES||LA11_0==TEMINATES) ) {</span>
<span class="nc" id="L1876">					alt11=1;</span>
				}

<span class="nc bnc" id="L1879" title="All 2 branches missed.">				switch (alt11) {</span>
				case 1 :
					// AcslParser.g:144:8: f+= function_clause
					{
<span class="nc" id="L1883">					pushFollow(FOLLOW_function_clause_in_full_contract_block963);</span>
<span class="nc" id="L1884">					f=function_clause();</span>
<span class="nc" id="L1885">					state._fsp--;</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_function_clause.add(f.getTree());</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">					if (list_f==null) list_f=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1889">					list_f.add(f.getTree());</span>
					}
<span class="nc" id="L1891">					break;</span>

				default :
<span class="nc" id="L1894">					break loop11;</span>
				}
<span class="nc" id="L1896">			}</span>

			// AcslParser.g:144:29: (m+= contract_block )*
			loop12:
			while (true) {
<span class="nc" id="L1901">				int alt12=2;</span>
<span class="nc" id="L1902">				int LA12_0 = input.LA(1);</span>
<span class="nc bnc" id="L1903" title="All 4 branches missed.">				if ( (LA12_0==BEHAVIOR||LA12_0==MPI_COLLECTIVE) ) {</span>
<span class="nc" id="L1904">					alt12=1;</span>
				}

<span class="nc bnc" id="L1907" title="All 2 branches missed.">				switch (alt12) {</span>
				case 1 :
					// AcslParser.g:144:30: m+= contract_block
					{
<span class="nc" id="L1911">					pushFollow(FOLLOW_contract_block_in_full_contract_block970);</span>
<span class="nc" id="L1912">					m=contract_block();</span>
<span class="nc" id="L1913">					state._fsp--;</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_contract_block.add(m.getTree());</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">					if (list_m==null) list_m=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1917">					list_m.add(m.getTree());</span>
					}
<span class="nc" id="L1919">					break;</span>

				default :
<span class="nc" id="L1922">					break loop12;</span>
				}
<span class="nc" id="L1924">			}</span>

			// AcslParser.g:145:9: (c+= completeness_clause_block )*
			loop13:
			while (true) {
<span class="nc" id="L1929">				int alt13=2;</span>
<span class="nc" id="L1930">				int LA13_0 = input.LA(1);</span>
<span class="nc bnc" id="L1931" title="All 4 branches missed.">				if ( (LA13_0==COMPLETE||LA13_0==DISJOINT) ) {</span>
<span class="nc" id="L1932">					alt13=1;</span>
				}

<span class="nc bnc" id="L1935" title="All 2 branches missed.">				switch (alt13) {</span>
				case 1 :
					// AcslParser.g:145:10: c+= completeness_clause_block
					{
<span class="nc" id="L1939">					pushFollow(FOLLOW_completeness_clause_block_in_full_contract_block985);</span>
<span class="nc" id="L1940">					c=completeness_clause_block();</span>
<span class="nc" id="L1941">					state._fsp--;</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_completeness_clause_block.add(c.getTree());</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">					if (list_c==null) list_c=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1945">					list_c.add(c.getTree());</span>
					}
<span class="nc" id="L1947">					break;</span>

				default :
<span class="nc" id="L1950">					break loop13;</span>
				}
<span class="nc" id="L1952">			}</span>

			// AST REWRITE
			// elements: m, c, f
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: f, c, m
			// wildcard labels: 
<span class="nc bnc" id="L1961" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L1962">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L1964">			RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,&quot;token f&quot;,list_f);</span>
<span class="nc" id="L1965">			RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;token c&quot;,list_c);</span>
<span class="nc" id="L1966">			RewriteRuleSubtreeStream stream_m=new RewriteRuleSubtreeStream(adaptor,&quot;token m&quot;,list_m);</span>
<span class="nc" id="L1967">			root_0 = (Object)adaptor.nil();</span>
			// 146:9: -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $m)* ( $c)* )
			{
				// AcslParser.g:146:12: ^( FUNC_CONTRACT_BLOCK ( $f)* ( $m)* ( $c)* )
				{
<span class="nc" id="L1972">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1973">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNC_CONTRACT_BLOCK, &quot;FUNC_CONTRACT_BLOCK&quot;), root_1);</span>
				// AcslParser.g:146:35: ( $f)*
<span class="nc bnc" id="L1975" title="All 2 branches missed.">				while ( stream_f.hasNext() ) {</span>
<span class="nc" id="L1976">					adaptor.addChild(root_1, stream_f.nextTree());</span>
				}
<span class="nc" id="L1978">				stream_f.reset();</span>

				// AcslParser.g:146:39: ( $m)*
<span class="nc bnc" id="L1981" title="All 2 branches missed.">				while ( stream_m.hasNext() ) {</span>
<span class="nc" id="L1982">					adaptor.addChild(root_1, stream_m.nextTree());</span>
				}
<span class="nc" id="L1984">				stream_m.reset();</span>

				// AcslParser.g:146:43: ( $c)*
<span class="nc bnc" id="L1987" title="All 2 branches missed.">				while ( stream_c.hasNext() ) {</span>
<span class="nc" id="L1988">					adaptor.addChild(root_1, stream_c.nextTree());</span>
				}
<span class="nc" id="L1990">				stream_c.reset();</span>

<span class="nc" id="L1992">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1998">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2003">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2005" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2006">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2007">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2010">		catch (RecognitionException re) {</span>
<span class="nc" id="L2011">			reportError(re);</span>
<span class="nc" id="L2012">			recover(input,re);</span>
<span class="nc" id="L2013">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2015">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2017">		}</span>
<span class="nc" id="L2018">		return retval;</span>
	}
	// $ANTLR end &quot;full_contract_block&quot;


<span class="nc" id="L2023">	public static class partial_contract_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2026">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;partial_contract_block&quot;
	// AcslParser.g:152:1: partial_contract_block : (f+= function_clause )* (b+= named_behavior_block )* (c+= completeness_clause_block )* -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $b)* ( $c)* ) ;
	public final AcslParser.partial_contract_block_return partial_contract_block() throws RecognitionException {
<span class="nc" id="L2033">		AcslParser.partial_contract_block_return retval = new AcslParser.partial_contract_block_return();</span>
<span class="nc" id="L2034">		retval.start = input.LT(1);</span>

<span class="nc" id="L2036">		Object root_0 = null;</span>

<span class="nc" id="L2038">		List&lt;Object&gt; list_f=null;</span>
<span class="nc" id="L2039">		List&lt;Object&gt; list_b=null;</span>
<span class="nc" id="L2040">		List&lt;Object&gt; list_c=null;</span>
<span class="nc" id="L2041">		RuleReturnScope f = null;</span>
<span class="nc" id="L2042">		RuleReturnScope b = null;</span>
<span class="nc" id="L2043">		RuleReturnScope c = null;</span>
<span class="nc" id="L2044">		RewriteRuleSubtreeStream stream_completeness_clause_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule completeness_clause_block&quot;);</span>
<span class="nc" id="L2045">		RewriteRuleSubtreeStream stream_function_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule function_clause&quot;);</span>
<span class="nc" id="L2046">		RewriteRuleSubtreeStream stream_named_behavior_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule named_behavior_block&quot;);</span>

		try {
			// AcslParser.g:153:5: ( (f+= function_clause )* (b+= named_behavior_block )* (c+= completeness_clause_block )* -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $b)* ( $c)* ) )
			// AcslParser.g:153:7: (f+= function_clause )* (b+= named_behavior_block )* (c+= completeness_clause_block )*
			{
			// AcslParser.g:153:7: (f+= function_clause )*
			loop14:
			while (true) {
<span class="nc" id="L2055">				int alt14=2;</span>
<span class="nc" id="L2056">				int LA14_0 = input.LA(1);</span>
<span class="nc bnc" id="L2057" title="All 18 branches missed.">				if ( (LA14_0==ALLOC||LA14_0==ASSIGNS||LA14_0==DEPENDS||LA14_0==ENSURES||LA14_0==FREES||LA14_0==GUARDS||LA14_0==READS||LA14_0==REQUIRES||LA14_0==TEMINATES) ) {</span>
<span class="nc" id="L2058">					alt14=1;</span>
				}

<span class="nc bnc" id="L2061" title="All 2 branches missed.">				switch (alt14) {</span>
				case 1 :
					// AcslParser.g:153:8: f+= function_clause
					{
<span class="nc" id="L2065">					pushFollow(FOLLOW_function_clause_in_partial_contract_block1037);</span>
<span class="nc" id="L2066">					f=function_clause();</span>
<span class="nc" id="L2067">					state._fsp--;</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_function_clause.add(f.getTree());</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">					if (list_f==null) list_f=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2071">					list_f.add(f.getTree());</span>
					}
<span class="nc" id="L2073">					break;</span>

				default :
<span class="nc" id="L2076">					break loop14;</span>
				}
<span class="nc" id="L2078">			}</span>

			// AcslParser.g:153:29: (b+= named_behavior_block )*
			loop15:
			while (true) {
<span class="nc" id="L2083">				int alt15=2;</span>
<span class="nc" id="L2084">				int LA15_0 = input.LA(1);</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">				if ( (LA15_0==BEHAVIOR) ) {</span>
<span class="nc" id="L2086">					int LA15_5 = input.LA(2);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">					if ( (synpred16_AcslParser()) ) {</span>
<span class="nc" id="L2088">						alt15=1;</span>
					}

				}

<span class="nc bnc" id="L2093" title="All 2 branches missed.">				switch (alt15) {</span>
				case 1 :
					// AcslParser.g:153:30: b+= named_behavior_block
					{
<span class="nc" id="L2097">					pushFollow(FOLLOW_named_behavior_block_in_partial_contract_block1044);</span>
<span class="nc" id="L2098">					b=named_behavior_block();</span>
<span class="nc" id="L2099">					state._fsp--;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2101" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_named_behavior_block.add(b.getTree());</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">					if (list_b==null) list_b=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2103">					list_b.add(b.getTree());</span>
					}
<span class="nc" id="L2105">					break;</span>

				default :
<span class="nc" id="L2108">					break loop15;</span>
				}
<span class="nc" id="L2110">			}</span>

			// AcslParser.g:154:9: (c+= completeness_clause_block )*
			loop16:
			while (true) {
<span class="nc" id="L2115">				int alt16=2;</span>
<span class="nc" id="L2116">				alt16 = dfa16.predict(input);</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">				switch (alt16) {</span>
				case 1 :
					// AcslParser.g:154:10: c+= completeness_clause_block
					{
<span class="nc" id="L2121">					pushFollow(FOLLOW_completeness_clause_block_in_partial_contract_block1060);</span>
<span class="nc" id="L2122">					c=completeness_clause_block();</span>
<span class="nc" id="L2123">					state._fsp--;</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_completeness_clause_block.add(c.getTree());</span>
<span class="nc bnc" id="L2126" title="All 2 branches missed.">					if (list_c==null) list_c=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2127">					list_c.add(c.getTree());</span>
					}
<span class="nc" id="L2129">					break;</span>

				default :
<span class="nc" id="L2132">					break loop16;</span>
				}
<span class="nc" id="L2134">			}</span>

			// AST REWRITE
			// elements: f, c, b
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: f, b, c
			// wildcard labels: 
<span class="nc bnc" id="L2143" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2144">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L2146">			RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,&quot;token f&quot;,list_f);</span>
<span class="nc" id="L2147">			RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,&quot;token b&quot;,list_b);</span>
<span class="nc" id="L2148">			RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;token c&quot;,list_c);</span>
<span class="nc" id="L2149">			root_0 = (Object)adaptor.nil();</span>
			// 155:9: -&gt; ^( FUNC_CONTRACT_BLOCK ( $f)* ( $b)* ( $c)* )
			{
				// AcslParser.g:155:12: ^( FUNC_CONTRACT_BLOCK ( $f)* ( $b)* ( $c)* )
				{
<span class="nc" id="L2154">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2155">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNC_CONTRACT_BLOCK, &quot;FUNC_CONTRACT_BLOCK&quot;), root_1);</span>
				// AcslParser.g:155:35: ( $f)*
<span class="nc bnc" id="L2157" title="All 2 branches missed.">				while ( stream_f.hasNext() ) {</span>
<span class="nc" id="L2158">					adaptor.addChild(root_1, stream_f.nextTree());</span>
				}
<span class="nc" id="L2160">				stream_f.reset();</span>

				// AcslParser.g:155:39: ( $b)*
<span class="nc bnc" id="L2163" title="All 2 branches missed.">				while ( stream_b.hasNext() ) {</span>
<span class="nc" id="L2164">					adaptor.addChild(root_1, stream_b.nextTree());</span>
				}
<span class="nc" id="L2166">				stream_b.reset();</span>

				// AcslParser.g:155:43: ( $c)*
<span class="nc bnc" id="L2169" title="All 2 branches missed.">				while ( stream_c.hasNext() ) {</span>
<span class="nc" id="L2170">					adaptor.addChild(root_1, stream_c.nextTree());</span>
				}
<span class="nc" id="L2172">				stream_c.reset();</span>

<span class="nc" id="L2174">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2180">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2185">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2187" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2188">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2189">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2192">		catch (RecognitionException re) {</span>
<span class="nc" id="L2193">			reportError(re);</span>
<span class="nc" id="L2194">			recover(input,re);</span>
<span class="nc" id="L2195">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2197">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2199">		}</span>
<span class="nc" id="L2200">		return retval;</span>
	}
	// $ANTLR end &quot;partial_contract_block&quot;


<span class="nc" id="L2205">	public static class contract_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2208">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;contract_block&quot;
	// AcslParser.g:163:1: contract_block : ( mpi_collective_block | named_behavior_block ( completeness_clause_block )? );
	public final AcslParser.contract_block_return contract_block() throws RecognitionException {
<span class="nc" id="L2215">		AcslParser.contract_block_return retval = new AcslParser.contract_block_return();</span>
<span class="nc" id="L2216">		retval.start = input.LT(1);</span>

<span class="nc" id="L2218">		Object root_0 = null;</span>

<span class="nc" id="L2220">		ParserRuleReturnScope mpi_collective_block42 =null;</span>
<span class="nc" id="L2221">		ParserRuleReturnScope named_behavior_block43 =null;</span>
<span class="nc" id="L2222">		ParserRuleReturnScope completeness_clause_block44 =null;</span>


		try {
			// AcslParser.g:164:5: ( mpi_collective_block | named_behavior_block ( completeness_clause_block )? )
<span class="nc" id="L2227">			int alt18=2;</span>
<span class="nc" id="L2228">			int LA18_0 = input.LA(1);</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">			if ( (LA18_0==MPI_COLLECTIVE) ) {</span>
<span class="nc" id="L2230">				alt18=1;</span>
			}
<span class="nc bnc" id="L2232" title="All 2 branches missed.">			else if ( (LA18_0==BEHAVIOR) ) {</span>
<span class="nc" id="L2233">				alt18=2;</span>
			}

			else {
<span class="nc bnc" id="L2237" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L2238">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 18, 0, input);
<span class="nc" id="L2240">				throw nvae;</span>
			}

<span class="nc bnc" id="L2243" title="All 3 branches missed.">			switch (alt18) {</span>
				case 1 :
					// AcslParser.g:164:7: mpi_collective_block
					{
<span class="nc" id="L2247">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2250">					pushFollow(FOLLOW_mpi_collective_block_in_contract_block1109);</span>
<span class="nc" id="L2251">					mpi_collective_block42=mpi_collective_block();</span>
<span class="nc" id="L2252">					state._fsp--;</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, mpi_collective_block42.getTree());</span>

					}
					break;
				case 2 :
					// AcslParser.g:165:7: named_behavior_block ( completeness_clause_block )?
					{
<span class="nc" id="L2261">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2264">					pushFollow(FOLLOW_named_behavior_block_in_contract_block1117);</span>
<span class="nc" id="L2265">					named_behavior_block43=named_behavior_block();</span>
<span class="nc" id="L2266">					state._fsp--;</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, named_behavior_block43.getTree());</span>

					// AcslParser.g:165:28: ( completeness_clause_block )?
<span class="nc" id="L2271">					int alt17=2;</span>
<span class="nc" id="L2272">					alt17 = dfa17.predict(input);</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">					switch (alt17) {</span>
						case 1 :
							// AcslParser.g:165:28: completeness_clause_block
							{
<span class="nc" id="L2277">							pushFollow(FOLLOW_completeness_clause_block_in_contract_block1119);</span>
<span class="nc" id="L2278">							completeness_clause_block44=completeness_clause_block();</span>
<span class="nc" id="L2279">							state._fsp--;</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">							if ( state.backtracking==0 ) adaptor.addChild(root_0, completeness_clause_block44.getTree());</span>

							}
							break;

					}

					}
					break;

			}
<span class="nc" id="L2292">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2294" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2295">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2296">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2299">		catch (RecognitionException re) {</span>
<span class="nc" id="L2300">			reportError(re);</span>
<span class="nc" id="L2301">			recover(input,re);</span>
<span class="nc" id="L2302">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2304">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2306">		}</span>
<span class="nc" id="L2307">		return retval;</span>
	}
	// $ANTLR end &quot;contract_block&quot;


<span class="nc" id="L2312">	public static class function_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2315">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;function_clause&quot;
	// AcslParser.g:168:1: function_clause : ( requires_clause SEMICOL -&gt; ^( CLAUSE_NORMAL requires_clause ) | terminates_clause SEMICOL -&gt; ^( CLAUSE_NORMAL terminates_clause ) | simple_clause SEMICOL -&gt; ^( CLAUSE_NORMAL simple_clause ) );
	public final AcslParser.function_clause_return function_clause() throws RecognitionException {
<span class="nc" id="L2322">		AcslParser.function_clause_return retval = new AcslParser.function_clause_return();</span>
<span class="nc" id="L2323">		retval.start = input.LT(1);</span>

<span class="nc" id="L2325">		Object root_0 = null;</span>

<span class="nc" id="L2327">		Token SEMICOL46=null;</span>
<span class="nc" id="L2328">		Token SEMICOL48=null;</span>
<span class="nc" id="L2329">		Token SEMICOL50=null;</span>
<span class="nc" id="L2330">		ParserRuleReturnScope requires_clause45 =null;</span>
<span class="nc" id="L2331">		ParserRuleReturnScope terminates_clause47 =null;</span>
<span class="nc" id="L2332">		ParserRuleReturnScope simple_clause49 =null;</span>

<span class="nc" id="L2334">		Object SEMICOL46_tree=null;</span>
<span class="nc" id="L2335">		Object SEMICOL48_tree=null;</span>
<span class="nc" id="L2336">		Object SEMICOL50_tree=null;</span>
<span class="nc" id="L2337">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L2338">		RewriteRuleSubtreeStream stream_terminates_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule terminates_clause&quot;);</span>
<span class="nc" id="L2339">		RewriteRuleSubtreeStream stream_simple_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule simple_clause&quot;);</span>
<span class="nc" id="L2340">		RewriteRuleSubtreeStream stream_requires_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule requires_clause&quot;);</span>

		try {
			// AcslParser.g:169:5: ( requires_clause SEMICOL -&gt; ^( CLAUSE_NORMAL requires_clause ) | terminates_clause SEMICOL -&gt; ^( CLAUSE_NORMAL terminates_clause ) | simple_clause SEMICOL -&gt; ^( CLAUSE_NORMAL simple_clause ) )
<span class="nc" id="L2344">			int alt19=3;</span>
<span class="nc bnc" id="L2345" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case REQUIRES:
				{
<span class="nc" id="L2348">				alt19=1;</span>
				}
<span class="nc" id="L2350">				break;</span>
			case TEMINATES:
				{
<span class="nc" id="L2353">				alt19=2;</span>
				}
<span class="nc" id="L2355">				break;</span>
			case ALLOC:
			case ASSIGNS:
			case DEPENDS:
			case ENSURES:
			case FREES:
			case GUARDS:
			case READS:
				{
<span class="nc" id="L2364">				alt19=3;</span>
				}
<span class="nc" id="L2366">				break;</span>
			default:
<span class="nc bnc" id="L2368" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L2369">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 19, 0, input);
<span class="nc" id="L2371">				throw nvae;</span>
			}
<span class="nc bnc" id="L2373" title="All 4 branches missed.">			switch (alt19) {</span>
				case 1 :
					// AcslParser.g:169:7: requires_clause SEMICOL
					{
<span class="nc" id="L2377">					pushFollow(FOLLOW_requires_clause_in_function_clause1137);</span>
<span class="nc" id="L2378">					requires_clause45=requires_clause();</span>
<span class="nc" id="L2379">					state._fsp--;</span>
<span class="nc bnc" id="L2380" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_requires_clause.add(requires_clause45.getTree());</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">					SEMICOL46=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_function_clause1139); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2383" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL46);</span>

					// AST REWRITE
					// elements: requires_clause
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L2392" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2393">					retval.tree = root_0;</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2396">					root_0 = (Object)adaptor.nil();</span>
					// 169:30: -&gt; ^( CLAUSE_NORMAL requires_clause )
					{
						// AcslParser.g:169:33: ^( CLAUSE_NORMAL requires_clause )
						{
<span class="nc" id="L2401">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2402">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLAUSE_NORMAL, &quot;CLAUSE_NORMAL&quot;), root_1);</span>
<span class="nc" id="L2403">						adaptor.addChild(root_1, stream_requires_clause.nextTree());</span>
<span class="nc" id="L2404">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L2410">					retval.tree = root_0;</span>
<span class="nc" id="L2411">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:170:7: terminates_clause SEMICOL
					{
<span class="nc" id="L2418">					pushFollow(FOLLOW_terminates_clause_in_function_clause1154);</span>
<span class="nc" id="L2419">					terminates_clause47=terminates_clause();</span>
<span class="nc" id="L2420">					state._fsp--;</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_terminates_clause.add(terminates_clause47.getTree());</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">					SEMICOL48=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_function_clause1156); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL48);</span>

					// AST REWRITE
					// elements: terminates_clause
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L2433" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2434">					retval.tree = root_0;</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2437">					root_0 = (Object)adaptor.nil();</span>
					// 170:32: -&gt; ^( CLAUSE_NORMAL terminates_clause )
					{
						// AcslParser.g:170:35: ^( CLAUSE_NORMAL terminates_clause )
						{
<span class="nc" id="L2442">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2443">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLAUSE_NORMAL, &quot;CLAUSE_NORMAL&quot;), root_1);</span>
<span class="nc" id="L2444">						adaptor.addChild(root_1, stream_terminates_clause.nextTree());</span>
<span class="nc" id="L2445">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L2451">					retval.tree = root_0;</span>
<span class="nc" id="L2452">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:171:7: simple_clause SEMICOL
					{
<span class="nc" id="L2459">					pushFollow(FOLLOW_simple_clause_in_function_clause1171);</span>
<span class="nc" id="L2460">					simple_clause49=simple_clause();</span>
<span class="nc" id="L2461">					state._fsp--;</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2463" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_simple_clause.add(simple_clause49.getTree());</span>
<span class="nc bnc" id="L2464" title="All 2 branches missed.">					SEMICOL50=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_function_clause1173); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL50);</span>

					// AST REWRITE
					// elements: simple_clause
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L2474" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2475">					retval.tree = root_0;</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2478">					root_0 = (Object)adaptor.nil();</span>
					// 171:29: -&gt; ^( CLAUSE_NORMAL simple_clause )
					{
						// AcslParser.g:171:32: ^( CLAUSE_NORMAL simple_clause )
						{
<span class="nc" id="L2483">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2484">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLAUSE_NORMAL, &quot;CLAUSE_NORMAL&quot;), root_1);</span>
<span class="nc" id="L2485">						adaptor.addChild(root_1, stream_simple_clause.nextTree());</span>
<span class="nc" id="L2486">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L2492">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L2499">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2501" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2502">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2503">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2506">		catch (RecognitionException re) {</span>
<span class="nc" id="L2507">			reportError(re);</span>
<span class="nc" id="L2508">			recover(input,re);</span>
<span class="nc" id="L2509">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2511">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2513">		}</span>
<span class="nc" id="L2514">		return retval;</span>
	}
	// $ANTLR end &quot;function_clause&quot;


<span class="nc" id="L2519">	public static class named_behavior_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2522">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;named_behavior_block&quot;
	// AcslParser.g:174:1: named_behavior_block : named_behavior -&gt; ^( CLAUSE_BEHAVIOR named_behavior ) ;
	public final AcslParser.named_behavior_block_return named_behavior_block() throws RecognitionException {
<span class="nc" id="L2529">		AcslParser.named_behavior_block_return retval = new AcslParser.named_behavior_block_return();</span>
<span class="nc" id="L2530">		retval.start = input.LT(1);</span>

<span class="nc" id="L2532">		Object root_0 = null;</span>

<span class="nc" id="L2534">		ParserRuleReturnScope named_behavior51 =null;</span>

<span class="nc" id="L2536">		RewriteRuleSubtreeStream stream_named_behavior=new RewriteRuleSubtreeStream(adaptor,&quot;rule named_behavior&quot;);</span>

		try {
			// AcslParser.g:175:5: ( named_behavior -&gt; ^( CLAUSE_BEHAVIOR named_behavior ) )
			// AcslParser.g:175:7: named_behavior
			{
<span class="nc" id="L2542">			pushFollow(FOLLOW_named_behavior_in_named_behavior_block1198);</span>
<span class="nc" id="L2543">			named_behavior51=named_behavior();</span>
<span class="nc" id="L2544">			state._fsp--;</span>
<span class="nc bnc" id="L2545" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L2546" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_named_behavior.add(named_behavior51.getTree());</span>
			// AST REWRITE
			// elements: named_behavior
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L2554" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2555">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2558">			root_0 = (Object)adaptor.nil();</span>
			// 175:22: -&gt; ^( CLAUSE_BEHAVIOR named_behavior )
			{
				// AcslParser.g:175:25: ^( CLAUSE_BEHAVIOR named_behavior )
				{
<span class="nc" id="L2563">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2564">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLAUSE_BEHAVIOR, &quot;CLAUSE_BEHAVIOR&quot;), root_1);</span>
<span class="nc" id="L2565">				adaptor.addChild(root_1, stream_named_behavior.nextTree());</span>
<span class="nc" id="L2566">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2572">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2577">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2579" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2580">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2581">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2584">		catch (RecognitionException re) {</span>
<span class="nc" id="L2585">			reportError(re);</span>
<span class="nc" id="L2586">			recover(input,re);</span>
<span class="nc" id="L2587">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2589">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2591">		}</span>
<span class="nc" id="L2592">		return retval;</span>
	}
	// $ANTLR end &quot;named_behavior_block&quot;


<span class="nc" id="L2597">	public static class completeness_clause_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2600">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;completeness_clause_block&quot;
	// AcslParser.g:178:1: completeness_clause_block : completeness_clause SEMICOL -&gt; ^( CLAUSE_COMPLETE completeness_clause ) ;
	public final AcslParser.completeness_clause_block_return completeness_clause_block() throws RecognitionException {
<span class="nc" id="L2607">		AcslParser.completeness_clause_block_return retval = new AcslParser.completeness_clause_block_return();</span>
<span class="nc" id="L2608">		retval.start = input.LT(1);</span>

<span class="nc" id="L2610">		Object root_0 = null;</span>

<span class="nc" id="L2612">		Token SEMICOL53=null;</span>
<span class="nc" id="L2613">		ParserRuleReturnScope completeness_clause52 =null;</span>

<span class="nc" id="L2615">		Object SEMICOL53_tree=null;</span>
<span class="nc" id="L2616">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L2617">		RewriteRuleSubtreeStream stream_completeness_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule completeness_clause&quot;);</span>

		try {
			// AcslParser.g:179:5: ( completeness_clause SEMICOL -&gt; ^( CLAUSE_COMPLETE completeness_clause ) )
			// AcslParser.g:179:7: completeness_clause SEMICOL
			{
<span class="nc" id="L2623">			pushFollow(FOLLOW_completeness_clause_in_completeness_clause_block1223);</span>
<span class="nc" id="L2624">			completeness_clause52=completeness_clause();</span>
<span class="nc" id="L2625">			state._fsp--;</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_completeness_clause.add(completeness_clause52.getTree());</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">			SEMICOL53=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_completeness_clause_block1225); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL53);</span>

			// AST REWRITE
			// elements: completeness_clause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L2638" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2639">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2642">			root_0 = (Object)adaptor.nil();</span>
			// 179:35: -&gt; ^( CLAUSE_COMPLETE completeness_clause )
			{
				// AcslParser.g:179:38: ^( CLAUSE_COMPLETE completeness_clause )
				{
<span class="nc" id="L2647">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2648">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CLAUSE_COMPLETE, &quot;CLAUSE_COMPLETE&quot;), root_1);</span>
<span class="nc" id="L2649">				adaptor.addChild(root_1, stream_completeness_clause.nextTree());</span>
<span class="nc" id="L2650">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2656">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2661">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2663" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2664">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2665">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2668">		catch (RecognitionException re) {</span>
<span class="nc" id="L2669">			reportError(re);</span>
<span class="nc" id="L2670">			recover(input,re);</span>
<span class="nc" id="L2671">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2673">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2675">		}</span>
<span class="nc" id="L2676">		return retval;</span>
	}
	// $ANTLR end &quot;completeness_clause_block&quot;


<span class="nc" id="L2681">	public static class requires_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2684">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;requires_clause&quot;
	// AcslParser.g:182:1: requires_clause : REQUIRES term -&gt; ^( REQUIRES term ) ;
	public final AcslParser.requires_clause_return requires_clause() throws RecognitionException {
<span class="nc" id="L2691">		AcslParser.requires_clause_return retval = new AcslParser.requires_clause_return();</span>
<span class="nc" id="L2692">		retval.start = input.LT(1);</span>

<span class="nc" id="L2694">		Object root_0 = null;</span>

<span class="nc" id="L2696">		Token REQUIRES54=null;</span>
<span class="nc" id="L2697">		ParserRuleReturnScope term55 =null;</span>

<span class="nc" id="L2699">		Object REQUIRES54_tree=null;</span>
<span class="nc" id="L2700">		RewriteRuleTokenStream stream_REQUIRES=new RewriteRuleTokenStream(adaptor,&quot;token REQUIRES&quot;);</span>
<span class="nc" id="L2701">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:183:5: ( REQUIRES term -&gt; ^( REQUIRES term ) )
			// AcslParser.g:183:7: REQUIRES term
			{
<span class="nc bnc" id="L2707" title="All 2 branches missed.">			REQUIRES54=(Token)match(input,REQUIRES,FOLLOW_REQUIRES_in_requires_clause1250); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_REQUIRES.add(REQUIRES54);</span>

<span class="nc" id="L2710">			pushFollow(FOLLOW_term_in_requires_clause1252);</span>
<span class="nc" id="L2711">			term55=term();</span>
<span class="nc" id="L2712">			state._fsp--;</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term55.getTree());</span>
			// AST REWRITE
			// elements: term, REQUIRES
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L2722" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2723">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2726">			root_0 = (Object)adaptor.nil();</span>
			// 183:21: -&gt; ^( REQUIRES term )
			{
				// AcslParser.g:183:24: ^( REQUIRES term )
				{
<span class="nc" id="L2731">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2732">				root_1 = (Object)adaptor.becomeRoot(stream_REQUIRES.nextNode(), root_1);</span>
<span class="nc" id="L2733">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L2734">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2740">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2745">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2747" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2748">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2749">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2752">		catch (RecognitionException re) {</span>
<span class="nc" id="L2753">			reportError(re);</span>
<span class="nc" id="L2754">			recover(input,re);</span>
<span class="nc" id="L2755">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2757">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2759">		}</span>
<span class="nc" id="L2760">		return retval;</span>
	}
	// $ANTLR end &quot;requires_clause&quot;


<span class="nc" id="L2765">	public static class terminates_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2768">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;terminates_clause&quot;
	// AcslParser.g:186:1: terminates_clause : TEMINATES term -&gt; ^( TERMINATES term ) ;
	public final AcslParser.terminates_clause_return terminates_clause() throws RecognitionException {
<span class="nc" id="L2775">		AcslParser.terminates_clause_return retval = new AcslParser.terminates_clause_return();</span>
<span class="nc" id="L2776">		retval.start = input.LT(1);</span>

<span class="nc" id="L2778">		Object root_0 = null;</span>

<span class="nc" id="L2780">		Token TEMINATES56=null;</span>
<span class="nc" id="L2781">		ParserRuleReturnScope term57 =null;</span>

<span class="nc" id="L2783">		Object TEMINATES56_tree=null;</span>
<span class="nc" id="L2784">		RewriteRuleTokenStream stream_TEMINATES=new RewriteRuleTokenStream(adaptor,&quot;token TEMINATES&quot;);</span>
<span class="nc" id="L2785">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:187:5: ( TEMINATES term -&gt; ^( TERMINATES term ) )
			// AcslParser.g:187:7: TEMINATES term
			{
<span class="nc bnc" id="L2791" title="All 2 branches missed.">			TEMINATES56=(Token)match(input,TEMINATES,FOLLOW_TEMINATES_in_terminates_clause1277); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_TEMINATES.add(TEMINATES56);</span>

<span class="nc" id="L2794">			pushFollow(FOLLOW_term_in_terminates_clause1279);</span>
<span class="nc" id="L2795">			term57=term();</span>
<span class="nc" id="L2796">			state._fsp--;</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term57.getTree());</span>
			// AST REWRITE
			// elements: term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L2806" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2807">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2810">			root_0 = (Object)adaptor.nil();</span>
			// 187:22: -&gt; ^( TERMINATES term )
			{
				// AcslParser.g:187:25: ^( TERMINATES term )
				{
<span class="nc" id="L2815">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2816">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TERMINATES, &quot;TERMINATES&quot;), root_1);</span>
<span class="nc" id="L2817">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L2818">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2824">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L2829">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2831" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2832">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2833">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2836">		catch (RecognitionException re) {</span>
<span class="nc" id="L2837">			reportError(re);</span>
<span class="nc" id="L2838">			recover(input,re);</span>
<span class="nc" id="L2839">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2841">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2843">		}</span>
<span class="nc" id="L2844">		return retval;</span>
	}
	// $ANTLR end &quot;terminates_clause&quot;


<span class="nc" id="L2849">	public static class rel_op_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2852">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;rel_op&quot;
	// AcslParser.g:190:1: rel_op : ( EQ | NEQ | LTE | GTE | LT | GT );
	public final AcslParser.rel_op_return rel_op() throws RecognitionException {
<span class="nc" id="L2859">		AcslParser.rel_op_return retval = new AcslParser.rel_op_return();</span>
<span class="nc" id="L2860">		retval.start = input.LT(1);</span>

<span class="nc" id="L2862">		Object root_0 = null;</span>

<span class="nc" id="L2864">		Token set58=null;</span>

<span class="nc" id="L2866">		Object set58_tree=null;</span>

		try {
			// AcslParser.g:191:5: ( EQ | NEQ | LTE | GTE | LT | GT )
			// AcslParser.g:
			{
<span class="nc" id="L2872">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2875">			set58=input.LT(1);</span>
<span class="nc bnc" id="L2876" title="All 12 branches missed.">			if ( input.LA(1)==EQ||(input.LA(1) &gt;= GT &amp;&amp; input.LA(1) &lt;= GTE)||(input.LA(1) &gt;= LT &amp;&amp; input.LA(1) &lt;= LTE)||input.LA(1)==NEQ ) {</span>
<span class="nc" id="L2877">				input.consume();</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set58));</span>
<span class="nc" id="L2879">				state.errorRecovery=false;</span>
<span class="nc" id="L2880">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L2883" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L2884">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L2885">				throw mse;</span>
			}
			}

<span class="nc" id="L2889">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L2891" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2892">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2893">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L2896">		catch (RecognitionException re) {</span>
<span class="nc" id="L2897">			reportError(re);</span>
<span class="nc" id="L2898">			recover(input,re);</span>
<span class="nc" id="L2899">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2901">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2903">		}</span>
<span class="nc" id="L2904">		return retval;</span>
	}
	// $ANTLR end &quot;rel_op&quot;


<span class="nc" id="L2909">	public static class binders_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2912">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;binders&quot;
	// AcslParser.g:194:1: binders : binder ( COMMA binder )* -&gt; ^( BINDER_LIST ( binder )+ ) ;
	public final AcslParser.binders_return binders() throws RecognitionException {
<span class="nc" id="L2919">		AcslParser.binders_return retval = new AcslParser.binders_return();</span>
<span class="nc" id="L2920">		retval.start = input.LT(1);</span>

<span class="nc" id="L2922">		Object root_0 = null;</span>

<span class="nc" id="L2924">		Token COMMA60=null;</span>
<span class="nc" id="L2925">		ParserRuleReturnScope binder59 =null;</span>
<span class="nc" id="L2926">		ParserRuleReturnScope binder61 =null;</span>

<span class="nc" id="L2928">		Object COMMA60_tree=null;</span>
<span class="nc" id="L2929">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L2930">		RewriteRuleSubtreeStream stream_binder=new RewriteRuleSubtreeStream(adaptor,&quot;rule binder&quot;);</span>

		try {
			// AcslParser.g:195:5: ( binder ( COMMA binder )* -&gt; ^( BINDER_LIST ( binder )+ ) )
			// AcslParser.g:195:7: binder ( COMMA binder )*
			{
<span class="nc" id="L2936">			pushFollow(FOLLOW_binder_in_binders1341);</span>
<span class="nc" id="L2937">			binder59=binder();</span>
<span class="nc" id="L2938">			state._fsp--;</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_binder.add(binder59.getTree());</span>
			// AcslParser.g:195:14: ( COMMA binder )*
			loop20:
			while (true) {
<span class="nc" id="L2944">				int alt20=2;</span>
<span class="nc" id="L2945">				int LA20_0 = input.LA(1);</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">				if ( (LA20_0==COMMA) ) {</span>
<span class="nc" id="L2947">					alt20=1;</span>
				}

<span class="nc bnc" id="L2950" title="All 2 branches missed.">				switch (alt20) {</span>
				case 1 :
					// AcslParser.g:195:15: COMMA binder
					{
<span class="nc bnc" id="L2954" title="All 2 branches missed.">					COMMA60=(Token)match(input,COMMA,FOLLOW_COMMA_in_binders1344); if (state.failed) return retval; </span>
<span class="nc bnc" id="L2955" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA60);</span>

<span class="nc" id="L2957">					pushFollow(FOLLOW_binder_in_binders1346);</span>
<span class="nc" id="L2958">					binder61=binder();</span>
<span class="nc" id="L2959">					state._fsp--;</span>
<span class="nc bnc" id="L2960" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L2961" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_binder.add(binder61.getTree());</span>
					}
					break;

				default :
<span class="nc" id="L2966">					break loop20;</span>
				}
<span class="nc" id="L2968">			}</span>

			// AST REWRITE
			// elements: binder
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L2977" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L2978">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2981">			root_0 = (Object)adaptor.nil();</span>
			// 196:9: -&gt; ^( BINDER_LIST ( binder )+ )
			{
				// AcslParser.g:196:11: ^( BINDER_LIST ( binder )+ )
				{
<span class="nc" id="L2986">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2987">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(BINDER_LIST, &quot;BINDER_LIST&quot;), root_1);</span>
<span class="nc bnc" id="L2988" title="All 2 branches missed.">				if ( !(stream_binder.hasNext()) ) {</span>
<span class="nc" id="L2989">					throw new RewriteEarlyExitException();</span>
				}
<span class="nc bnc" id="L2991" title="All 2 branches missed.">				while ( stream_binder.hasNext() ) {</span>
<span class="nc" id="L2992">					adaptor.addChild(root_1, stream_binder.nextTree());</span>
				}
<span class="nc" id="L2994">				stream_binder.reset();</span>

<span class="nc" id="L2996">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L3002">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L3007">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3009" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3010">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3011">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3014">		catch (RecognitionException re) {</span>
<span class="nc" id="L3015">			reportError(re);</span>
<span class="nc" id="L3016">			recover(input,re);</span>
<span class="nc" id="L3017">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3019">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3021">		}</span>
<span class="nc" id="L3022">		return retval;</span>
	}
	// $ANTLR end &quot;binders&quot;


<span class="nc" id="L3027">	public static class binder_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3030">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;binder&quot;
	// AcslParser.g:199:1: binder : type_expr variable_ident ( COMMA variable_ident )* -&gt; ^( BINDER type_expr ( variable_ident )+ ) ;
	public final AcslParser.binder_return binder() throws RecognitionException {
<span class="nc" id="L3037">		AcslParser.binder_return retval = new AcslParser.binder_return();</span>
<span class="nc" id="L3038">		retval.start = input.LT(1);</span>

<span class="nc" id="L3040">		Object root_0 = null;</span>

<span class="nc" id="L3042">		Token COMMA64=null;</span>
<span class="nc" id="L3043">		ParserRuleReturnScope type_expr62 =null;</span>
<span class="nc" id="L3044">		ParserRuleReturnScope variable_ident63 =null;</span>
<span class="nc" id="L3045">		ParserRuleReturnScope variable_ident65 =null;</span>

<span class="nc" id="L3047">		Object COMMA64_tree=null;</span>
<span class="nc" id="L3048">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L3049">		RewriteRuleSubtreeStream stream_variable_ident=new RewriteRuleSubtreeStream(adaptor,&quot;rule variable_ident&quot;);</span>
<span class="nc" id="L3050">		RewriteRuleSubtreeStream stream_type_expr=new RewriteRuleSubtreeStream(adaptor,&quot;rule type_expr&quot;);</span>

		try {
			// AcslParser.g:200:5: ( type_expr variable_ident ( COMMA variable_ident )* -&gt; ^( BINDER type_expr ( variable_ident )+ ) )
			// AcslParser.g:200:7: type_expr variable_ident ( COMMA variable_ident )*
			{
<span class="nc" id="L3056">			pushFollow(FOLLOW_type_expr_in_binder1381);</span>
<span class="nc" id="L3057">			type_expr62=type_expr();</span>
<span class="nc" id="L3058">			state._fsp--;</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L3060" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_type_expr.add(type_expr62.getTree());</span>
<span class="nc" id="L3061">			pushFollow(FOLLOW_variable_ident_in_binder1383);</span>
<span class="nc" id="L3062">			variable_ident63=variable_ident();</span>
<span class="nc" id="L3063">			state._fsp--;</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_variable_ident.add(variable_ident63.getTree());</span>
			// AcslParser.g:200:32: ( COMMA variable_ident )*
			loop21:
			while (true) {
<span class="nc" id="L3069">				int alt21=2;</span>
<span class="nc" id="L3070">				int LA21_0 = input.LA(1);</span>
<span class="nc bnc" id="L3071" title="All 2 branches missed.">				if ( (LA21_0==COMMA) ) {</span>
<span class="nc" id="L3072">					int LA21_1 = input.LA(2);</span>
<span class="nc bnc" id="L3073" title="All 2 branches missed.">					if ( (LA21_1==ID) ) {</span>
<span class="nc" id="L3074">						int LA21_3 = input.LA(3);</span>
<span class="nc bnc" id="L3075" title="All 10 branches missed.">						if ( (LA21_3==EOF||LA21_3==COMMA||LA21_3==LSQUARE||LA21_3==RCURLY||LA21_3==SEMICOL) ) {</span>
<span class="nc" id="L3076">							alt21=1;</span>
						}

<span class="nc" id="L3079">					}</span>
<span class="nc bnc" id="L3080" title="All 4 branches missed.">					else if ( (LA21_1==LPAREN||LA21_1==STAR) ) {</span>
<span class="nc" id="L3081">						alt21=1;</span>
					}

				}

<span class="nc bnc" id="L3086" title="All 2 branches missed.">				switch (alt21) {</span>
				case 1 :
					// AcslParser.g:200:33: COMMA variable_ident
					{
<span class="nc bnc" id="L3090" title="All 2 branches missed.">					COMMA64=(Token)match(input,COMMA,FOLLOW_COMMA_in_binder1386); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3091" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA64);</span>

<span class="nc" id="L3093">					pushFollow(FOLLOW_variable_ident_in_binder1388);</span>
<span class="nc" id="L3094">					variable_ident65=variable_ident();</span>
<span class="nc" id="L3095">					state._fsp--;</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident.add(variable_ident65.getTree());</span>
					}
					break;

				default :
<span class="nc" id="L3102">					break loop21;</span>
				}
<span class="nc" id="L3104">			}</span>

			// AST REWRITE
			// elements: variable_ident, type_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L3113" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3114">			retval.tree = root_0;</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3117">			root_0 = (Object)adaptor.nil();</span>
			// 201:9: -&gt; ^( BINDER type_expr ( variable_ident )+ )
			{
				// AcslParser.g:201:11: ^( BINDER type_expr ( variable_ident )+ )
				{
<span class="nc" id="L3122">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3123">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(BINDER, &quot;BINDER&quot;), root_1);</span>
<span class="nc" id="L3124">				adaptor.addChild(root_1, stream_type_expr.nextTree());</span>
<span class="nc bnc" id="L3125" title="All 2 branches missed.">				if ( !(stream_variable_ident.hasNext()) ) {</span>
<span class="nc" id="L3126">					throw new RewriteEarlyExitException();</span>
				}
<span class="nc bnc" id="L3128" title="All 2 branches missed.">				while ( stream_variable_ident.hasNext() ) {</span>
<span class="nc" id="L3129">					adaptor.addChild(root_1, stream_variable_ident.nextTree());</span>
				}
<span class="nc" id="L3131">				stream_variable_ident.reset();</span>

<span class="nc" id="L3133">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L3139">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L3144">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3146" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3147">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3148">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3151">		catch (RecognitionException re) {</span>
<span class="nc" id="L3152">			reportError(re);</span>
<span class="nc" id="L3153">			recover(input,re);</span>
<span class="nc" id="L3154">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3156">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3158">		}</span>
<span class="nc" id="L3159">		return retval;</span>
	}
	// $ANTLR end &quot;binder&quot;


<span class="nc" id="L3164">	public static class type_expr_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3167">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;type_expr&quot;
	// AcslParser.g:204:1: type_expr : ( logic_type_expr -&gt; ^( LOGIC_TYPE logic_type_expr ) | c_type -&gt; ^( C_TYPE c_type ) );
	public final AcslParser.type_expr_return type_expr() throws RecognitionException {
<span class="nc" id="L3174">		AcslParser.type_expr_return retval = new AcslParser.type_expr_return();</span>
<span class="nc" id="L3175">		retval.start = input.LT(1);</span>

<span class="nc" id="L3177">		Object root_0 = null;</span>

<span class="nc" id="L3179">		ParserRuleReturnScope logic_type_expr66 =null;</span>
<span class="nc" id="L3180">		ParserRuleReturnScope c_type67 =null;</span>

<span class="nc" id="L3182">		RewriteRuleSubtreeStream stream_c_type=new RewriteRuleSubtreeStream(adaptor,&quot;rule c_type&quot;);</span>
<span class="nc" id="L3183">		RewriteRuleSubtreeStream stream_logic_type_expr=new RewriteRuleSubtreeStream(adaptor,&quot;rule logic_type_expr&quot;);</span>

		try {
			// AcslParser.g:205:5: ( logic_type_expr -&gt; ^( LOGIC_TYPE logic_type_expr ) | c_type -&gt; ^( C_TYPE c_type ) )
<span class="nc" id="L3187">			int alt22=2;</span>
<span class="nc" id="L3188">			int LA22_0 = input.LA(1);</span>
<span class="nc bnc" id="L3189" title="All 8 branches missed.">			if ( (LA22_0==BOOLEAN||LA22_0==ID||LA22_0==INTEGER||LA22_0==REAL) ) {</span>
<span class="nc" id="L3190">				alt22=1;</span>
			}
<span class="nc bnc" id="L3192" title="All 14 branches missed.">			else if ( (LA22_0==CHAR||LA22_0==DOUBLE||LA22_0==FLOAT||LA22_0==INT||LA22_0==LONG||LA22_0==SHORT||LA22_0==VOID) ) {</span>
<span class="nc" id="L3193">				alt22=2;</span>
			}

			else {
<span class="nc bnc" id="L3197" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3198">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 22, 0, input);
<span class="nc" id="L3200">				throw nvae;</span>
			}

<span class="nc bnc" id="L3203" title="All 3 branches missed.">			switch (alt22) {</span>
				case 1 :
					// AcslParser.g:205:7: logic_type_expr
					{
<span class="nc" id="L3207">					pushFollow(FOLLOW_logic_type_expr_in_type_expr1425);</span>
<span class="nc" id="L3208">					logic_type_expr66=logic_type_expr();</span>
<span class="nc" id="L3209">					state._fsp--;</span>
<span class="nc bnc" id="L3210" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_logic_type_expr.add(logic_type_expr66.getTree());</span>
					// AST REWRITE
					// elements: logic_type_expr
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3219" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3220">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3221" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3223">					root_0 = (Object)adaptor.nil();</span>
					// 205:23: -&gt; ^( LOGIC_TYPE logic_type_expr )
					{
						// AcslParser.g:205:25: ^( LOGIC_TYPE logic_type_expr )
						{
<span class="nc" id="L3228">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3229">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(LOGIC_TYPE, &quot;LOGIC_TYPE&quot;), root_1);</span>
<span class="nc" id="L3230">						adaptor.addChild(root_1, stream_logic_type_expr.nextTree());</span>
<span class="nc" id="L3231">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3237">					retval.tree = root_0;</span>
<span class="nc" id="L3238">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:206:7: c_type
					{
<span class="nc" id="L3245">					pushFollow(FOLLOW_c_type_in_type_expr1440);</span>
<span class="nc" id="L3246">					c_type67=c_type();</span>
<span class="nc" id="L3247">					state._fsp--;</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_c_type.add(c_type67.getTree());</span>
					// AST REWRITE
					// elements: c_type
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3257" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3258">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3261">					root_0 = (Object)adaptor.nil();</span>
					// 206:14: -&gt; ^( C_TYPE c_type )
					{
						// AcslParser.g:206:16: ^( C_TYPE c_type )
						{
<span class="nc" id="L3266">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3267">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(C_TYPE, &quot;C_TYPE&quot;), root_1);</span>
<span class="nc" id="L3268">						adaptor.addChild(root_1, stream_c_type.nextTree());</span>
<span class="nc" id="L3269">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3275">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L3282">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3284" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3285">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3286">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3289">		catch (RecognitionException re) {</span>
<span class="nc" id="L3290">			reportError(re);</span>
<span class="nc" id="L3291">			recover(input,re);</span>
<span class="nc" id="L3292">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3294">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3296">		}</span>
<span class="nc" id="L3297">		return retval;</span>
	}
	// $ANTLR end &quot;type_expr&quot;


<span class="nc" id="L3302">	public static class logic_type_expr_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3305">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;logic_type_expr&quot;
	// AcslParser.g:209:1: logic_type_expr : ( built_in_logic_type -&gt; ^( TYPE_BUILTIN built_in_logic_type ) | ID -&gt; ^( TYPE_ID ID ) );
	public final AcslParser.logic_type_expr_return logic_type_expr() throws RecognitionException {
<span class="nc" id="L3312">		AcslParser.logic_type_expr_return retval = new AcslParser.logic_type_expr_return();</span>
<span class="nc" id="L3313">		retval.start = input.LT(1);</span>

<span class="nc" id="L3315">		Object root_0 = null;</span>

<span class="nc" id="L3317">		Token ID69=null;</span>
<span class="nc" id="L3318">		ParserRuleReturnScope built_in_logic_type68 =null;</span>

<span class="nc" id="L3320">		Object ID69_tree=null;</span>
<span class="nc" id="L3321">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L3322">		RewriteRuleSubtreeStream stream_built_in_logic_type=new RewriteRuleSubtreeStream(adaptor,&quot;rule built_in_logic_type&quot;);</span>

		try {
			// AcslParser.g:210:5: ( built_in_logic_type -&gt; ^( TYPE_BUILTIN built_in_logic_type ) | ID -&gt; ^( TYPE_ID ID ) )
<span class="nc" id="L3326">			int alt23=2;</span>
<span class="nc" id="L3327">			int LA23_0 = input.LA(1);</span>
<span class="nc bnc" id="L3328" title="All 6 branches missed.">			if ( (LA23_0==BOOLEAN||LA23_0==INTEGER||LA23_0==REAL) ) {</span>
<span class="nc" id="L3329">				alt23=1;</span>
			}
<span class="nc bnc" id="L3331" title="All 2 branches missed.">			else if ( (LA23_0==ID) ) {</span>
<span class="nc" id="L3332">				alt23=2;</span>
			}

			else {
<span class="nc bnc" id="L3336" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3337">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 23, 0, input);
<span class="nc" id="L3339">				throw nvae;</span>
			}

<span class="nc bnc" id="L3342" title="All 3 branches missed.">			switch (alt23) {</span>
				case 1 :
					// AcslParser.g:210:7: built_in_logic_type
					{
<span class="nc" id="L3346">					pushFollow(FOLLOW_built_in_logic_type_in_logic_type_expr1464);</span>
<span class="nc" id="L3347">					built_in_logic_type68=built_in_logic_type();</span>
<span class="nc" id="L3348">					state._fsp--;</span>
<span class="nc bnc" id="L3349" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3350" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_built_in_logic_type.add(built_in_logic_type68.getTree());</span>
					// AST REWRITE
					// elements: built_in_logic_type
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3358" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3359">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3360" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3362">					root_0 = (Object)adaptor.nil();</span>
					// 210:27: -&gt; ^( TYPE_BUILTIN built_in_logic_type )
					{
						// AcslParser.g:210:29: ^( TYPE_BUILTIN built_in_logic_type )
						{
<span class="nc" id="L3367">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3368">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TYPE_BUILTIN, &quot;TYPE_BUILTIN&quot;), root_1);</span>
<span class="nc" id="L3369">						adaptor.addChild(root_1, stream_built_in_logic_type.nextTree());</span>
<span class="nc" id="L3370">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3376">					retval.tree = root_0;</span>
<span class="nc" id="L3377">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:211:7: ID
					{
<span class="nc bnc" id="L3384" title="All 2 branches missed.">					ID69=(Token)match(input,ID,FOLLOW_ID_in_logic_type_expr1479); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3385" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID69);</span>

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3394" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3395">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3396" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3398">					root_0 = (Object)adaptor.nil();</span>
					// 211:10: -&gt; ^( TYPE_ID ID )
					{
						// AcslParser.g:211:12: ^( TYPE_ID ID )
						{
<span class="nc" id="L3403">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3404">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TYPE_ID, &quot;TYPE_ID&quot;), root_1);</span>
<span class="nc" id="L3405">						adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L3406">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3412">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L3419">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3421" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3422">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3423">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3426">		catch (RecognitionException re) {</span>
<span class="nc" id="L3427">			reportError(re);</span>
<span class="nc" id="L3428">			recover(input,re);</span>
<span class="nc" id="L3429">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3431">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3433">		}</span>
<span class="nc" id="L3434">		return retval;</span>
	}
	// $ANTLR end &quot;logic_type_expr&quot;


<span class="nc" id="L3439">	public static class c_type_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3442">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;c_type&quot;
	// AcslParser.g:214:1: c_type : ( CHAR | DOUBLE | FLOAT | INT | LONG | SHORT | VOID );
	public final AcslParser.c_type_return c_type() throws RecognitionException {
<span class="nc" id="L3449">		AcslParser.c_type_return retval = new AcslParser.c_type_return();</span>
<span class="nc" id="L3450">		retval.start = input.LT(1);</span>

<span class="nc" id="L3452">		Object root_0 = null;</span>

<span class="nc" id="L3454">		Token set70=null;</span>

<span class="nc" id="L3456">		Object set70_tree=null;</span>

		try {
			// AcslParser.g:215:5: ( CHAR | DOUBLE | FLOAT | INT | LONG | SHORT | VOID )
			// AcslParser.g:
			{
<span class="nc" id="L3462">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L3465">			set70=input.LT(1);</span>
<span class="nc bnc" id="L3466" title="All 14 branches missed.">			if ( input.LA(1)==CHAR||input.LA(1)==DOUBLE||input.LA(1)==FLOAT||input.LA(1)==INT||input.LA(1)==LONG||input.LA(1)==SHORT||input.LA(1)==VOID ) {</span>
<span class="nc" id="L3467">				input.consume();</span>
<span class="nc bnc" id="L3468" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set70));</span>
<span class="nc" id="L3469">				state.errorRecovery=false;</span>
<span class="nc" id="L3470">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L3473" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3474">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L3475">				throw mse;</span>
			}
			}

<span class="nc" id="L3479">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3481" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3482">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3483">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3486">		catch (RecognitionException re) {</span>
<span class="nc" id="L3487">			reportError(re);</span>
<span class="nc" id="L3488">			recover(input,re);</span>
<span class="nc" id="L3489">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3491">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3493">		}</span>
<span class="nc" id="L3494">		return retval;</span>
	}
	// $ANTLR end &quot;c_type&quot;


<span class="nc" id="L3499">	public static class built_in_logic_type_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3502">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;built_in_logic_type&quot;
	// AcslParser.g:218:1: built_in_logic_type : ( BOOLEAN | INTEGER | REAL );
	public final AcslParser.built_in_logic_type_return built_in_logic_type() throws RecognitionException {
<span class="nc" id="L3509">		AcslParser.built_in_logic_type_return retval = new AcslParser.built_in_logic_type_return();</span>
<span class="nc" id="L3510">		retval.start = input.LT(1);</span>

<span class="nc" id="L3512">		Object root_0 = null;</span>

<span class="nc" id="L3514">		Token set71=null;</span>

<span class="nc" id="L3516">		Object set71_tree=null;</span>

		try {
			// AcslParser.g:219:5: ( BOOLEAN | INTEGER | REAL )
			// AcslParser.g:
			{
<span class="nc" id="L3522">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L3525">			set71=input.LT(1);</span>
<span class="nc bnc" id="L3526" title="All 6 branches missed.">			if ( input.LA(1)==BOOLEAN||input.LA(1)==INTEGER||input.LA(1)==REAL ) {</span>
<span class="nc" id="L3527">				input.consume();</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set71));</span>
<span class="nc" id="L3529">				state.errorRecovery=false;</span>
<span class="nc" id="L3530">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L3533" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3534">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L3535">				throw mse;</span>
			}
			}

<span class="nc" id="L3539">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3541" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3542">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3543">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3546">		catch (RecognitionException re) {</span>
<span class="nc" id="L3547">			reportError(re);</span>
<span class="nc" id="L3548">			recover(input,re);</span>
<span class="nc" id="L3549">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3551">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3553">		}</span>
<span class="nc" id="L3554">		return retval;</span>
	}
	// $ANTLR end &quot;built_in_logic_type&quot;


<span class="nc" id="L3559">	public static class variable_ident_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3562">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;variable_ident&quot;
	// AcslParser.g:222:1: variable_ident : ( STAR variable_ident_base -&gt; ^( VAR_ID_STAR variable_ident_base ) | variable_ident_base LSQUARE RSQUARE -&gt; ^( VAR_ID_SQUARE variable_ident_base ) | variable_ident_base -&gt; ^( VAR_ID variable_ident_base ) );
	public final AcslParser.variable_ident_return variable_ident() throws RecognitionException {
<span class="nc" id="L3569">		AcslParser.variable_ident_return retval = new AcslParser.variable_ident_return();</span>
<span class="nc" id="L3570">		retval.start = input.LT(1);</span>

<span class="nc" id="L3572">		Object root_0 = null;</span>

<span class="nc" id="L3574">		Token STAR72=null;</span>
<span class="nc" id="L3575">		Token LSQUARE75=null;</span>
<span class="nc" id="L3576">		Token RSQUARE76=null;</span>
<span class="nc" id="L3577">		ParserRuleReturnScope variable_ident_base73 =null;</span>
<span class="nc" id="L3578">		ParserRuleReturnScope variable_ident_base74 =null;</span>
<span class="nc" id="L3579">		ParserRuleReturnScope variable_ident_base77 =null;</span>

<span class="nc" id="L3581">		Object STAR72_tree=null;</span>
<span class="nc" id="L3582">		Object LSQUARE75_tree=null;</span>
<span class="nc" id="L3583">		Object RSQUARE76_tree=null;</span>
<span class="nc" id="L3584">		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,&quot;token STAR&quot;);</span>
<span class="nc" id="L3585">		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,&quot;token LSQUARE&quot;);</span>
<span class="nc" id="L3586">		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,&quot;token RSQUARE&quot;);</span>
<span class="nc" id="L3587">		RewriteRuleSubtreeStream stream_variable_ident_base=new RewriteRuleSubtreeStream(adaptor,&quot;rule variable_ident_base&quot;);</span>

		try {
			// AcslParser.g:223:5: ( STAR variable_ident_base -&gt; ^( VAR_ID_STAR variable_ident_base ) | variable_ident_base LSQUARE RSQUARE -&gt; ^( VAR_ID_SQUARE variable_ident_base ) | variable_ident_base -&gt; ^( VAR_ID variable_ident_base ) )
<span class="nc" id="L3591">			int alt24=3;</span>
<span class="nc bnc" id="L3592" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case STAR:
				{
<span class="nc" id="L3595">				alt24=1;</span>
				}
<span class="nc" id="L3597">				break;</span>
			case ID:
				{
<span class="nc" id="L3600">				int LA24_2 = input.LA(2);</span>
<span class="nc bnc" id="L3601" title="All 2 branches missed.">				if ( (synpred40_AcslParser()) ) {</span>
<span class="nc" id="L3602">					alt24=2;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L3605">					alt24=3;</span>
				}

				}
<span class="nc" id="L3609">				break;</span>
			case LPAREN:
				{
<span class="nc" id="L3612">				int LA24_3 = input.LA(2);</span>
<span class="nc bnc" id="L3613" title="All 2 branches missed.">				if ( (synpred40_AcslParser()) ) {</span>
<span class="nc" id="L3614">					alt24=2;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L3617">					alt24=3;</span>
				}

				}
<span class="nc" id="L3621">				break;</span>
			default:
<span class="nc bnc" id="L3623" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3624">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 24, 0, input);
<span class="nc" id="L3626">				throw nvae;</span>
			}
<span class="nc bnc" id="L3628" title="All 4 branches missed.">			switch (alt24) {</span>
				case 1 :
					// AcslParser.g:223:7: STAR variable_ident_base
					{
<span class="nc bnc" id="L3632" title="All 2 branches missed.">					STAR72=(Token)match(input,STAR,FOLLOW_STAR_in_variable_ident1569); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3633" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_STAR.add(STAR72);</span>

<span class="nc" id="L3635">					pushFollow(FOLLOW_variable_ident_base_in_variable_ident1571);</span>
<span class="nc" id="L3636">					variable_ident_base73=variable_ident_base();</span>
<span class="nc" id="L3637">					state._fsp--;</span>
<span class="nc bnc" id="L3638" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident_base.add(variable_ident_base73.getTree());</span>
					// AST REWRITE
					// elements: variable_ident_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3647" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3648">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3649" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3651">					root_0 = (Object)adaptor.nil();</span>
					// 224:9: -&gt; ^( VAR_ID_STAR variable_ident_base )
					{
						// AcslParser.g:224:11: ^( VAR_ID_STAR variable_ident_base )
						{
<span class="nc" id="L3656">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3657">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR_ID_STAR, &quot;VAR_ID_STAR&quot;), root_1);</span>
<span class="nc" id="L3658">						adaptor.addChild(root_1, stream_variable_ident_base.nextTree());</span>
<span class="nc" id="L3659">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3665">					retval.tree = root_0;</span>
<span class="nc" id="L3666">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:225:7: variable_ident_base LSQUARE RSQUARE
					{
<span class="nc" id="L3673">					pushFollow(FOLLOW_variable_ident_base_in_variable_ident1594);</span>
<span class="nc" id="L3674">					variable_ident_base74=variable_ident_base();</span>
<span class="nc" id="L3675">					state._fsp--;</span>
<span class="nc bnc" id="L3676" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3677" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident_base.add(variable_ident_base74.getTree());</span>
<span class="nc bnc" id="L3678" title="All 2 branches missed.">					LSQUARE75=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_variable_ident1596); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LSQUARE.add(LSQUARE75);</span>

<span class="nc bnc" id="L3681" title="All 2 branches missed.">					RSQUARE76=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_variable_ident1598); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3682" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE76);</span>

					// AST REWRITE
					// elements: variable_ident_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3691" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3692">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3693" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3695">					root_0 = (Object)adaptor.nil();</span>
					// 226:9: -&gt; ^( VAR_ID_SQUARE variable_ident_base )
					{
						// AcslParser.g:226:11: ^( VAR_ID_SQUARE variable_ident_base )
						{
<span class="nc" id="L3700">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3701">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR_ID_SQUARE, &quot;VAR_ID_SQUARE&quot;), root_1);</span>
<span class="nc" id="L3702">						adaptor.addChild(root_1, stream_variable_ident_base.nextTree());</span>
<span class="nc" id="L3703">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3709">					retval.tree = root_0;</span>
<span class="nc" id="L3710">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:227:7: variable_ident_base
					{
<span class="nc" id="L3717">					pushFollow(FOLLOW_variable_ident_base_in_variable_ident1621);</span>
<span class="nc" id="L3718">					variable_ident_base77=variable_ident_base();</span>
<span class="nc" id="L3719">					state._fsp--;</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident_base.add(variable_ident_base77.getTree());</span>
					// AST REWRITE
					// elements: variable_ident_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3729" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3730">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3731" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3733">					root_0 = (Object)adaptor.nil();</span>
					// 228:9: -&gt; ^( VAR_ID variable_ident_base )
					{
						// AcslParser.g:228:11: ^( VAR_ID variable_ident_base )
						{
<span class="nc" id="L3738">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3739">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR_ID, &quot;VAR_ID&quot;), root_1);</span>
<span class="nc" id="L3740">						adaptor.addChild(root_1, stream_variable_ident_base.nextTree());</span>
<span class="nc" id="L3741">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3747">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L3754">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3756" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3757">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3758">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3761">		catch (RecognitionException re) {</span>
<span class="nc" id="L3762">			reportError(re);</span>
<span class="nc" id="L3763">			recover(input,re);</span>
<span class="nc" id="L3764">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3766">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3768">		}</span>
<span class="nc" id="L3769">		return retval;</span>
	}
	// $ANTLR end &quot;variable_ident&quot;


<span class="nc" id="L3774">	public static class variable_ident_base_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3777">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;variable_ident_base&quot;
	// AcslParser.g:231:1: variable_ident_base : ( ID -&gt; ^( ID ) | LPAREN variable_ident RPAREN -&gt; ^( VAR_ID_BASE variable_ident ) );
	public final AcslParser.variable_ident_base_return variable_ident_base() throws RecognitionException {
<span class="nc" id="L3784">		AcslParser.variable_ident_base_return retval = new AcslParser.variable_ident_base_return();</span>
<span class="nc" id="L3785">		retval.start = input.LT(1);</span>

<span class="nc" id="L3787">		Object root_0 = null;</span>

<span class="nc" id="L3789">		Token ID78=null;</span>
<span class="nc" id="L3790">		Token LPAREN79=null;</span>
<span class="nc" id="L3791">		Token RPAREN81=null;</span>
<span class="nc" id="L3792">		ParserRuleReturnScope variable_ident80 =null;</span>

<span class="nc" id="L3794">		Object ID78_tree=null;</span>
<span class="nc" id="L3795">		Object LPAREN79_tree=null;</span>
<span class="nc" id="L3796">		Object RPAREN81_tree=null;</span>
<span class="nc" id="L3797">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L3798">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L3799">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L3800">		RewriteRuleSubtreeStream stream_variable_ident=new RewriteRuleSubtreeStream(adaptor,&quot;rule variable_ident&quot;);</span>

		try {
			// AcslParser.g:232:5: ( ID -&gt; ^( ID ) | LPAREN variable_ident RPAREN -&gt; ^( VAR_ID_BASE variable_ident ) )
<span class="nc" id="L3804">			int alt25=2;</span>
<span class="nc" id="L3805">			int LA25_0 = input.LA(1);</span>
<span class="nc bnc" id="L3806" title="All 2 branches missed.">			if ( (LA25_0==ID) ) {</span>
<span class="nc" id="L3807">				alt25=1;</span>
			}
<span class="nc bnc" id="L3809" title="All 2 branches missed.">			else if ( (LA25_0==LPAREN) ) {</span>
<span class="nc" id="L3810">				alt25=2;</span>
			}

			else {
<span class="nc bnc" id="L3814" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L3815">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 25, 0, input);
<span class="nc" id="L3817">				throw nvae;</span>
			}

<span class="nc bnc" id="L3820" title="All 3 branches missed.">			switch (alt25) {</span>
				case 1 :
					// AcslParser.g:232:7: ID
					{
<span class="nc bnc" id="L3824" title="All 2 branches missed.">					ID78=(Token)match(input,ID,FOLLOW_ID_in_variable_ident_base1653); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3825" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID78);</span>

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3834" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3835">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3836" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3838">					root_0 = (Object)adaptor.nil();</span>
					// 233:7: -&gt; ^( ID )
					{
						// AcslParser.g:233:9: ^( ID )
						{
<span class="nc" id="L3843">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3844">						root_1 = (Object)adaptor.becomeRoot(stream_ID.nextNode(), root_1);</span>
<span class="nc" id="L3845">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3851">					retval.tree = root_0;</span>
<span class="nc" id="L3852">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:234:7: LPAREN variable_ident RPAREN
					{
<span class="nc bnc" id="L3859" title="All 2 branches missed.">					LPAREN79=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_variable_ident_base1672); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3860" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN79);</span>

<span class="nc" id="L3862">					pushFollow(FOLLOW_variable_ident_in_variable_ident_base1674);</span>
<span class="nc" id="L3863">					variable_ident80=variable_ident();</span>
<span class="nc" id="L3864">					state._fsp--;</span>
<span class="nc bnc" id="L3865" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L3866" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident.add(variable_ident80.getTree());</span>
<span class="nc bnc" id="L3867" title="All 2 branches missed.">					RPAREN81=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_variable_ident_base1676); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3868" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN81);</span>

					// AST REWRITE
					// elements: variable_ident
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L3877" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3878">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3879" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3881">					root_0 = (Object)adaptor.nil();</span>
					// 235:7: -&gt; ^( VAR_ID_BASE variable_ident )
					{
						// AcslParser.g:235:9: ^( VAR_ID_BASE variable_ident )
						{
<span class="nc" id="L3886">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3887">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(VAR_ID_BASE, &quot;VAR_ID_BASE&quot;), root_1);</span>
<span class="nc" id="L3888">						adaptor.addChild(root_1, stream_variable_ident.nextTree());</span>
<span class="nc" id="L3889">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3895">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L3902">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3904" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3905">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3906">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3909">		catch (RecognitionException re) {</span>
<span class="nc" id="L3910">			reportError(re);</span>
<span class="nc" id="L3911">			recover(input,re);</span>
<span class="nc" id="L3912">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3914">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3916">		}</span>
<span class="nc" id="L3917">		return retval;</span>
	}
	// $ANTLR end &quot;variable_ident_base&quot;


<span class="nc" id="L3922">	public static class guards_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3925">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;guards_clause&quot;
	// AcslParser.g:238:1: guards_clause : GUARDS term -&gt; ^( GUARDS term ) ;
	public final AcslParser.guards_clause_return guards_clause() throws RecognitionException {
<span class="nc" id="L3932">		AcslParser.guards_clause_return retval = new AcslParser.guards_clause_return();</span>
<span class="nc" id="L3933">		retval.start = input.LT(1);</span>

<span class="nc" id="L3935">		Object root_0 = null;</span>

<span class="nc" id="L3937">		Token GUARDS82=null;</span>
<span class="nc" id="L3938">		ParserRuleReturnScope term83 =null;</span>

<span class="nc" id="L3940">		Object GUARDS82_tree=null;</span>
<span class="nc" id="L3941">		RewriteRuleTokenStream stream_GUARDS=new RewriteRuleTokenStream(adaptor,&quot;token GUARDS&quot;);</span>
<span class="nc" id="L3942">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:239:5: ( GUARDS term -&gt; ^( GUARDS term ) )
			// AcslParser.g:239:7: GUARDS term
			{
<span class="nc bnc" id="L3948" title="All 2 branches missed.">			GUARDS82=(Token)match(input,GUARDS,FOLLOW_GUARDS_in_guards_clause1706); if (state.failed) return retval; </span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_GUARDS.add(GUARDS82);</span>

<span class="nc" id="L3951">			pushFollow(FOLLOW_term_in_guards_clause1708);</span>
<span class="nc" id="L3952">			term83=term();</span>
<span class="nc" id="L3953">			state._fsp--;</span>
<span class="nc bnc" id="L3954" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L3955" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term83.getTree());</span>
			// AST REWRITE
			// elements: term, GUARDS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L3963" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3964">			retval.tree = root_0;</span>
<span class="nc bnc" id="L3965" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3967">			root_0 = (Object)adaptor.nil();</span>
			// 239:19: -&gt; ^( GUARDS term )
			{
				// AcslParser.g:239:21: ^( GUARDS term )
				{
<span class="nc" id="L3972">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3973">				root_1 = (Object)adaptor.becomeRoot(stream_GUARDS.nextNode(), root_1);</span>
<span class="nc" id="L3974">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L3975">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L3981">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L3986">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L3988" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L3989">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3990">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L3993">		catch (RecognitionException re) {</span>
<span class="nc" id="L3994">			reportError(re);</span>
<span class="nc" id="L3995">			recover(input,re);</span>
<span class="nc" id="L3996">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3998">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4000">		}</span>
<span class="nc" id="L4001">		return retval;</span>
	}
	// $ANTLR end &quot;guards_clause&quot;


<span class="nc" id="L4006">	public static class simple_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4009">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;simple_clause&quot;
	// AcslParser.g:242:1: simple_clause : ( assigns_clause | ensures_clause | allocation_clause | reads_clause | depends_clause | guards_clause );
	public final AcslParser.simple_clause_return simple_clause() throws RecognitionException {
<span class="nc" id="L4016">		AcslParser.simple_clause_return retval = new AcslParser.simple_clause_return();</span>
<span class="nc" id="L4017">		retval.start = input.LT(1);</span>

<span class="nc" id="L4019">		Object root_0 = null;</span>

<span class="nc" id="L4021">		ParserRuleReturnScope assigns_clause84 =null;</span>
<span class="nc" id="L4022">		ParserRuleReturnScope ensures_clause85 =null;</span>
<span class="nc" id="L4023">		ParserRuleReturnScope allocation_clause86 =null;</span>
<span class="nc" id="L4024">		ParserRuleReturnScope reads_clause87 =null;</span>
<span class="nc" id="L4025">		ParserRuleReturnScope depends_clause88 =null;</span>
<span class="nc" id="L4026">		ParserRuleReturnScope guards_clause89 =null;</span>


		try {
			// AcslParser.g:243:5: ( assigns_clause | ensures_clause | allocation_clause | reads_clause | depends_clause | guards_clause )
<span class="nc" id="L4031">			int alt26=6;</span>
<span class="nc bnc" id="L4032" title="All 7 branches missed.">			switch ( input.LA(1) ) {</span>
			case ASSIGNS:
				{
<span class="nc" id="L4035">				alt26=1;</span>
				}
<span class="nc" id="L4037">				break;</span>
			case ENSURES:
				{
<span class="nc" id="L4040">				alt26=2;</span>
				}
<span class="nc" id="L4042">				break;</span>
			case ALLOC:
			case FREES:
				{
<span class="nc" id="L4046">				alt26=3;</span>
				}
<span class="nc" id="L4048">				break;</span>
			case READS:
				{
<span class="nc" id="L4051">				alt26=4;</span>
				}
<span class="nc" id="L4053">				break;</span>
			case DEPENDS:
				{
<span class="nc" id="L4056">				alt26=5;</span>
				}
<span class="nc" id="L4058">				break;</span>
			case GUARDS:
				{
<span class="nc" id="L4061">				alt26=6;</span>
				}
<span class="nc" id="L4063">				break;</span>
			default:
<span class="nc bnc" id="L4065" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L4066">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 26, 0, input);
<span class="nc" id="L4068">				throw nvae;</span>
			}
<span class="nc bnc" id="L4070" title="All 7 branches missed.">			switch (alt26) {</span>
				case 1 :
					// AcslParser.g:243:7: assigns_clause
					{
<span class="nc" id="L4074">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4077">					pushFollow(FOLLOW_assigns_clause_in_simple_clause1732);</span>
<span class="nc" id="L4078">					assigns_clause84=assigns_clause();</span>
<span class="nc" id="L4079">					state._fsp--;</span>
<span class="nc bnc" id="L4080" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4081" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, assigns_clause84.getTree());</span>

					}
					break;
				case 2 :
					// AcslParser.g:244:7: ensures_clause
					{
<span class="nc" id="L4088">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4091">					pushFollow(FOLLOW_ensures_clause_in_simple_clause1740);</span>
<span class="nc" id="L4092">					ensures_clause85=ensures_clause();</span>
<span class="nc" id="L4093">					state._fsp--;</span>
<span class="nc bnc" id="L4094" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4095" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, ensures_clause85.getTree());</span>

					}
					break;
				case 3 :
					// AcslParser.g:245:7: allocation_clause
					{
<span class="nc" id="L4102">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4105">					pushFollow(FOLLOW_allocation_clause_in_simple_clause1749);</span>
<span class="nc" id="L4106">					allocation_clause86=allocation_clause();</span>
<span class="nc" id="L4107">					state._fsp--;</span>
<span class="nc bnc" id="L4108" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4109" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, allocation_clause86.getTree());</span>

					}
					break;
				case 4 :
					// AcslParser.g:246:7: reads_clause
					{
<span class="nc" id="L4116">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4119">					pushFollow(FOLLOW_reads_clause_in_simple_clause1757);</span>
<span class="nc" id="L4120">					reads_clause87=reads_clause();</span>
<span class="nc" id="L4121">					state._fsp--;</span>
<span class="nc bnc" id="L4122" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4123" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, reads_clause87.getTree());</span>

					}
					break;
				case 5 :
					// AcslParser.g:247:7: depends_clause
					{
<span class="nc" id="L4130">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4133">					pushFollow(FOLLOW_depends_clause_in_simple_clause1765);</span>
<span class="nc" id="L4134">					depends_clause88=depends_clause();</span>
<span class="nc" id="L4135">					state._fsp--;</span>
<span class="nc bnc" id="L4136" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4137" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, depends_clause88.getTree());</span>

					}
					break;
				case 6 :
					// AcslParser.g:248:7: guards_clause
					{
<span class="nc" id="L4144">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L4147">					pushFollow(FOLLOW_guards_clause_in_simple_clause1773);</span>
<span class="nc" id="L4148">					guards_clause89=guards_clause();</span>
<span class="nc" id="L4149">					state._fsp--;</span>
<span class="nc bnc" id="L4150" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4151" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, guards_clause89.getTree());</span>

					}
					break;

			}
<span class="nc" id="L4157">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4159" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4160">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4161">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4164">		catch (RecognitionException re) {</span>
<span class="nc" id="L4165">			reportError(re);</span>
<span class="nc" id="L4166">			recover(input,re);</span>
<span class="nc" id="L4167">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4169">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4171">		}</span>
<span class="nc" id="L4172">		return retval;</span>
	}
	// $ANTLR end &quot;simple_clause&quot;


<span class="nc" id="L4177">	public static class assigns_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4180">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;assigns_clause&quot;
	// AcslParser.g:251:1: assigns_clause : ASSIGNS argumentExpressionList -&gt; ^( ASSIGNS argumentExpressionList ) ;
	public final AcslParser.assigns_clause_return assigns_clause() throws RecognitionException {
<span class="nc" id="L4187">		AcslParser.assigns_clause_return retval = new AcslParser.assigns_clause_return();</span>
<span class="nc" id="L4188">		retval.start = input.LT(1);</span>

<span class="nc" id="L4190">		Object root_0 = null;</span>

<span class="nc" id="L4192">		Token ASSIGNS90=null;</span>
<span class="nc" id="L4193">		ParserRuleReturnScope argumentExpressionList91 =null;</span>

<span class="nc" id="L4195">		Object ASSIGNS90_tree=null;</span>
<span class="nc" id="L4196">		RewriteRuleTokenStream stream_ASSIGNS=new RewriteRuleTokenStream(adaptor,&quot;token ASSIGNS&quot;);</span>
<span class="nc" id="L4197">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:252:5: ( ASSIGNS argumentExpressionList -&gt; ^( ASSIGNS argumentExpressionList ) )
			// AcslParser.g:252:7: ASSIGNS argumentExpressionList
			{
<span class="nc bnc" id="L4203" title="All 2 branches missed.">			ASSIGNS90=(Token)match(input,ASSIGNS,FOLLOW_ASSIGNS_in_assigns_clause1790); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4204" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ASSIGNS.add(ASSIGNS90);</span>

<span class="nc" id="L4206">			pushFollow(FOLLOW_argumentExpressionList_in_assigns_clause1792);</span>
<span class="nc" id="L4207">			argumentExpressionList91=argumentExpressionList();</span>
<span class="nc" id="L4208">			state._fsp--;</span>
<span class="nc bnc" id="L4209" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L4210" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList91.getTree());</span>
			// AST REWRITE
			// elements: argumentExpressionList, ASSIGNS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L4218" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4219">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4220" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4222">			root_0 = (Object)adaptor.nil();</span>
			// 252:38: -&gt; ^( ASSIGNS argumentExpressionList )
			{
				// AcslParser.g:252:40: ^( ASSIGNS argumentExpressionList )
				{
<span class="nc" id="L4227">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4228">				root_1 = (Object)adaptor.becomeRoot(stream_ASSIGNS.nextNode(), root_1);</span>
<span class="nc" id="L4229">				adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L4230">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4236">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L4241">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4243" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4244">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4245">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4248">		catch (RecognitionException re) {</span>
<span class="nc" id="L4249">			reportError(re);</span>
<span class="nc" id="L4250">			recover(input,re);</span>
<span class="nc" id="L4251">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4253">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4255">		}</span>
<span class="nc" id="L4256">		return retval;</span>
	}
	// $ANTLR end &quot;assigns_clause&quot;


<span class="nc" id="L4261">	public static class ensures_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4264">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;ensures_clause&quot;
	// AcslParser.g:255:1: ensures_clause : ENSURES term -&gt; ^( ENSURES term ) ;
	public final AcslParser.ensures_clause_return ensures_clause() throws RecognitionException {
<span class="nc" id="L4271">		AcslParser.ensures_clause_return retval = new AcslParser.ensures_clause_return();</span>
<span class="nc" id="L4272">		retval.start = input.LT(1);</span>

<span class="nc" id="L4274">		Object root_0 = null;</span>

<span class="nc" id="L4276">		Token ENSURES92=null;</span>
<span class="nc" id="L4277">		ParserRuleReturnScope term93 =null;</span>

<span class="nc" id="L4279">		Object ENSURES92_tree=null;</span>
<span class="nc" id="L4280">		RewriteRuleTokenStream stream_ENSURES=new RewriteRuleTokenStream(adaptor,&quot;token ENSURES&quot;);</span>
<span class="nc" id="L4281">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:256:5: ( ENSURES term -&gt; ^( ENSURES term ) )
			// AcslParser.g:256:7: ENSURES term
			{
<span class="nc bnc" id="L4287" title="All 2 branches missed.">			ENSURES92=(Token)match(input,ENSURES,FOLLOW_ENSURES_in_ensures_clause1816); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4288" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ENSURES.add(ENSURES92);</span>

<span class="nc" id="L4290">			pushFollow(FOLLOW_term_in_ensures_clause1818);</span>
<span class="nc" id="L4291">			term93=term();</span>
<span class="nc" id="L4292">			state._fsp--;</span>
<span class="nc bnc" id="L4293" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L4294" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term93.getTree());</span>
			// AST REWRITE
			// elements: ENSURES, term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L4302" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4303">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4304" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4306">			root_0 = (Object)adaptor.nil();</span>
			// 256:20: -&gt; ^( ENSURES term )
			{
				// AcslParser.g:256:22: ^( ENSURES term )
				{
<span class="nc" id="L4311">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4312">				root_1 = (Object)adaptor.becomeRoot(stream_ENSURES.nextNode(), root_1);</span>
<span class="nc" id="L4313">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L4314">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4320">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L4325">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4327" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4328">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4329">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4332">		catch (RecognitionException re) {</span>
<span class="nc" id="L4333">			reportError(re);</span>
<span class="nc" id="L4334">			recover(input,re);</span>
<span class="nc" id="L4335">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4337">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4339">		}</span>
<span class="nc" id="L4340">		return retval;</span>
	}
	// $ANTLR end &quot;ensures_clause&quot;


<span class="nc" id="L4345">	public static class allocation_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4348">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;allocation_clause&quot;
	// AcslParser.g:259:1: allocation_clause : ( ALLOC argumentExpressionList ( COMMA term )? -&gt; ^( ALLOC argumentExpressionList ( term )? ) | FREES argumentExpressionList -&gt; ^( FREES argumentExpressionList ) );
	public final AcslParser.allocation_clause_return allocation_clause() throws RecognitionException {
<span class="nc" id="L4355">		AcslParser.allocation_clause_return retval = new AcslParser.allocation_clause_return();</span>
<span class="nc" id="L4356">		retval.start = input.LT(1);</span>

<span class="nc" id="L4358">		Object root_0 = null;</span>

<span class="nc" id="L4360">		Token ALLOC94=null;</span>
<span class="nc" id="L4361">		Token COMMA96=null;</span>
<span class="nc" id="L4362">		Token FREES98=null;</span>
<span class="nc" id="L4363">		ParserRuleReturnScope argumentExpressionList95 =null;</span>
<span class="nc" id="L4364">		ParserRuleReturnScope term97 =null;</span>
<span class="nc" id="L4365">		ParserRuleReturnScope argumentExpressionList99 =null;</span>

<span class="nc" id="L4367">		Object ALLOC94_tree=null;</span>
<span class="nc" id="L4368">		Object COMMA96_tree=null;</span>
<span class="nc" id="L4369">		Object FREES98_tree=null;</span>
<span class="nc" id="L4370">		RewriteRuleTokenStream stream_FREES=new RewriteRuleTokenStream(adaptor,&quot;token FREES&quot;);</span>
<span class="nc" id="L4371">		RewriteRuleTokenStream stream_ALLOC=new RewriteRuleTokenStream(adaptor,&quot;token ALLOC&quot;);</span>
<span class="nc" id="L4372">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L4373">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L4374">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:260:5: ( ALLOC argumentExpressionList ( COMMA term )? -&gt; ^( ALLOC argumentExpressionList ( term )? ) | FREES argumentExpressionList -&gt; ^( FREES argumentExpressionList ) )
<span class="nc" id="L4378">			int alt28=2;</span>
<span class="nc" id="L4379">			int LA28_0 = input.LA(1);</span>
<span class="nc bnc" id="L4380" title="All 2 branches missed.">			if ( (LA28_0==ALLOC) ) {</span>
<span class="nc" id="L4381">				alt28=1;</span>
			}
<span class="nc bnc" id="L4383" title="All 2 branches missed.">			else if ( (LA28_0==FREES) ) {</span>
<span class="nc" id="L4384">				alt28=2;</span>
			}

			else {
<span class="nc bnc" id="L4388" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L4389">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 28, 0, input);
<span class="nc" id="L4391">				throw nvae;</span>
			}

<span class="nc bnc" id="L4394" title="All 3 branches missed.">			switch (alt28) {</span>
				case 1 :
					// AcslParser.g:260:7: ALLOC argumentExpressionList ( COMMA term )?
					{
<span class="nc bnc" id="L4398" title="All 2 branches missed.">					ALLOC94=(Token)match(input,ALLOC,FOLLOW_ALLOC_in_allocation_clause1842); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ALLOC.add(ALLOC94);</span>

<span class="nc" id="L4401">					pushFollow(FOLLOW_argumentExpressionList_in_allocation_clause1844);</span>
<span class="nc" id="L4402">					argumentExpressionList95=argumentExpressionList();</span>
<span class="nc" id="L4403">					state._fsp--;</span>
<span class="nc bnc" id="L4404" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList95.getTree());</span>
					// AcslParser.g:260:36: ( COMMA term )?
<span class="nc" id="L4407">					int alt27=2;</span>
<span class="nc" id="L4408">					int LA27_0 = input.LA(1);</span>
<span class="nc bnc" id="L4409" title="All 2 branches missed.">					if ( (LA27_0==COMMA) ) {</span>
<span class="nc" id="L4410">						alt27=1;</span>
					}
<span class="nc bnc" id="L4412" title="All 2 branches missed.">					switch (alt27) {</span>
						case 1 :
							// AcslParser.g:260:37: COMMA term
							{
<span class="nc bnc" id="L4416" title="All 2 branches missed.">							COMMA96=(Token)match(input,COMMA,FOLLOW_COMMA_in_allocation_clause1847); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4417" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_COMMA.add(COMMA96);</span>

<span class="nc" id="L4419">							pushFollow(FOLLOW_term_in_allocation_clause1849);</span>
<span class="nc" id="L4420">							term97=term();</span>
<span class="nc" id="L4421">							state._fsp--;</span>
<span class="nc bnc" id="L4422" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L4423" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_term.add(term97.getTree());</span>
							}
							break;

					}

					// AST REWRITE
					// elements: argumentExpressionList, term, ALLOC
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L4436" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4437">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4438" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4440">					root_0 = (Object)adaptor.nil();</span>
					// 260:50: -&gt; ^( ALLOC argumentExpressionList ( term )? )
					{
						// AcslParser.g:260:52: ^( ALLOC argumentExpressionList ( term )? )
						{
<span class="nc" id="L4445">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4446">						root_1 = (Object)adaptor.becomeRoot(stream_ALLOC.nextNode(), root_1);</span>
<span class="nc" id="L4447">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
						// AcslParser.g:260:83: ( term )?
<span class="nc bnc" id="L4449" title="All 2 branches missed.">						if ( stream_term.hasNext() ) {</span>
<span class="nc" id="L4450">							adaptor.addChild(root_1, stream_term.nextTree());</span>
						}
<span class="nc" id="L4452">						stream_term.reset();</span>

<span class="nc" id="L4454">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4460">					retval.tree = root_0;</span>
					}

					}
<span class="nc" id="L4464">					break;</span>
				case 2 :
					// AcslParser.g:261:7: FREES argumentExpressionList
					{
<span class="nc bnc" id="L4468" title="All 2 branches missed.">					FREES98=(Token)match(input,FREES,FOLLOW_FREES_in_allocation_clause1869); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4469" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_FREES.add(FREES98);</span>

<span class="nc" id="L4471">					pushFollow(FOLLOW_argumentExpressionList_in_allocation_clause1871);</span>
<span class="nc" id="L4472">					argumentExpressionList99=argumentExpressionList();</span>
<span class="nc" id="L4473">					state._fsp--;</span>
<span class="nc bnc" id="L4474" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4475" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList99.getTree());</span>
					// AST REWRITE
					// elements: argumentExpressionList, FREES
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L4483" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4484">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4485" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4487">					root_0 = (Object)adaptor.nil();</span>
					// 261:36: -&gt; ^( FREES argumentExpressionList )
					{
						// AcslParser.g:261:38: ^( FREES argumentExpressionList )
						{
<span class="nc" id="L4492">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4493">						root_1 = (Object)adaptor.becomeRoot(stream_FREES.nextNode(), root_1);</span>
<span class="nc" id="L4494">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L4495">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4501">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L4508">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4510" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4511">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4512">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4515">		catch (RecognitionException re) {</span>
<span class="nc" id="L4516">			reportError(re);</span>
<span class="nc" id="L4517">			recover(input,re);</span>
<span class="nc" id="L4518">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4520">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4522">		}</span>
<span class="nc" id="L4523">		return retval;</span>
	}
	// $ANTLR end &quot;allocation_clause&quot;


<span class="nc" id="L4528">	public static class reads_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4531">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;reads_clause&quot;
	// AcslParser.g:264:1: reads_clause : READS argumentExpressionList -&gt; ^( READS argumentExpressionList ) ;
	public final AcslParser.reads_clause_return reads_clause() throws RecognitionException {
<span class="nc" id="L4538">		AcslParser.reads_clause_return retval = new AcslParser.reads_clause_return();</span>
<span class="nc" id="L4539">		retval.start = input.LT(1);</span>

<span class="nc" id="L4541">		Object root_0 = null;</span>

<span class="nc" id="L4543">		Token READS100=null;</span>
<span class="nc" id="L4544">		ParserRuleReturnScope argumentExpressionList101 =null;</span>

<span class="nc" id="L4546">		Object READS100_tree=null;</span>
<span class="nc" id="L4547">		RewriteRuleTokenStream stream_READS=new RewriteRuleTokenStream(adaptor,&quot;token READS&quot;);</span>
<span class="nc" id="L4548">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:265:5: ( READS argumentExpressionList -&gt; ^( READS argumentExpressionList ) )
			// AcslParser.g:265:7: READS argumentExpressionList
			{
<span class="nc bnc" id="L4554" title="All 2 branches missed.">			READS100=(Token)match(input,READS,FOLLOW_READS_in_reads_clause1895); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4555" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_READS.add(READS100);</span>

<span class="nc" id="L4557">			pushFollow(FOLLOW_argumentExpressionList_in_reads_clause1897);</span>
<span class="nc" id="L4558">			argumentExpressionList101=argumentExpressionList();</span>
<span class="nc" id="L4559">			state._fsp--;</span>
<span class="nc bnc" id="L4560" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L4561" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList101.getTree());</span>
			// AST REWRITE
			// elements: argumentExpressionList, READS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L4569" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4570">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4571" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4573">			root_0 = (Object)adaptor.nil();</span>
			// 265:36: -&gt; ^( READS argumentExpressionList )
			{
				// AcslParser.g:265:38: ^( READS argumentExpressionList )
				{
<span class="nc" id="L4578">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4579">				root_1 = (Object)adaptor.becomeRoot(stream_READS.nextNode(), root_1);</span>
<span class="nc" id="L4580">				adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L4581">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4587">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L4592">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4594" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4595">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4596">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4599">		catch (RecognitionException re) {</span>
<span class="nc" id="L4600">			reportError(re);</span>
<span class="nc" id="L4601">			recover(input,re);</span>
<span class="nc" id="L4602">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4604">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4606">		}</span>
<span class="nc" id="L4607">		return retval;</span>
	}
	// $ANTLR end &quot;reads_clause&quot;


<span class="nc" id="L4612">	public static class depends_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4615">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;depends_clause&quot;
	// AcslParser.g:272:1: depends_clause : DEPENDS event_list -&gt; ^( DEPENDS event_list ) ;
	public final AcslParser.depends_clause_return depends_clause() throws RecognitionException {
<span class="nc" id="L4622">		AcslParser.depends_clause_return retval = new AcslParser.depends_clause_return();</span>
<span class="nc" id="L4623">		retval.start = input.LT(1);</span>

<span class="nc" id="L4625">		Object root_0 = null;</span>

<span class="nc" id="L4627">		Token DEPENDS102=null;</span>
<span class="nc" id="L4628">		ParserRuleReturnScope event_list103 =null;</span>

<span class="nc" id="L4630">		Object DEPENDS102_tree=null;</span>
<span class="nc" id="L4631">		RewriteRuleTokenStream stream_DEPENDS=new RewriteRuleTokenStream(adaptor,&quot;token DEPENDS&quot;);</span>
<span class="nc" id="L4632">		RewriteRuleSubtreeStream stream_event_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule event_list&quot;);</span>

		try {
			// AcslParser.g:273:5: ( DEPENDS event_list -&gt; ^( DEPENDS event_list ) )
			// AcslParser.g:273:7: DEPENDS event_list
			{
<span class="nc bnc" id="L4638" title="All 2 branches missed.">			DEPENDS102=(Token)match(input,DEPENDS,FOLLOW_DEPENDS_in_depends_clause1922); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4639" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_DEPENDS.add(DEPENDS102);</span>

<span class="nc" id="L4641">			pushFollow(FOLLOW_event_list_in_depends_clause1924);</span>
<span class="nc" id="L4642">			event_list103=event_list();</span>
<span class="nc" id="L4643">			state._fsp--;</span>
<span class="nc bnc" id="L4644" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L4645" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_event_list.add(event_list103.getTree());</span>
			// AST REWRITE
			// elements: event_list, DEPENDS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L4653" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4654">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4655" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4657">			root_0 = (Object)adaptor.nil();</span>
			// 273:26: -&gt; ^( DEPENDS event_list )
			{
				// AcslParser.g:273:28: ^( DEPENDS event_list )
				{
<span class="nc" id="L4662">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4663">				root_1 = (Object)adaptor.becomeRoot(stream_DEPENDS.nextNode(), root_1);</span>
<span class="nc" id="L4664">				adaptor.addChild(root_1, stream_event_list.nextTree());</span>
<span class="nc" id="L4665">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4671">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L4676">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4678" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4679">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4680">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4683">		catch (RecognitionException re) {</span>
<span class="nc" id="L4684">			reportError(re);</span>
<span class="nc" id="L4685">			recover(input,re);</span>
<span class="nc" id="L4686">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4688">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4690">		}</span>
<span class="nc" id="L4691">		return retval;</span>
	}
	// $ANTLR end &quot;depends_clause&quot;


<span class="nc" id="L4696">	public static class event_list_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4699">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;event_list&quot;
	// AcslParser.g:276:1: event_list : event ( COMMA event )* -&gt; ^( EVENT_LIST ( event )+ ) ;
	public final AcslParser.event_list_return event_list() throws RecognitionException {
<span class="nc" id="L4706">		AcslParser.event_list_return retval = new AcslParser.event_list_return();</span>
<span class="nc" id="L4707">		retval.start = input.LT(1);</span>

<span class="nc" id="L4709">		Object root_0 = null;</span>

<span class="nc" id="L4711">		Token COMMA105=null;</span>
<span class="nc" id="L4712">		ParserRuleReturnScope event104 =null;</span>
<span class="nc" id="L4713">		ParserRuleReturnScope event106 =null;</span>

<span class="nc" id="L4715">		Object COMMA105_tree=null;</span>
<span class="nc" id="L4716">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L4717">		RewriteRuleSubtreeStream stream_event=new RewriteRuleSubtreeStream(adaptor,&quot;rule event&quot;);</span>

		try {
			// AcslParser.g:277:5: ( event ( COMMA event )* -&gt; ^( EVENT_LIST ( event )+ ) )
			// AcslParser.g:277:7: event ( COMMA event )*
			{
<span class="nc" id="L4723">			pushFollow(FOLLOW_event_in_event_list1948);</span>
<span class="nc" id="L4724">			event104=event();</span>
<span class="nc" id="L4725">			state._fsp--;</span>
<span class="nc bnc" id="L4726" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L4727" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_event.add(event104.getTree());</span>
			// AcslParser.g:277:13: ( COMMA event )*
			loop29:
			while (true) {
<span class="nc" id="L4731">				int alt29=2;</span>
<span class="nc" id="L4732">				int LA29_0 = input.LA(1);</span>
<span class="nc bnc" id="L4733" title="All 2 branches missed.">				if ( (LA29_0==COMMA) ) {</span>
<span class="nc" id="L4734">					alt29=1;</span>
				}

<span class="nc bnc" id="L4737" title="All 2 branches missed.">				switch (alt29) {</span>
				case 1 :
					// AcslParser.g:277:14: COMMA event
					{
<span class="nc bnc" id="L4741" title="All 2 branches missed.">					COMMA105=(Token)match(input,COMMA,FOLLOW_COMMA_in_event_list1951); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA105);</span>

<span class="nc" id="L4744">					pushFollow(FOLLOW_event_in_event_list1953);</span>
<span class="nc" id="L4745">					event106=event();</span>
<span class="nc" id="L4746">					state._fsp--;</span>
<span class="nc bnc" id="L4747" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4748" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event.add(event106.getTree());</span>
					}
					break;

				default :
<span class="nc" id="L4753">					break loop29;</span>
				}
<span class="nc" id="L4755">			}</span>

			// AST REWRITE
			// elements: event
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L4764" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4765">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4766" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4768">			root_0 = (Object)adaptor.nil();</span>
			// 277:28: -&gt; ^( EVENT_LIST ( event )+ )
			{
				// AcslParser.g:277:31: ^( EVENT_LIST ( event )+ )
				{
<span class="nc" id="L4773">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4774">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_LIST, &quot;EVENT_LIST&quot;), root_1);</span>
<span class="nc bnc" id="L4775" title="All 2 branches missed.">				if ( !(stream_event.hasNext()) ) {</span>
<span class="nc" id="L4776">					throw new RewriteEarlyExitException();</span>
				}
<span class="nc bnc" id="L4778" title="All 2 branches missed.">				while ( stream_event.hasNext() ) {</span>
<span class="nc" id="L4779">					adaptor.addChild(root_1, stream_event.nextTree());</span>
				}
<span class="nc" id="L4781">				stream_event.reset();</span>

<span class="nc" id="L4783">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4789">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L4794">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L4796" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L4797">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4798">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L4801">		catch (RecognitionException re) {</span>
<span class="nc" id="L4802">			reportError(re);</span>
<span class="nc" id="L4803">			recover(input,re);</span>
<span class="nc" id="L4804">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4806">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4808">		}</span>
<span class="nc" id="L4809">		return retval;</span>
	}
	// $ANTLR end &quot;event_list&quot;


<span class="nc" id="L4814">	public static class event_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4817">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;event&quot;
	// AcslParser.g:280:1: event : ( event_base PLUS event_base -&gt; ^( EVENT_PLUS event_base event_base ) | event_base SUB event_base -&gt; ^( EVENT_SUB event_base event_base ) | event_base AMPERSAND event_base -&gt; ^( EVENT_INTS event_base event_base ) | event_base -&gt; ^( EVENT_BASE event_base ) );
	public final AcslParser.event_return event() throws RecognitionException {
<span class="nc" id="L4824">		AcslParser.event_return retval = new AcslParser.event_return();</span>
<span class="nc" id="L4825">		retval.start = input.LT(1);</span>

<span class="nc" id="L4827">		Object root_0 = null;</span>

<span class="nc" id="L4829">		Token PLUS108=null;</span>
<span class="nc" id="L4830">		Token SUB111=null;</span>
<span class="nc" id="L4831">		Token AMPERSAND114=null;</span>
<span class="nc" id="L4832">		ParserRuleReturnScope event_base107 =null;</span>
<span class="nc" id="L4833">		ParserRuleReturnScope event_base109 =null;</span>
<span class="nc" id="L4834">		ParserRuleReturnScope event_base110 =null;</span>
<span class="nc" id="L4835">		ParserRuleReturnScope event_base112 =null;</span>
<span class="nc" id="L4836">		ParserRuleReturnScope event_base113 =null;</span>
<span class="nc" id="L4837">		ParserRuleReturnScope event_base115 =null;</span>
<span class="nc" id="L4838">		ParserRuleReturnScope event_base116 =null;</span>

<span class="nc" id="L4840">		Object PLUS108_tree=null;</span>
<span class="nc" id="L4841">		Object SUB111_tree=null;</span>
<span class="nc" id="L4842">		Object AMPERSAND114_tree=null;</span>
<span class="nc" id="L4843">		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,&quot;token AMPERSAND&quot;);</span>
<span class="nc" id="L4844">		RewriteRuleTokenStream stream_SUB=new RewriteRuleTokenStream(adaptor,&quot;token SUB&quot;);</span>
<span class="nc" id="L4845">		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,&quot;token PLUS&quot;);</span>
<span class="nc" id="L4846">		RewriteRuleSubtreeStream stream_event_base=new RewriteRuleSubtreeStream(adaptor,&quot;rule event_base&quot;);</span>

		try {
			// AcslParser.g:281:5: ( event_base PLUS event_base -&gt; ^( EVENT_PLUS event_base event_base ) | event_base SUB event_base -&gt; ^( EVENT_SUB event_base event_base ) | event_base AMPERSAND event_base -&gt; ^( EVENT_INTS event_base event_base ) | event_base -&gt; ^( EVENT_BASE event_base ) )
<span class="nc" id="L4850">			int alt30=4;</span>
<span class="nc bnc" id="L4851" title="All 8 branches missed.">			switch ( input.LA(1) ) {</span>
			case READ:
				{
<span class="nc" id="L4854">				int LA30_1 = input.LA(2);</span>
<span class="nc bnc" id="L4855" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4856">					alt30=1;</span>
				}
<span class="nc bnc" id="L4858" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4859">					alt30=2;</span>
				}
<span class="nc bnc" id="L4861" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4862">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4865">					alt30=4;</span>
				}

				}
<span class="nc" id="L4869">				break;</span>
			case WRITE:
				{
<span class="nc" id="L4872">				int LA30_2 = input.LA(2);</span>
<span class="nc bnc" id="L4873" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4874">					alt30=1;</span>
				}
<span class="nc bnc" id="L4876" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4877">					alt30=2;</span>
				}
<span class="nc bnc" id="L4879" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4880">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4883">					alt30=4;</span>
				}

				}
<span class="nc" id="L4887">				break;</span>
			case REACH:
				{
<span class="nc" id="L4890">				int LA30_3 = input.LA(2);</span>
<span class="nc bnc" id="L4891" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4892">					alt30=1;</span>
				}
<span class="nc bnc" id="L4894" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4895">					alt30=2;</span>
				}
<span class="nc bnc" id="L4897" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4898">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4901">					alt30=4;</span>
				}

				}
<span class="nc" id="L4905">				break;</span>
			case CALL:
				{
<span class="nc" id="L4908">				int LA30_4 = input.LA(2);</span>
<span class="nc bnc" id="L4909" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4910">					alt30=1;</span>
				}
<span class="nc bnc" id="L4912" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4913">					alt30=2;</span>
				}
<span class="nc bnc" id="L4915" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4916">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4919">					alt30=4;</span>
				}

				}
<span class="nc" id="L4923">				break;</span>
			case NOACT:
				{
<span class="nc" id="L4926">				int LA30_5 = input.LA(2);</span>
<span class="nc bnc" id="L4927" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4928">					alt30=1;</span>
				}
<span class="nc bnc" id="L4930" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4931">					alt30=2;</span>
				}
<span class="nc bnc" id="L4933" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4934">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4937">					alt30=4;</span>
				}

				}
<span class="nc" id="L4941">				break;</span>
			case ANYACT:
				{
<span class="nc" id="L4944">				int LA30_6 = input.LA(2);</span>
<span class="nc bnc" id="L4945" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4946">					alt30=1;</span>
				}
<span class="nc bnc" id="L4948" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4949">					alt30=2;</span>
				}
<span class="nc bnc" id="L4951" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4952">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4955">					alt30=4;</span>
				}

				}
<span class="nc" id="L4959">				break;</span>
			case LPAREN:
				{
<span class="nc" id="L4962">				int LA30_7 = input.LA(2);</span>
<span class="nc bnc" id="L4963" title="All 2 branches missed.">				if ( (synpred50_AcslParser()) ) {</span>
<span class="nc" id="L4964">					alt30=1;</span>
				}
<span class="nc bnc" id="L4966" title="All 2 branches missed.">				else if ( (synpred51_AcslParser()) ) {</span>
<span class="nc" id="L4967">					alt30=2;</span>
				}
<span class="nc bnc" id="L4969" title="All 2 branches missed.">				else if ( (synpred52_AcslParser()) ) {</span>
<span class="nc" id="L4970">					alt30=3;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L4973">					alt30=4;</span>
				}

				}
<span class="nc" id="L4977">				break;</span>
			default:
<span class="nc bnc" id="L4979" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L4980">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 30, 0, input);
<span class="nc" id="L4982">				throw nvae;</span>
			}
<span class="nc bnc" id="L4984" title="All 5 branches missed.">			switch (alt30) {</span>
				case 1 :
					// AcslParser.g:281:7: event_base PLUS event_base
					{
<span class="nc" id="L4988">					pushFollow(FOLLOW_event_base_in_event1981);</span>
<span class="nc" id="L4989">					event_base107=event_base();</span>
<span class="nc" id="L4990">					state._fsp--;</span>
<span class="nc bnc" id="L4991" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L4992" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base107.getTree());</span>
<span class="nc bnc" id="L4993" title="All 2 branches missed.">					PLUS108=(Token)match(input,PLUS,FOLLOW_PLUS_in_event1983); if (state.failed) return retval; </span>
<span class="nc bnc" id="L4994" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_PLUS.add(PLUS108);</span>

<span class="nc" id="L4996">					pushFollow(FOLLOW_event_base_in_event1985);</span>
<span class="nc" id="L4997">					event_base109=event_base();</span>
<span class="nc" id="L4998">					state._fsp--;</span>
<span class="nc bnc" id="L4999" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5000" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base109.getTree());</span>
					// AST REWRITE
					// elements: event_base, event_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5008" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5009">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5010" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5012">					root_0 = (Object)adaptor.nil();</span>
					// 282:9: -&gt; ^( EVENT_PLUS event_base event_base )
					{
						// AcslParser.g:282:12: ^( EVENT_PLUS event_base event_base )
						{
<span class="nc" id="L5017">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5018">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_PLUS, &quot;EVENT_PLUS&quot;), root_1);</span>
<span class="nc" id="L5019">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5020">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5021">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5027">					retval.tree = root_0;</span>
<span class="nc" id="L5028">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:283:7: event_base SUB event_base
					{
<span class="nc" id="L5035">					pushFollow(FOLLOW_event_base_in_event2011);</span>
<span class="nc" id="L5036">					event_base110=event_base();</span>
<span class="nc" id="L5037">					state._fsp--;</span>
<span class="nc bnc" id="L5038" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5039" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base110.getTree());</span>
<span class="nc bnc" id="L5040" title="All 2 branches missed.">					SUB111=(Token)match(input,SUB,FOLLOW_SUB_in_event2013); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5041" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SUB.add(SUB111);</span>

<span class="nc" id="L5043">					pushFollow(FOLLOW_event_base_in_event2015);</span>
<span class="nc" id="L5044">					event_base112=event_base();</span>
<span class="nc" id="L5045">					state._fsp--;</span>
<span class="nc bnc" id="L5046" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5047" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base112.getTree());</span>
					// AST REWRITE
					// elements: event_base, event_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5055" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5056">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5057" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5059">					root_0 = (Object)adaptor.nil();</span>
					// 284:9: -&gt; ^( EVENT_SUB event_base event_base )
					{
						// AcslParser.g:284:12: ^( EVENT_SUB event_base event_base )
						{
<span class="nc" id="L5064">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5065">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_SUB, &quot;EVENT_SUB&quot;), root_1);</span>
<span class="nc" id="L5066">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5067">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5068">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5074">					retval.tree = root_0;</span>
<span class="nc" id="L5075">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:285:7: event_base AMPERSAND event_base
					{
<span class="nc" id="L5082">					pushFollow(FOLLOW_event_base_in_event2041);</span>
<span class="nc" id="L5083">					event_base113=event_base();</span>
<span class="nc" id="L5084">					state._fsp--;</span>
<span class="nc bnc" id="L5085" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5086" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base113.getTree());</span>
<span class="nc bnc" id="L5087" title="All 2 branches missed.">					AMPERSAND114=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_event2043); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5088" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND114);</span>

<span class="nc" id="L5090">					pushFollow(FOLLOW_event_base_in_event2045);</span>
<span class="nc" id="L5091">					event_base115=event_base();</span>
<span class="nc" id="L5092">					state._fsp--;</span>
<span class="nc bnc" id="L5093" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5094" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base115.getTree());</span>
					// AST REWRITE
					// elements: event_base, event_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5102" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5103">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5104" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5106">					root_0 = (Object)adaptor.nil();</span>
					// 286:9: -&gt; ^( EVENT_INTS event_base event_base )
					{
						// AcslParser.g:286:12: ^( EVENT_INTS event_base event_base )
						{
<span class="nc" id="L5111">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5112">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_INTS, &quot;EVENT_INTS&quot;), root_1);</span>
<span class="nc" id="L5113">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5114">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5115">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5121">					retval.tree = root_0;</span>
<span class="nc" id="L5122">					}</span>

					}
					break;
				case 4 :
					// AcslParser.g:287:7: event_base
					{
<span class="nc" id="L5129">					pushFollow(FOLLOW_event_base_in_event2071);</span>
<span class="nc" id="L5130">					event_base116=event_base();</span>
<span class="nc" id="L5131">					state._fsp--;</span>
<span class="nc bnc" id="L5132" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5133" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event_base.add(event_base116.getTree());</span>
					// AST REWRITE
					// elements: event_base
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5141" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5142">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5143" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5145">					root_0 = (Object)adaptor.nil();</span>
					// 288:9: -&gt; ^( EVENT_BASE event_base )
					{
						// AcslParser.g:288:12: ^( EVENT_BASE event_base )
						{
<span class="nc" id="L5150">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5151">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_BASE, &quot;EVENT_BASE&quot;), root_1);</span>
<span class="nc" id="L5152">						adaptor.addChild(root_1, stream_event_base.nextTree());</span>
<span class="nc" id="L5153">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5159">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L5166">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L5168" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5169">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5170">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L5173">		catch (RecognitionException re) {</span>
<span class="nc" id="L5174">			reportError(re);</span>
<span class="nc" id="L5175">			recover(input,re);</span>
<span class="nc" id="L5176">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5178">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5180">		}</span>
<span class="nc" id="L5181">		return retval;</span>
	}
	// $ANTLR end &quot;event&quot;


<span class="nc" id="L5186">	public static class event_base_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5189">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;event_base&quot;
	// AcslParser.g:291:1: event_base : ( READ LPAREN argumentExpressionList RPAREN -&gt; ^( READ argumentExpressionList ) | WRITE LPAREN argumentExpressionList RPAREN -&gt; ^( WRITE argumentExpressionList ) | REACH LPAREN argumentExpressionList RPAREN -&gt; ^( REACH argumentExpressionList ) | CALL LPAREN ID ( COMMA argumentExpressionList )? RPAREN -&gt; ^( CALL ID ( argumentExpressionList )? ) | NOACT -&gt; ^( NOACT ) | ANYACT -&gt; ^( ANYACT ) | LPAREN event RPAREN -&gt; ^( EVENT_PARENTHESIZED event ) );
	public final AcslParser.event_base_return event_base() throws RecognitionException {
<span class="nc" id="L5196">		AcslParser.event_base_return retval = new AcslParser.event_base_return();</span>
<span class="nc" id="L5197">		retval.start = input.LT(1);</span>

<span class="nc" id="L5199">		Object root_0 = null;</span>

<span class="nc" id="L5201">		Token READ117=null;</span>
<span class="nc" id="L5202">		Token LPAREN118=null;</span>
<span class="nc" id="L5203">		Token RPAREN120=null;</span>
<span class="nc" id="L5204">		Token WRITE121=null;</span>
<span class="nc" id="L5205">		Token LPAREN122=null;</span>
<span class="nc" id="L5206">		Token RPAREN124=null;</span>
<span class="nc" id="L5207">		Token REACH125=null;</span>
<span class="nc" id="L5208">		Token LPAREN126=null;</span>
<span class="nc" id="L5209">		Token RPAREN128=null;</span>
<span class="nc" id="L5210">		Token CALL129=null;</span>
<span class="nc" id="L5211">		Token LPAREN130=null;</span>
<span class="nc" id="L5212">		Token ID131=null;</span>
<span class="nc" id="L5213">		Token COMMA132=null;</span>
<span class="nc" id="L5214">		Token RPAREN134=null;</span>
<span class="nc" id="L5215">		Token NOACT135=null;</span>
<span class="nc" id="L5216">		Token ANYACT136=null;</span>
<span class="nc" id="L5217">		Token LPAREN137=null;</span>
<span class="nc" id="L5218">		Token RPAREN139=null;</span>
<span class="nc" id="L5219">		ParserRuleReturnScope argumentExpressionList119 =null;</span>
<span class="nc" id="L5220">		ParserRuleReturnScope argumentExpressionList123 =null;</span>
<span class="nc" id="L5221">		ParserRuleReturnScope argumentExpressionList127 =null;</span>
<span class="nc" id="L5222">		ParserRuleReturnScope argumentExpressionList133 =null;</span>
<span class="nc" id="L5223">		ParserRuleReturnScope event138 =null;</span>

<span class="nc" id="L5225">		Object READ117_tree=null;</span>
<span class="nc" id="L5226">		Object LPAREN118_tree=null;</span>
<span class="nc" id="L5227">		Object RPAREN120_tree=null;</span>
<span class="nc" id="L5228">		Object WRITE121_tree=null;</span>
<span class="nc" id="L5229">		Object LPAREN122_tree=null;</span>
<span class="nc" id="L5230">		Object RPAREN124_tree=null;</span>
<span class="nc" id="L5231">		Object REACH125_tree=null;</span>
<span class="nc" id="L5232">		Object LPAREN126_tree=null;</span>
<span class="nc" id="L5233">		Object RPAREN128_tree=null;</span>
<span class="nc" id="L5234">		Object CALL129_tree=null;</span>
<span class="nc" id="L5235">		Object LPAREN130_tree=null;</span>
<span class="nc" id="L5236">		Object ID131_tree=null;</span>
<span class="nc" id="L5237">		Object COMMA132_tree=null;</span>
<span class="nc" id="L5238">		Object RPAREN134_tree=null;</span>
<span class="nc" id="L5239">		Object NOACT135_tree=null;</span>
<span class="nc" id="L5240">		Object ANYACT136_tree=null;</span>
<span class="nc" id="L5241">		Object LPAREN137_tree=null;</span>
<span class="nc" id="L5242">		Object RPAREN139_tree=null;</span>
<span class="nc" id="L5243">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5244">		RewriteRuleTokenStream stream_NOACT=new RewriteRuleTokenStream(adaptor,&quot;token NOACT&quot;);</span>
<span class="nc" id="L5245">		RewriteRuleTokenStream stream_REACH=new RewriteRuleTokenStream(adaptor,&quot;token REACH&quot;);</span>
<span class="nc" id="L5246">		RewriteRuleTokenStream stream_CALL=new RewriteRuleTokenStream(adaptor,&quot;token CALL&quot;);</span>
<span class="nc" id="L5247">		RewriteRuleTokenStream stream_ANYACT=new RewriteRuleTokenStream(adaptor,&quot;token ANYACT&quot;);</span>
<span class="nc" id="L5248">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L5249">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L5250">		RewriteRuleTokenStream stream_READ=new RewriteRuleTokenStream(adaptor,&quot;token READ&quot;);</span>
<span class="nc" id="L5251">		RewriteRuleTokenStream stream_WRITE=new RewriteRuleTokenStream(adaptor,&quot;token WRITE&quot;);</span>
<span class="nc" id="L5252">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5253">		RewriteRuleSubtreeStream stream_event=new RewriteRuleSubtreeStream(adaptor,&quot;rule event&quot;);</span>
<span class="nc" id="L5254">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>

		try {
			// AcslParser.g:292:5: ( READ LPAREN argumentExpressionList RPAREN -&gt; ^( READ argumentExpressionList ) | WRITE LPAREN argumentExpressionList RPAREN -&gt; ^( WRITE argumentExpressionList ) | REACH LPAREN argumentExpressionList RPAREN -&gt; ^( REACH argumentExpressionList ) | CALL LPAREN ID ( COMMA argumentExpressionList )? RPAREN -&gt; ^( CALL ID ( argumentExpressionList )? ) | NOACT -&gt; ^( NOACT ) | ANYACT -&gt; ^( ANYACT ) | LPAREN event RPAREN -&gt; ^( EVENT_PARENTHESIZED event ) )
<span class="nc" id="L5258">			int alt32=7;</span>
<span class="nc bnc" id="L5259" title="All 8 branches missed.">			switch ( input.LA(1) ) {</span>
			case READ:
				{
<span class="nc" id="L5262">				alt32=1;</span>
				}
<span class="nc" id="L5264">				break;</span>
			case WRITE:
				{
<span class="nc" id="L5267">				alt32=2;</span>
				}
<span class="nc" id="L5269">				break;</span>
			case REACH:
				{
<span class="nc" id="L5272">				alt32=3;</span>
				}
<span class="nc" id="L5274">				break;</span>
			case CALL:
				{
<span class="nc" id="L5277">				alt32=4;</span>
				}
<span class="nc" id="L5279">				break;</span>
			case NOACT:
				{
<span class="nc" id="L5282">				alt32=5;</span>
				}
<span class="nc" id="L5284">				break;</span>
			case ANYACT:
				{
<span class="nc" id="L5287">				alt32=6;</span>
				}
<span class="nc" id="L5289">				break;</span>
			case LPAREN:
				{
<span class="nc" id="L5292">				alt32=7;</span>
				}
<span class="nc" id="L5294">				break;</span>
			default:
<span class="nc bnc" id="L5296" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L5297">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 32, 0, input);
<span class="nc" id="L5299">				throw nvae;</span>
			}
<span class="nc bnc" id="L5301" title="All 8 branches missed.">			switch (alt32) {</span>
				case 1 :
					// AcslParser.g:292:7: READ LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L5305" title="All 2 branches missed.">					READ117=(Token)match(input,READ,FOLLOW_READ_in_event_base2104); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5306" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_READ.add(READ117);</span>

<span class="nc bnc" id="L5308" title="All 2 branches missed.">					LPAREN118=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_base2106); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5309" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN118);</span>

<span class="nc" id="L5311">					pushFollow(FOLLOW_argumentExpressionList_in_event_base2108);</span>
<span class="nc" id="L5312">					argumentExpressionList119=argumentExpressionList();</span>
<span class="nc" id="L5313">					state._fsp--;</span>
<span class="nc bnc" id="L5314" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5315" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList119.getTree());</span>
<span class="nc bnc" id="L5316" title="All 2 branches missed.">					RPAREN120=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_base2110); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5317" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN120);</span>

					// AST REWRITE
					// elements: READ, argumentExpressionList
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5326" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5327">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5328" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5330">					root_0 = (Object)adaptor.nil();</span>
					// 293:9: -&gt; ^( READ argumentExpressionList )
					{
						// AcslParser.g:293:12: ^( READ argumentExpressionList )
						{
<span class="nc" id="L5335">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5336">						root_1 = (Object)adaptor.becomeRoot(stream_READ.nextNode(), root_1);</span>
<span class="nc" id="L5337">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L5338">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5344">					retval.tree = root_0;</span>
<span class="nc" id="L5345">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:294:7: WRITE LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L5352" title="All 2 branches missed.">					WRITE121=(Token)match(input,WRITE,FOLLOW_WRITE_in_event_base2134); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5353" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_WRITE.add(WRITE121);</span>

<span class="nc bnc" id="L5355" title="All 2 branches missed.">					LPAREN122=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_base2136); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5356" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN122);</span>

<span class="nc" id="L5358">					pushFollow(FOLLOW_argumentExpressionList_in_event_base2138);</span>
<span class="nc" id="L5359">					argumentExpressionList123=argumentExpressionList();</span>
<span class="nc" id="L5360">					state._fsp--;</span>
<span class="nc bnc" id="L5361" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5362" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList123.getTree());</span>
<span class="nc bnc" id="L5363" title="All 2 branches missed.">					RPAREN124=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_base2140); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5364" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN124);</span>

					// AST REWRITE
					// elements: argumentExpressionList, WRITE
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5373" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5374">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5375" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5377">					root_0 = (Object)adaptor.nil();</span>
					// 295:9: -&gt; ^( WRITE argumentExpressionList )
					{
						// AcslParser.g:295:12: ^( WRITE argumentExpressionList )
						{
<span class="nc" id="L5382">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5383">						root_1 = (Object)adaptor.becomeRoot(stream_WRITE.nextNode(), root_1);</span>
<span class="nc" id="L5384">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L5385">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5391">					retval.tree = root_0;</span>
<span class="nc" id="L5392">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:296:7: REACH LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L5399" title="All 2 branches missed.">					REACH125=(Token)match(input,REACH,FOLLOW_REACH_in_event_base2164); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5400" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_REACH.add(REACH125);</span>

<span class="nc bnc" id="L5402" title="All 2 branches missed.">					LPAREN126=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_base2166); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5403" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN126);</span>

<span class="nc" id="L5405">					pushFollow(FOLLOW_argumentExpressionList_in_event_base2168);</span>
<span class="nc" id="L5406">					argumentExpressionList127=argumentExpressionList();</span>
<span class="nc" id="L5407">					state._fsp--;</span>
<span class="nc bnc" id="L5408" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5409" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList127.getTree());</span>
<span class="nc bnc" id="L5410" title="All 2 branches missed.">					RPAREN128=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_base2170); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5411" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN128);</span>

					// AST REWRITE
					// elements: argumentExpressionList, REACH
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5420" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5421">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5422" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5424">					root_0 = (Object)adaptor.nil();</span>
					// 297:9: -&gt; ^( REACH argumentExpressionList )
					{
						// AcslParser.g:297:12: ^( REACH argumentExpressionList )
						{
<span class="nc" id="L5429">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5430">						root_1 = (Object)adaptor.becomeRoot(stream_REACH.nextNode(), root_1);</span>
<span class="nc" id="L5431">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L5432">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5438">					retval.tree = root_0;</span>
<span class="nc" id="L5439">					}</span>

					}
					break;
				case 4 :
					// AcslParser.g:298:7: CALL LPAREN ID ( COMMA argumentExpressionList )? RPAREN
					{
<span class="nc bnc" id="L5446" title="All 2 branches missed.">					CALL129=(Token)match(input,CALL,FOLLOW_CALL_in_event_base2194); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5447" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_CALL.add(CALL129);</span>

<span class="nc bnc" id="L5449" title="All 2 branches missed.">					LPAREN130=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_base2196); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5450" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN130);</span>

<span class="nc bnc" id="L5452" title="All 2 branches missed.">					ID131=(Token)match(input,ID,FOLLOW_ID_in_event_base2198); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5453" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID131);</span>

					// AcslParser.g:298:22: ( COMMA argumentExpressionList )?
<span class="nc" id="L5456">					int alt31=2;</span>
<span class="nc" id="L5457">					int LA31_0 = input.LA(1);</span>
<span class="nc bnc" id="L5458" title="All 2 branches missed.">					if ( (LA31_0==COMMA) ) {</span>
<span class="nc" id="L5459">						alt31=1;</span>
					}
<span class="nc bnc" id="L5461" title="All 2 branches missed.">					switch (alt31) {</span>
						case 1 :
							// AcslParser.g:298:23: COMMA argumentExpressionList
							{
<span class="nc bnc" id="L5465" title="All 2 branches missed.">							COMMA132=(Token)match(input,COMMA,FOLLOW_COMMA_in_event_base2201); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5466" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_COMMA.add(COMMA132);</span>

<span class="nc" id="L5468">							pushFollow(FOLLOW_argumentExpressionList_in_event_base2203);</span>
<span class="nc" id="L5469">							argumentExpressionList133=argumentExpressionList();</span>
<span class="nc" id="L5470">							state._fsp--;</span>
<span class="nc bnc" id="L5471" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L5472" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList133.getTree());</span>
							}
							break;

					}

<span class="nc bnc" id="L5478" title="All 2 branches missed.">					RPAREN134=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_base2207); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5479" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN134);</span>

					// AST REWRITE
					// elements: CALL, ID, argumentExpressionList
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5488" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5489">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5490" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5492">					root_0 = (Object)adaptor.nil();</span>
					// 299:9: -&gt; ^( CALL ID ( argumentExpressionList )? )
					{
						// AcslParser.g:299:12: ^( CALL ID ( argumentExpressionList )? )
						{
<span class="nc" id="L5497">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5498">						root_1 = (Object)adaptor.becomeRoot(stream_CALL.nextNode(), root_1);</span>
<span class="nc" id="L5499">						adaptor.addChild(root_1, stream_ID.nextNode());</span>
						// AcslParser.g:299:22: ( argumentExpressionList )?
<span class="nc bnc" id="L5501" title="All 2 branches missed.">						if ( stream_argumentExpressionList.hasNext() ) {</span>
<span class="nc" id="L5502">							adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
						}
<span class="nc" id="L5504">						stream_argumentExpressionList.reset();</span>

<span class="nc" id="L5506">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5512">					retval.tree = root_0;</span>
					}

					}
<span class="nc" id="L5516">					break;</span>
				case 5 :
					// AcslParser.g:300:7: NOACT
					{
<span class="nc bnc" id="L5520" title="All 2 branches missed.">					NOACT135=(Token)match(input,NOACT,FOLLOW_NOACT_in_event_base2234); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5521" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_NOACT.add(NOACT135);</span>

					// AST REWRITE
					// elements: NOACT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5530" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5531">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5532" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5534">					root_0 = (Object)adaptor.nil();</span>
					// 301:9: -&gt; ^( NOACT )
					{
						// AcslParser.g:301:12: ^( NOACT )
						{
<span class="nc" id="L5539">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5540">						root_1 = (Object)adaptor.becomeRoot(stream_NOACT.nextNode(), root_1);</span>
<span class="nc" id="L5541">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5547">					retval.tree = root_0;</span>
<span class="nc" id="L5548">					}</span>

					}
					break;
				case 6 :
					// AcslParser.g:302:7: ANYACT
					{
<span class="nc bnc" id="L5555" title="All 2 branches missed.">					ANYACT136=(Token)match(input,ANYACT,FOLLOW_ANYACT_in_event_base2256); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5556" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ANYACT.add(ANYACT136);</span>

					// AST REWRITE
					// elements: ANYACT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5565" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5566">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5567" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5569">					root_0 = (Object)adaptor.nil();</span>
					// 303:9: -&gt; ^( ANYACT )
					{
						// AcslParser.g:303:12: ^( ANYACT )
						{
<span class="nc" id="L5574">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5575">						root_1 = (Object)adaptor.becomeRoot(stream_ANYACT.nextNode(), root_1);</span>
<span class="nc" id="L5576">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5582">					retval.tree = root_0;</span>
<span class="nc" id="L5583">					}</span>

					}
					break;
				case 7 :
					// AcslParser.g:304:7: LPAREN event RPAREN
					{
<span class="nc bnc" id="L5590" title="All 2 branches missed.">					LPAREN137=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_event_base2278); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5591" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN137);</span>

<span class="nc" id="L5593">					pushFollow(FOLLOW_event_in_event_base2280);</span>
<span class="nc" id="L5594">					event138=event();</span>
<span class="nc" id="L5595">					state._fsp--;</span>
<span class="nc bnc" id="L5596" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5597" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_event.add(event138.getTree());</span>
<span class="nc bnc" id="L5598" title="All 2 branches missed.">					RPAREN139=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_event_base2282); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5599" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN139);</span>

					// AST REWRITE
					// elements: event
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L5608" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5609">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5610" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5612">					root_0 = (Object)adaptor.nil();</span>
					// 305:9: -&gt; ^( EVENT_PARENTHESIZED event )
					{
						// AcslParser.g:305:12: ^( EVENT_PARENTHESIZED event )
						{
<span class="nc" id="L5617">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5618">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(EVENT_PARENTHESIZED, &quot;EVENT_PARENTHESIZED&quot;), root_1);</span>
<span class="nc" id="L5619">						adaptor.addChild(root_1, stream_event.nextTree());</span>
<span class="nc" id="L5620">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5626">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L5633">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L5635" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5636">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5637">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L5640">		catch (RecognitionException re) {</span>
<span class="nc" id="L5641">			reportError(re);</span>
<span class="nc" id="L5642">			recover(input,re);</span>
<span class="nc" id="L5643">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5645">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5647">		}</span>
<span class="nc" id="L5648">		return retval;</span>
	}
	// $ANTLR end &quot;event_base&quot;


<span class="nc" id="L5653">	public static class mpi_collective_block_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5656">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;mpi_collective_block&quot;
	// AcslParser.g:309:1: mpi_collective_block : MPI_COLLECTIVE LPAREN ID COMMA kind= mpi_collective_kind RPAREN COLON c= partial_contract_block -&gt; ^( MPI_COLLECTIVE ID $kind $c) ;
	public final AcslParser.mpi_collective_block_return mpi_collective_block() throws RecognitionException {
<span class="nc" id="L5663">		AcslParser.mpi_collective_block_return retval = new AcslParser.mpi_collective_block_return();</span>
<span class="nc" id="L5664">		retval.start = input.LT(1);</span>

<span class="nc" id="L5666">		Object root_0 = null;</span>

<span class="nc" id="L5668">		Token MPI_COLLECTIVE140=null;</span>
<span class="nc" id="L5669">		Token LPAREN141=null;</span>
<span class="nc" id="L5670">		Token ID142=null;</span>
<span class="nc" id="L5671">		Token COMMA143=null;</span>
<span class="nc" id="L5672">		Token RPAREN144=null;</span>
<span class="nc" id="L5673">		Token COLON145=null;</span>
<span class="nc" id="L5674">		ParserRuleReturnScope kind =null;</span>
<span class="nc" id="L5675">		ParserRuleReturnScope c =null;</span>

<span class="nc" id="L5677">		Object MPI_COLLECTIVE140_tree=null;</span>
<span class="nc" id="L5678">		Object LPAREN141_tree=null;</span>
<span class="nc" id="L5679">		Object ID142_tree=null;</span>
<span class="nc" id="L5680">		Object COMMA143_tree=null;</span>
<span class="nc" id="L5681">		Object RPAREN144_tree=null;</span>
<span class="nc" id="L5682">		Object COLON145_tree=null;</span>
<span class="nc" id="L5683">		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,&quot;token COLON&quot;);</span>
<span class="nc" id="L5684">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5685">		RewriteRuleTokenStream stream_MPI_COLLECTIVE=new RewriteRuleTokenStream(adaptor,&quot;token MPI_COLLECTIVE&quot;);</span>
<span class="nc" id="L5686">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L5687">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L5688">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5689">		RewriteRuleSubtreeStream stream_partial_contract_block=new RewriteRuleSubtreeStream(adaptor,&quot;rule partial_contract_block&quot;);</span>
<span class="nc" id="L5690">		RewriteRuleSubtreeStream stream_mpi_collective_kind=new RewriteRuleSubtreeStream(adaptor,&quot;rule mpi_collective_kind&quot;);</span>

		try {
			// AcslParser.g:310:5: ( MPI_COLLECTIVE LPAREN ID COMMA kind= mpi_collective_kind RPAREN COLON c= partial_contract_block -&gt; ^( MPI_COLLECTIVE ID $kind $c) )
			// AcslParser.g:310:7: MPI_COLLECTIVE LPAREN ID COMMA kind= mpi_collective_kind RPAREN COLON c= partial_contract_block
			{
<span class="nc bnc" id="L5696" title="All 2 branches missed.">			MPI_COLLECTIVE140=(Token)match(input,MPI_COLLECTIVE,FOLLOW_MPI_COLLECTIVE_in_mpi_collective_block2317); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5697" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_MPI_COLLECTIVE.add(MPI_COLLECTIVE140);</span>

<span class="nc bnc" id="L5699" title="All 2 branches missed.">			LPAREN141=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_collective_block2319); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5700" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN141);</span>

<span class="nc bnc" id="L5702" title="All 2 branches missed.">			ID142=(Token)match(input,ID,FOLLOW_ID_in_mpi_collective_block2321); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5703" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ID.add(ID142);</span>

<span class="nc bnc" id="L5705" title="All 2 branches missed.">			COMMA143=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_collective_block2323); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5706" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_COMMA.add(COMMA143);</span>

<span class="nc" id="L5708">			pushFollow(FOLLOW_mpi_collective_kind_in_mpi_collective_block2327);</span>
<span class="nc" id="L5709">			kind=mpi_collective_kind();</span>
<span class="nc" id="L5710">			state._fsp--;</span>
<span class="nc bnc" id="L5711" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L5712" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_mpi_collective_kind.add(kind.getTree());</span>
<span class="nc bnc" id="L5713" title="All 2 branches missed.">			RPAREN144=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_collective_block2330); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5714" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN144);</span>

<span class="nc bnc" id="L5716" title="All 2 branches missed.">			COLON145=(Token)match(input,COLON,FOLLOW_COLON_in_mpi_collective_block2332); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5717" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_COLON.add(COLON145);</span>

<span class="nc" id="L5719">			pushFollow(FOLLOW_partial_contract_block_in_mpi_collective_block2342);</span>
<span class="nc" id="L5720">			c=partial_contract_block();</span>
<span class="nc" id="L5721">			state._fsp--;</span>
<span class="nc bnc" id="L5722" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L5723" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_partial_contract_block.add(c.getTree());</span>
			// AST REWRITE
			// elements: c, ID, MPI_COLLECTIVE, kind
			// token labels: 
			// rule labels: retval, c, kind
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L5731" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5732">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5733" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L5734" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;rule c&quot;,c!=null?c.getTree():null);</span>
<span class="nc bnc" id="L5735" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_kind=new RewriteRuleSubtreeStream(adaptor,&quot;rule kind&quot;,kind!=null?kind.getTree():null);</span>

<span class="nc" id="L5737">			root_0 = (Object)adaptor.nil();</span>
			// 311:32: -&gt; ^( MPI_COLLECTIVE ID $kind $c)
			{
				// AcslParser.g:311:35: ^( MPI_COLLECTIVE ID $kind $c)
				{
<span class="nc" id="L5742">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5743">				root_1 = (Object)adaptor.becomeRoot(stream_MPI_COLLECTIVE.nextNode(), root_1);</span>
<span class="nc" id="L5744">				adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L5745">				adaptor.addChild(root_1, stream_kind.nextTree());</span>
<span class="nc" id="L5746">				adaptor.addChild(root_1, stream_c.nextTree());</span>
<span class="nc" id="L5747">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5753">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L5758">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L5760" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5761">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5762">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L5765">		catch (RecognitionException re) {</span>
<span class="nc" id="L5766">			reportError(re);</span>
<span class="nc" id="L5767">			recover(input,re);</span>
<span class="nc" id="L5768">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5770">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5772">		}</span>
<span class="nc" id="L5773">		return retval;</span>
	}
	// $ANTLR end &quot;mpi_collective_block&quot;


<span class="nc" id="L5778">	public static class named_behavior_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5781">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;named_behavior&quot;
	// AcslParser.g:317:1: named_behavior : BEHAVIOR ID COLON behavior_body -&gt; ^( BEHAVIOR ID behavior_body ) ;
	public final AcslParser.named_behavior_return named_behavior() throws RecognitionException {
<span class="nc" id="L5788">		AcslParser.named_behavior_return retval = new AcslParser.named_behavior_return();</span>
<span class="nc" id="L5789">		retval.start = input.LT(1);</span>

<span class="nc" id="L5791">		Object root_0 = null;</span>

<span class="nc" id="L5793">		Token BEHAVIOR146=null;</span>
<span class="nc" id="L5794">		Token ID147=null;</span>
<span class="nc" id="L5795">		Token COLON148=null;</span>
<span class="nc" id="L5796">		ParserRuleReturnScope behavior_body149 =null;</span>

<span class="nc" id="L5798">		Object BEHAVIOR146_tree=null;</span>
<span class="nc" id="L5799">		Object ID147_tree=null;</span>
<span class="nc" id="L5800">		Object COLON148_tree=null;</span>
<span class="nc" id="L5801">		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,&quot;token COLON&quot;);</span>
<span class="nc" id="L5802">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L5803">		RewriteRuleTokenStream stream_BEHAVIOR=new RewriteRuleTokenStream(adaptor,&quot;token BEHAVIOR&quot;);</span>
<span class="nc" id="L5804">		RewriteRuleSubtreeStream stream_behavior_body=new RewriteRuleSubtreeStream(adaptor,&quot;rule behavior_body&quot;);</span>

		try {
			// AcslParser.g:318:5: ( BEHAVIOR ID COLON behavior_body -&gt; ^( BEHAVIOR ID behavior_body ) )
			// AcslParser.g:318:7: BEHAVIOR ID COLON behavior_body
			{
<span class="nc bnc" id="L5810" title="All 2 branches missed.">			BEHAVIOR146=(Token)match(input,BEHAVIOR,FOLLOW_BEHAVIOR_in_named_behavior2377); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5811" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_BEHAVIOR.add(BEHAVIOR146);</span>

<span class="nc bnc" id="L5813" title="All 2 branches missed.">			ID147=(Token)match(input,ID,FOLLOW_ID_in_named_behavior2379); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5814" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ID.add(ID147);</span>

<span class="nc bnc" id="L5816" title="All 2 branches missed.">			COLON148=(Token)match(input,COLON,FOLLOW_COLON_in_named_behavior2381); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5817" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_COLON.add(COLON148);</span>

<span class="nc" id="L5819">			pushFollow(FOLLOW_behavior_body_in_named_behavior2383);</span>
<span class="nc" id="L5820">			behavior_body149=behavior_body();</span>
<span class="nc" id="L5821">			state._fsp--;</span>
<span class="nc bnc" id="L5822" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L5823" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_behavior_body.add(behavior_body149.getTree());</span>
			// AST REWRITE
			// elements: ID, behavior_body, BEHAVIOR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L5831" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5832">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5833" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5835">			root_0 = (Object)adaptor.nil();</span>
			// 318:39: -&gt; ^( BEHAVIOR ID behavior_body )
			{
				// AcslParser.g:318:41: ^( BEHAVIOR ID behavior_body )
				{
<span class="nc" id="L5840">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5841">				root_1 = (Object)adaptor.becomeRoot(stream_BEHAVIOR.nextNode(), root_1);</span>
<span class="nc" id="L5842">				adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L5843">				adaptor.addChild(root_1, stream_behavior_body.nextTree());</span>
<span class="nc" id="L5844">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5850">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L5855">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L5857" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5858">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5859">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L5862">		catch (RecognitionException re) {</span>
<span class="nc" id="L5863">			reportError(re);</span>
<span class="nc" id="L5864">			recover(input,re);</span>
<span class="nc" id="L5865">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5867">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5869">		}</span>
<span class="nc" id="L5870">		return retval;</span>
	}
	// $ANTLR end &quot;named_behavior&quot;


<span class="nc" id="L5875">	public static class behavior_body_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5878">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;behavior_body&quot;
	// AcslParser.g:321:1: behavior_body : (b+= behavior_clause SEMICOL )+ -&gt; ^( BEHAVIOR_BODY ( $b)+ ) ;
	public final AcslParser.behavior_body_return behavior_body() throws RecognitionException {
<span class="nc" id="L5885">		AcslParser.behavior_body_return retval = new AcslParser.behavior_body_return();</span>
<span class="nc" id="L5886">		retval.start = input.LT(1);</span>

<span class="nc" id="L5888">		Object root_0 = null;</span>

<span class="nc" id="L5890">		Token SEMICOL150=null;</span>
<span class="nc" id="L5891">		List&lt;Object&gt; list_b=null;</span>
<span class="nc" id="L5892">		RuleReturnScope b = null;</span>
<span class="nc" id="L5893">		Object SEMICOL150_tree=null;</span>
<span class="nc" id="L5894">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L5895">		RewriteRuleSubtreeStream stream_behavior_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule behavior_clause&quot;);</span>

		try {
			// AcslParser.g:322:5: ( (b+= behavior_clause SEMICOL )+ -&gt; ^( BEHAVIOR_BODY ( $b)+ ) )
			// AcslParser.g:322:7: (b+= behavior_clause SEMICOL )+
			{
			// AcslParser.g:322:7: (b+= behavior_clause SEMICOL )+
<span class="nc" id="L5902">			int cnt33=0;</span>
			loop33:
			while (true) {
<span class="nc" id="L5905">				int alt33=2;</span>
<span class="nc" id="L5906">				int LA33_0 = input.LA(1);</span>
<span class="nc bnc" id="L5907" title="All 18 branches missed.">				if ( (LA33_0==ALLOC||(LA33_0 &gt;= ASSIGNS &amp;&amp; LA33_0 &lt;= ASSUMES)||LA33_0==DEPENDS||LA33_0==ENSURES||LA33_0==FREES||LA33_0==GUARDS||LA33_0==READS||LA33_0==REQUIRES) ) {</span>
<span class="nc" id="L5908">					alt33=1;</span>
				}

<span class="nc bnc" id="L5911" title="All 2 branches missed.">				switch (alt33) {</span>
				case 1 :
					// AcslParser.g:322:8: b+= behavior_clause SEMICOL
					{
<span class="nc" id="L5915">					pushFollow(FOLLOW_behavior_clause_in_behavior_body2412);</span>
<span class="nc" id="L5916">					b=behavior_clause();</span>
<span class="nc" id="L5917">					state._fsp--;</span>
<span class="nc bnc" id="L5918" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L5919" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_behavior_clause.add(b.getTree());</span>
<span class="nc bnc" id="L5920" title="All 2 branches missed.">					if (list_b==null) list_b=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L5921">					list_b.add(b.getTree());</span>
<span class="nc bnc" id="L5922" title="All 2 branches missed.">					SEMICOL150=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_behavior_body2414); if (state.failed) return retval; </span>
<span class="nc bnc" id="L5923" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL150);</span>

					}
					break;

				default :
<span class="nc bnc" id="L5929" title="All 2 branches missed.">					if ( cnt33 &gt;= 1 ) break loop33;</span>
<span class="nc bnc" id="L5930" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L5931">					EarlyExitException eee = new EarlyExitException(33, input);</span>
<span class="nc" id="L5932">					throw eee;</span>
				}
<span class="nc" id="L5934">				cnt33++;</span>
<span class="nc" id="L5935">			}</span>

			// AST REWRITE
			// elements: b
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: b
			// wildcard labels: 
<span class="nc bnc" id="L5944" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5945">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5946" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L5947">			RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,&quot;token b&quot;,list_b);</span>
<span class="nc" id="L5948">			root_0 = (Object)adaptor.nil();</span>
			// 322:37: -&gt; ^( BEHAVIOR_BODY ( $b)+ )
			{
				// AcslParser.g:322:40: ^( BEHAVIOR_BODY ( $b)+ )
				{
<span class="nc" id="L5953">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5954">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(BEHAVIOR_BODY, &quot;BEHAVIOR_BODY&quot;), root_1);</span>
<span class="nc bnc" id="L5955" title="All 2 branches missed.">				if ( !(stream_b.hasNext()) ) {</span>
<span class="nc" id="L5956">					throw new RewriteEarlyExitException();</span>
				}
<span class="nc bnc" id="L5958" title="All 2 branches missed.">				while ( stream_b.hasNext() ) {</span>
<span class="nc" id="L5959">					adaptor.addChild(root_1, stream_b.nextTree());</span>
				}
<span class="nc" id="L5961">				stream_b.reset();</span>

<span class="nc" id="L5963">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5969">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L5974">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L5976" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L5977">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5978">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L5981">		catch (RecognitionException re) {</span>
<span class="nc" id="L5982">			reportError(re);</span>
<span class="nc" id="L5983">			recover(input,re);</span>
<span class="nc" id="L5984">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5986">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5988">		}</span>
<span class="nc" id="L5989">		return retval;</span>
	}
	// $ANTLR end &quot;behavior_body&quot;


<span class="nc" id="L5994">	public static class behavior_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5997">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;behavior_clause&quot;
	// AcslParser.g:325:1: behavior_clause : ( assumes_clause | requires_clause | simple_clause );
	public final AcslParser.behavior_clause_return behavior_clause() throws RecognitionException {
<span class="nc" id="L6004">		AcslParser.behavior_clause_return retval = new AcslParser.behavior_clause_return();</span>
<span class="nc" id="L6005">		retval.start = input.LT(1);</span>

<span class="nc" id="L6007">		Object root_0 = null;</span>

<span class="nc" id="L6009">		ParserRuleReturnScope assumes_clause151 =null;</span>
<span class="nc" id="L6010">		ParserRuleReturnScope requires_clause152 =null;</span>
<span class="nc" id="L6011">		ParserRuleReturnScope simple_clause153 =null;</span>


		try {
			// AcslParser.g:326:5: ( assumes_clause | requires_clause | simple_clause )
<span class="nc" id="L6016">			int alt34=3;</span>
<span class="nc bnc" id="L6017" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case ASSUMES:
				{
<span class="nc" id="L6020">				alt34=1;</span>
				}
<span class="nc" id="L6022">				break;</span>
			case REQUIRES:
				{
<span class="nc" id="L6025">				alt34=2;</span>
				}
<span class="nc" id="L6027">				break;</span>
			case ALLOC:
			case ASSIGNS:
			case DEPENDS:
			case ENSURES:
			case FREES:
			case GUARDS:
			case READS:
				{
<span class="nc" id="L6036">				alt34=3;</span>
				}
<span class="nc" id="L6038">				break;</span>
			default:
<span class="nc bnc" id="L6040" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L6041">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 34, 0, input);
<span class="nc" id="L6043">				throw nvae;</span>
			}
<span class="nc bnc" id="L6045" title="All 4 branches missed.">			switch (alt34) {</span>
				case 1 :
					// AcslParser.g:326:7: assumes_clause
					{
<span class="nc" id="L6049">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L6052">					pushFollow(FOLLOW_assumes_clause_in_behavior_clause2443);</span>
<span class="nc" id="L6053">					assumes_clause151=assumes_clause();</span>
<span class="nc" id="L6054">					state._fsp--;</span>
<span class="nc bnc" id="L6055" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6056" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, assumes_clause151.getTree());</span>

					}
					break;
				case 2 :
					// AcslParser.g:327:7: requires_clause
					{
<span class="nc" id="L6063">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L6066">					pushFollow(FOLLOW_requires_clause_in_behavior_clause2452);</span>
<span class="nc" id="L6067">					requires_clause152=requires_clause();</span>
<span class="nc" id="L6068">					state._fsp--;</span>
<span class="nc bnc" id="L6069" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6070" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, requires_clause152.getTree());</span>

					}
					break;
				case 3 :
					// AcslParser.g:328:7: simple_clause
					{
<span class="nc" id="L6077">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L6080">					pushFollow(FOLLOW_simple_clause_in_behavior_clause2460);</span>
<span class="nc" id="L6081">					simple_clause153=simple_clause();</span>
<span class="nc" id="L6082">					state._fsp--;</span>
<span class="nc bnc" id="L6083" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6084" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, simple_clause153.getTree());</span>

					}
					break;

			}
<span class="nc" id="L6090">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L6092" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6093">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L6094">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L6097">		catch (RecognitionException re) {</span>
<span class="nc" id="L6098">			reportError(re);</span>
<span class="nc" id="L6099">			recover(input,re);</span>
<span class="nc" id="L6100">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6102">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6104">		}</span>
<span class="nc" id="L6105">		return retval;</span>
	}
	// $ANTLR end &quot;behavior_clause&quot;


<span class="nc" id="L6110">	public static class assumes_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L6113">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;assumes_clause&quot;
	// AcslParser.g:331:1: assumes_clause : ASSUMES term -&gt; ^( ASSUMES term ) ;
	public final AcslParser.assumes_clause_return assumes_clause() throws RecognitionException {
<span class="nc" id="L6120">		AcslParser.assumes_clause_return retval = new AcslParser.assumes_clause_return();</span>
<span class="nc" id="L6121">		retval.start = input.LT(1);</span>

<span class="nc" id="L6123">		Object root_0 = null;</span>

<span class="nc" id="L6125">		Token ASSUMES154=null;</span>
<span class="nc" id="L6126">		ParserRuleReturnScope term155 =null;</span>

<span class="nc" id="L6128">		Object ASSUMES154_tree=null;</span>
<span class="nc" id="L6129">		RewriteRuleTokenStream stream_ASSUMES=new RewriteRuleTokenStream(adaptor,&quot;token ASSUMES&quot;);</span>
<span class="nc" id="L6130">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>

		try {
			// AcslParser.g:332:5: ( ASSUMES term -&gt; ^( ASSUMES term ) )
			// AcslParser.g:332:7: ASSUMES term
			{
<span class="nc bnc" id="L6136" title="All 2 branches missed.">			ASSUMES154=(Token)match(input,ASSUMES,FOLLOW_ASSUMES_in_assumes_clause2477); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6137" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_ASSUMES.add(ASSUMES154);</span>

<span class="nc" id="L6139">			pushFollow(FOLLOW_term_in_assumes_clause2479);</span>
<span class="nc" id="L6140">			term155=term();</span>
<span class="nc" id="L6141">			state._fsp--;</span>
<span class="nc bnc" id="L6142" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L6143" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_term.add(term155.getTree());</span>
			// AST REWRITE
			// elements: ASSUMES, term
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L6151" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6152">			retval.tree = root_0;</span>
<span class="nc bnc" id="L6153" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6155">			root_0 = (Object)adaptor.nil();</span>
			// 332:20: -&gt; ^( ASSUMES term )
			{
				// AcslParser.g:332:22: ^( ASSUMES term )
				{
<span class="nc" id="L6160">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6161">				root_1 = (Object)adaptor.becomeRoot(stream_ASSUMES.nextNode(), root_1);</span>
<span class="nc" id="L6162">				adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L6163">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L6169">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L6174">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L6176" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6177">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L6178">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L6181">		catch (RecognitionException re) {</span>
<span class="nc" id="L6182">			reportError(re);</span>
<span class="nc" id="L6183">			recover(input,re);</span>
<span class="nc" id="L6184">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6186">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6188">		}</span>
<span class="nc" id="L6189">		return retval;</span>
	}
	// $ANTLR end &quot;assumes_clause&quot;


<span class="nc" id="L6194">	public static class completeness_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L6197">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;completeness_clause&quot;
	// AcslParser.g:335:1: completeness_clause : ( COMPLETE BEHAVIORS id_list -&gt; ^( BEHAVIOR_COMPLETE id_list ) | DISJOINT BEHAVIORS id_list -&gt; ^( BEHAVIOR_DISJOINT id_list ) );
	public final AcslParser.completeness_clause_return completeness_clause() throws RecognitionException {
<span class="nc" id="L6204">		AcslParser.completeness_clause_return retval = new AcslParser.completeness_clause_return();</span>
<span class="nc" id="L6205">		retval.start = input.LT(1);</span>

<span class="nc" id="L6207">		Object root_0 = null;</span>

<span class="nc" id="L6209">		Token COMPLETE156=null;</span>
<span class="nc" id="L6210">		Token BEHAVIORS157=null;</span>
<span class="nc" id="L6211">		Token DISJOINT159=null;</span>
<span class="nc" id="L6212">		Token BEHAVIORS160=null;</span>
<span class="nc" id="L6213">		ParserRuleReturnScope id_list158 =null;</span>
<span class="nc" id="L6214">		ParserRuleReturnScope id_list161 =null;</span>

<span class="nc" id="L6216">		Object COMPLETE156_tree=null;</span>
<span class="nc" id="L6217">		Object BEHAVIORS157_tree=null;</span>
<span class="nc" id="L6218">		Object DISJOINT159_tree=null;</span>
<span class="nc" id="L6219">		Object BEHAVIORS160_tree=null;</span>
<span class="nc" id="L6220">		RewriteRuleTokenStream stream_DISJOINT=new RewriteRuleTokenStream(adaptor,&quot;token DISJOINT&quot;);</span>
<span class="nc" id="L6221">		RewriteRuleTokenStream stream_COMPLETE=new RewriteRuleTokenStream(adaptor,&quot;token COMPLETE&quot;);</span>
<span class="nc" id="L6222">		RewriteRuleTokenStream stream_BEHAVIORS=new RewriteRuleTokenStream(adaptor,&quot;token BEHAVIORS&quot;);</span>
<span class="nc" id="L6223">		RewriteRuleSubtreeStream stream_id_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule id_list&quot;);</span>

		try {
			// AcslParser.g:336:5: ( COMPLETE BEHAVIORS id_list -&gt; ^( BEHAVIOR_COMPLETE id_list ) | DISJOINT BEHAVIORS id_list -&gt; ^( BEHAVIOR_DISJOINT id_list ) )
<span class="nc" id="L6227">			int alt35=2;</span>
<span class="nc" id="L6228">			int LA35_0 = input.LA(1);</span>
<span class="nc bnc" id="L6229" title="All 2 branches missed.">			if ( (LA35_0==COMPLETE) ) {</span>
<span class="nc" id="L6230">				alt35=1;</span>
			}
<span class="nc bnc" id="L6232" title="All 2 branches missed.">			else if ( (LA35_0==DISJOINT) ) {</span>
<span class="nc" id="L6233">				alt35=2;</span>
			}

			else {
<span class="nc bnc" id="L6237" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L6238">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 35, 0, input);
<span class="nc" id="L6240">				throw nvae;</span>
			}

<span class="nc bnc" id="L6243" title="All 3 branches missed.">			switch (alt35) {</span>
				case 1 :
					// AcslParser.g:336:7: COMPLETE BEHAVIORS id_list
					{
<span class="nc bnc" id="L6247" title="All 2 branches missed.">					COMPLETE156=(Token)match(input,COMPLETE,FOLLOW_COMPLETE_in_completeness_clause2503); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6248" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMPLETE.add(COMPLETE156);</span>

<span class="nc bnc" id="L6250" title="All 2 branches missed.">					BEHAVIORS157=(Token)match(input,BEHAVIORS,FOLLOW_BEHAVIORS_in_completeness_clause2505); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6251" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_BEHAVIORS.add(BEHAVIORS157);</span>

<span class="nc" id="L6253">					pushFollow(FOLLOW_id_list_in_completeness_clause2507);</span>
<span class="nc" id="L6254">					id_list158=id_list();</span>
<span class="nc" id="L6255">					state._fsp--;</span>
<span class="nc bnc" id="L6256" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6257" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_id_list.add(id_list158.getTree());</span>
					// AST REWRITE
					// elements: id_list
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6265" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6266">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6267" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6269">					root_0 = (Object)adaptor.nil();</span>
					// 336:34: -&gt; ^( BEHAVIOR_COMPLETE id_list )
					{
						// AcslParser.g:336:36: ^( BEHAVIOR_COMPLETE id_list )
						{
<span class="nc" id="L6274">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6275">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(BEHAVIOR_COMPLETE, &quot;BEHAVIOR_COMPLETE&quot;), root_1);</span>
<span class="nc" id="L6276">						adaptor.addChild(root_1, stream_id_list.nextTree());</span>
<span class="nc" id="L6277">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6283">					retval.tree = root_0;</span>
<span class="nc" id="L6284">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:337:7: DISJOINT BEHAVIORS id_list
					{
<span class="nc bnc" id="L6291" title="All 2 branches missed.">					DISJOINT159=(Token)match(input,DISJOINT,FOLLOW_DISJOINT_in_completeness_clause2522); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6292" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_DISJOINT.add(DISJOINT159);</span>

<span class="nc bnc" id="L6294" title="All 2 branches missed.">					BEHAVIORS160=(Token)match(input,BEHAVIORS,FOLLOW_BEHAVIORS_in_completeness_clause2524); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6295" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_BEHAVIORS.add(BEHAVIORS160);</span>

<span class="nc" id="L6297">					pushFollow(FOLLOW_id_list_in_completeness_clause2526);</span>
<span class="nc" id="L6298">					id_list161=id_list();</span>
<span class="nc" id="L6299">					state._fsp--;</span>
<span class="nc bnc" id="L6300" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6301" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_id_list.add(id_list161.getTree());</span>
					// AST REWRITE
					// elements: id_list
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6309" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6310">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6311" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6313">					root_0 = (Object)adaptor.nil();</span>
					// 337:34: -&gt; ^( BEHAVIOR_DISJOINT id_list )
					{
						// AcslParser.g:337:36: ^( BEHAVIOR_DISJOINT id_list )
						{
<span class="nc" id="L6318">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6319">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(BEHAVIOR_DISJOINT, &quot;BEHAVIOR_DISJOINT&quot;), root_1);</span>
<span class="nc" id="L6320">						adaptor.addChild(root_1, stream_id_list.nextTree());</span>
<span class="nc" id="L6321">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6327">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L6334">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L6336" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6337">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L6338">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L6341">		catch (RecognitionException re) {</span>
<span class="nc" id="L6342">			reportError(re);</span>
<span class="nc" id="L6343">			recover(input,re);</span>
<span class="nc" id="L6344">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6346">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6348">		}</span>
<span class="nc" id="L6349">		return retval;</span>
	}
	// $ANTLR end &quot;completeness_clause&quot;


<span class="nc" id="L6354">	public static class id_list_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L6357">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;id_list&quot;
	// AcslParser.g:340:1: id_list : (| ID ( COMMA ID )* -&gt; ^( ID_LIST ( ID )+ ) );
	public final AcslParser.id_list_return id_list() throws RecognitionException {
<span class="nc" id="L6364">		AcslParser.id_list_return retval = new AcslParser.id_list_return();</span>
<span class="nc" id="L6365">		retval.start = input.LT(1);</span>

<span class="nc" id="L6367">		Object root_0 = null;</span>

<span class="nc" id="L6369">		Token ID162=null;</span>
<span class="nc" id="L6370">		Token COMMA163=null;</span>
<span class="nc" id="L6371">		Token ID164=null;</span>

<span class="nc" id="L6373">		Object ID162_tree=null;</span>
<span class="nc" id="L6374">		Object COMMA163_tree=null;</span>
<span class="nc" id="L6375">		Object ID164_tree=null;</span>
<span class="nc" id="L6376">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L6377">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>

		try {
			// AcslParser.g:341:5: (| ID ( COMMA ID )* -&gt; ^( ID_LIST ( ID )+ ) )
<span class="nc" id="L6381">			int alt37=2;</span>
<span class="nc" id="L6382">			int LA37_0 = input.LA(1);</span>
<span class="nc bnc" id="L6383" title="All 6 branches missed.">			if ( (LA37_0==EOF||LA37_0==COLON||LA37_0==SEMICOL) ) {</span>
<span class="nc" id="L6384">				alt37=1;</span>
			}
<span class="nc bnc" id="L6386" title="All 2 branches missed.">			else if ( (LA37_0==ID) ) {</span>
<span class="nc" id="L6387">				alt37=2;</span>
			}

			else {
<span class="nc bnc" id="L6391" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L6392">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 37, 0, input);
<span class="nc" id="L6394">				throw nvae;</span>
			}

<span class="nc bnc" id="L6397" title="All 3 branches missed.">			switch (alt37) {</span>
				case 1 :
					// AcslParser.g:342:5: 
					{
<span class="nc" id="L6401">					root_0 = (Object)adaptor.nil();</span>


					}
<span class="nc" id="L6405">					break;</span>
				case 2 :
					// AcslParser.g:342:7: ID ( COMMA ID )*
					{
<span class="nc bnc" id="L6409" title="All 2 branches missed.">					ID162=(Token)match(input,ID,FOLLOW_ID_in_id_list2556); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6410" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID162);</span>

					// AcslParser.g:342:10: ( COMMA ID )*
					loop36:
					while (true) {
<span class="nc" id="L6415">						int alt36=2;</span>
<span class="nc" id="L6416">						int LA36_0 = input.LA(1);</span>
<span class="nc bnc" id="L6417" title="All 2 branches missed.">						if ( (LA36_0==COMMA) ) {</span>
<span class="nc" id="L6418">							alt36=1;</span>
						}

<span class="nc bnc" id="L6421" title="All 2 branches missed.">						switch (alt36) {</span>
						case 1 :
							// AcslParser.g:342:11: COMMA ID
							{
<span class="nc bnc" id="L6425" title="All 2 branches missed.">							COMMA163=(Token)match(input,COMMA,FOLLOW_COMMA_in_id_list2559); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6426" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_COMMA.add(COMMA163);</span>

<span class="nc bnc" id="L6428" title="All 2 branches missed.">							ID164=(Token)match(input,ID,FOLLOW_ID_in_id_list2561); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6429" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_ID.add(ID164);</span>

							}
							break;

						default :
<span class="nc" id="L6435">							break loop36;</span>
						}
<span class="nc" id="L6437">					}</span>

					// AST REWRITE
					// elements: ID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6446" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6447">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6448" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6450">					root_0 = (Object)adaptor.nil();</span>
					// 342:22: -&gt; ^( ID_LIST ( ID )+ )
					{
						// AcslParser.g:342:24: ^( ID_LIST ( ID )+ )
						{
<span class="nc" id="L6455">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6456">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ID_LIST, &quot;ID_LIST&quot;), root_1);</span>
<span class="nc bnc" id="L6457" title="All 2 branches missed.">						if ( !(stream_ID.hasNext()) ) {</span>
<span class="nc" id="L6458">							throw new RewriteEarlyExitException();</span>
						}
<span class="nc bnc" id="L6460" title="All 2 branches missed.">						while ( stream_ID.hasNext() ) {</span>
<span class="nc" id="L6461">							adaptor.addChild(root_1, stream_ID.nextNode());</span>
						}
<span class="nc" id="L6463">						stream_ID.reset();</span>

<span class="nc" id="L6465">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6471">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L6478">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L6480" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6481">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L6482">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L6485">		catch (RecognitionException re) {</span>
<span class="nc" id="L6486">			reportError(re);</span>
<span class="nc" id="L6487">			recover(input,re);</span>
<span class="nc" id="L6488">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6490">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6492">		}</span>
<span class="nc" id="L6493">		return retval;</span>
	}
	// $ANTLR end &quot;id_list&quot;


<span class="nc" id="L6498">	public static class primaryExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L6501">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;primaryExpression&quot;
	// AcslParser.g:346:1: primaryExpression : ( constant | ID | STRING_LITERAL | LCURLY term BAR binders ( SEMICOL term )? RCURLY -&gt; ^( SET_BINDERS term binders ( term )? ) | LCURLY term RCURLY -&gt; ^( SET_SIMPLE term ) | LPAREN term RPAREN -&gt; ^( TERM_PARENTHESIZED term ) | mpi_expression -&gt; ^( MPI_EXPRESSION mpi_expression ) | REMOTE_ACCESS LPAREN a= ID COMMA b= primaryExpression RPAREN -&gt; ^( REMOTE_ACCESS $a $b) );
	public final AcslParser.primaryExpression_return primaryExpression() throws RecognitionException {
<span class="nc" id="L6508">		AcslParser.primaryExpression_return retval = new AcslParser.primaryExpression_return();</span>
<span class="nc" id="L6509">		retval.start = input.LT(1);</span>

<span class="nc" id="L6511">		Object root_0 = null;</span>

<span class="nc" id="L6513">		Token a=null;</span>
<span class="nc" id="L6514">		Token ID166=null;</span>
<span class="nc" id="L6515">		Token STRING_LITERAL167=null;</span>
<span class="nc" id="L6516">		Token LCURLY168=null;</span>
<span class="nc" id="L6517">		Token BAR170=null;</span>
<span class="nc" id="L6518">		Token SEMICOL172=null;</span>
<span class="nc" id="L6519">		Token RCURLY174=null;</span>
<span class="nc" id="L6520">		Token LCURLY175=null;</span>
<span class="nc" id="L6521">		Token RCURLY177=null;</span>
<span class="nc" id="L6522">		Token LPAREN178=null;</span>
<span class="nc" id="L6523">		Token RPAREN180=null;</span>
<span class="nc" id="L6524">		Token REMOTE_ACCESS182=null;</span>
<span class="nc" id="L6525">		Token LPAREN183=null;</span>
<span class="nc" id="L6526">		Token COMMA184=null;</span>
<span class="nc" id="L6527">		Token RPAREN185=null;</span>
<span class="nc" id="L6528">		ParserRuleReturnScope b =null;</span>
<span class="nc" id="L6529">		ParserRuleReturnScope constant165 =null;</span>
<span class="nc" id="L6530">		ParserRuleReturnScope term169 =null;</span>
<span class="nc" id="L6531">		ParserRuleReturnScope binders171 =null;</span>
<span class="nc" id="L6532">		ParserRuleReturnScope term173 =null;</span>
<span class="nc" id="L6533">		ParserRuleReturnScope term176 =null;</span>
<span class="nc" id="L6534">		ParserRuleReturnScope term179 =null;</span>
<span class="nc" id="L6535">		ParserRuleReturnScope mpi_expression181 =null;</span>

<span class="nc" id="L6537">		Object a_tree=null;</span>
<span class="nc" id="L6538">		Object ID166_tree=null;</span>
<span class="nc" id="L6539">		Object STRING_LITERAL167_tree=null;</span>
<span class="nc" id="L6540">		Object LCURLY168_tree=null;</span>
<span class="nc" id="L6541">		Object BAR170_tree=null;</span>
<span class="nc" id="L6542">		Object SEMICOL172_tree=null;</span>
<span class="nc" id="L6543">		Object RCURLY174_tree=null;</span>
<span class="nc" id="L6544">		Object LCURLY175_tree=null;</span>
<span class="nc" id="L6545">		Object RCURLY177_tree=null;</span>
<span class="nc" id="L6546">		Object LPAREN178_tree=null;</span>
<span class="nc" id="L6547">		Object RPAREN180_tree=null;</span>
<span class="nc" id="L6548">		Object REMOTE_ACCESS182_tree=null;</span>
<span class="nc" id="L6549">		Object LPAREN183_tree=null;</span>
<span class="nc" id="L6550">		Object COMMA184_tree=null;</span>
<span class="nc" id="L6551">		Object RPAREN185_tree=null;</span>
<span class="nc" id="L6552">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L6553">		RewriteRuleTokenStream stream_REMOTE_ACCESS=new RewriteRuleTokenStream(adaptor,&quot;token REMOTE_ACCESS&quot;);</span>
<span class="nc" id="L6554">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L6555">		RewriteRuleTokenStream stream_LCURLY=new RewriteRuleTokenStream(adaptor,&quot;token LCURLY&quot;);</span>
<span class="nc" id="L6556">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L6557">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L6558">		RewriteRuleTokenStream stream_BAR=new RewriteRuleTokenStream(adaptor,&quot;token BAR&quot;);</span>
<span class="nc" id="L6559">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L6560">		RewriteRuleTokenStream stream_RCURLY=new RewriteRuleTokenStream(adaptor,&quot;token RCURLY&quot;);</span>
<span class="nc" id="L6561">		RewriteRuleSubtreeStream stream_binders=new RewriteRuleSubtreeStream(adaptor,&quot;rule binders&quot;);</span>
<span class="nc" id="L6562">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L6563">		RewriteRuleSubtreeStream stream_mpi_expression=new RewriteRuleSubtreeStream(adaptor,&quot;rule mpi_expression&quot;);</span>
<span class="nc" id="L6564">		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule primaryExpression&quot;);</span>

		try {
			// AcslParser.g:347:2: ( constant | ID | STRING_LITERAL | LCURLY term BAR binders ( SEMICOL term )? RCURLY -&gt; ^( SET_BINDERS term binders ( term )? ) | LCURLY term RCURLY -&gt; ^( SET_SIMPLE term ) | LPAREN term RPAREN -&gt; ^( TERM_PARENTHESIZED term ) | mpi_expression -&gt; ^( MPI_EXPRESSION mpi_expression ) | REMOTE_ACCESS LPAREN a= ID COMMA b= primaryExpression RPAREN -&gt; ^( REMOTE_ACCESS $a $b) )
<span class="nc" id="L6568">			int alt39=8;</span>
<span class="nc bnc" id="L6569" title="All 8 branches missed.">			switch ( input.LA(1) ) {</span>
			case ELLIPSIS:
			case FALSE:
			case FLOATING_CONSTANT:
			case INTEGER_CONSTANT:
			case MPI_COMM_RANK:
			case MPI_COMM_SIZE:
			case NOTHING:
			case NULL:
			case RESULT:
			case SELF:
			case TRUE:
			case CHARACTER_CONSTANT:
				{
<span class="nc" id="L6583">				alt39=1;</span>
				}
<span class="nc" id="L6585">				break;</span>
			case ID:
				{
<span class="nc" id="L6588">				alt39=2;</span>
				}
<span class="nc" id="L6590">				break;</span>
			case STRING_LITERAL:
				{
<span class="nc" id="L6593">				alt39=3;</span>
				}
<span class="nc" id="L6595">				break;</span>
			case LCURLY:
				{
<span class="nc" id="L6598">				int LA39_14 = input.LA(2);</span>
<span class="nc bnc" id="L6599" title="All 2 branches missed.">				if ( (synpred70_AcslParser()) ) {</span>
<span class="nc" id="L6600">					alt39=4;</span>
				}
<span class="nc bnc" id="L6602" title="All 2 branches missed.">				else if ( (synpred71_AcslParser()) ) {</span>
<span class="nc" id="L6603">					alt39=5;</span>
				}

				else {
<span class="nc bnc" id="L6607" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L6608">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L6610">						input.consume();</span>
<span class="nc" id="L6611">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 39, 14, input);
<span class="nc" id="L6613">						throw nvae;</span>
					} finally {
<span class="nc" id="L6615">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L6620">				break;</span>
			case LPAREN:
				{
<span class="nc" id="L6623">				alt39=6;</span>
				}
<span class="nc" id="L6625">				break;</span>
			case MPI_AGREE:
			case MPI_EMPTY_IN:
			case MPI_EMPTY_OUT:
			case MPI_EQUALS:
			case MPI_REGION:
				{
<span class="nc" id="L6632">				alt39=7;</span>
				}
<span class="nc" id="L6634">				break;</span>
			case REMOTE_ACCESS:
				{
<span class="nc" id="L6637">				alt39=8;</span>
				}
<span class="nc" id="L6639">				break;</span>
			default:
<span class="nc bnc" id="L6641" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L6642">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 39, 0, input);
<span class="nc" id="L6644">				throw nvae;</span>
			}
<span class="nc bnc" id="L6646" title="All 9 branches missed.">			switch (alt39) {</span>
				case 1 :
					// AcslParser.g:347:4: constant
					{
<span class="nc" id="L6650">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L6653">					pushFollow(FOLLOW_constant_in_primaryExpression2587);</span>
<span class="nc" id="L6654">					constant165=constant();</span>
<span class="nc" id="L6655">					state._fsp--;</span>
<span class="nc bnc" id="L6656" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6657" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, constant165.getTree());</span>

					}
					break;
				case 2 :
					// AcslParser.g:348:7: ID
					{
<span class="nc" id="L6664">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L6667" title="All 2 branches missed.">					ID166=(Token)match(input,ID,FOLLOW_ID_in_primaryExpression2595); if (state.failed) return retval;</span>
<span class="nc bnc" id="L6668" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6669">					ID166_tree = (Object)adaptor.create(ID166);</span>
<span class="nc" id="L6670">					adaptor.addChild(root_0, ID166_tree);</span>
					}

					}
					break;
				case 3 :
					// AcslParser.g:349:4: STRING_LITERAL
					{
<span class="nc" id="L6678">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L6681" title="All 2 branches missed.">					STRING_LITERAL167=(Token)match(input,STRING_LITERAL,FOLLOW_STRING_LITERAL_in_primaryExpression2600); if (state.failed) return retval;</span>
<span class="nc bnc" id="L6682" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6683">					STRING_LITERAL167_tree = (Object)adaptor.create(STRING_LITERAL167);</span>
<span class="nc" id="L6684">					adaptor.addChild(root_0, STRING_LITERAL167_tree);</span>
					}

					}
					break;
				case 4 :
					// AcslParser.g:350:7: LCURLY term BAR binders ( SEMICOL term )? RCURLY
					{
<span class="nc bnc" id="L6692" title="All 2 branches missed.">					LCURLY168=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_primaryExpression2608); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6693" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY168);</span>

<span class="nc" id="L6695">					pushFollow(FOLLOW_term_in_primaryExpression2610);</span>
<span class="nc" id="L6696">					term169=term();</span>
<span class="nc" id="L6697">					state._fsp--;</span>
<span class="nc bnc" id="L6698" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6699" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term169.getTree());</span>
<span class="nc bnc" id="L6700" title="All 2 branches missed.">					BAR170=(Token)match(input,BAR,FOLLOW_BAR_in_primaryExpression2612); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6701" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_BAR.add(BAR170);</span>

<span class="nc" id="L6703">					pushFollow(FOLLOW_binders_in_primaryExpression2614);</span>
<span class="nc" id="L6704">					binders171=binders();</span>
<span class="nc" id="L6705">					state._fsp--;</span>
<span class="nc bnc" id="L6706" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6707" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_binders.add(binders171.getTree());</span>
					// AcslParser.g:350:31: ( SEMICOL term )?
<span class="nc" id="L6709">					int alt38=2;</span>
<span class="nc" id="L6710">					int LA38_0 = input.LA(1);</span>
<span class="nc bnc" id="L6711" title="All 2 branches missed.">					if ( (LA38_0==SEMICOL) ) {</span>
<span class="nc" id="L6712">						alt38=1;</span>
					}
<span class="nc bnc" id="L6714" title="All 2 branches missed.">					switch (alt38) {</span>
						case 1 :
							// AcslParser.g:350:32: SEMICOL term
							{
<span class="nc bnc" id="L6718" title="All 2 branches missed.">							SEMICOL172=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_primaryExpression2617); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6719" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL172);</span>

<span class="nc" id="L6721">							pushFollow(FOLLOW_term_in_primaryExpression2619);</span>
<span class="nc" id="L6722">							term173=term();</span>
<span class="nc" id="L6723">							state._fsp--;</span>
<span class="nc bnc" id="L6724" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L6725" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_term.add(term173.getTree());</span>
							}
							break;

					}

<span class="nc bnc" id="L6731" title="All 2 branches missed.">					RCURLY174=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_primaryExpression2623); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6732" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY174);</span>

					// AST REWRITE
					// elements: term, term, binders
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6741" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6742">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6743" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6745">					root_0 = (Object)adaptor.nil();</span>
					// 351:9: -&gt; ^( SET_BINDERS term binders ( term )? )
					{
						// AcslParser.g:351:11: ^( SET_BINDERS term binders ( term )? )
						{
<span class="nc" id="L6750">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6751">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SET_BINDERS, &quot;SET_BINDERS&quot;), root_1);</span>
<span class="nc" id="L6752">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L6753">						adaptor.addChild(root_1, stream_binders.nextTree());</span>
						// AcslParser.g:351:38: ( term )?
<span class="nc bnc" id="L6755" title="All 2 branches missed.">						if ( stream_term.hasNext() ) {</span>
<span class="nc" id="L6756">							adaptor.addChild(root_1, stream_term.nextTree());</span>
						}
<span class="nc" id="L6758">						stream_term.reset();</span>

<span class="nc" id="L6760">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6766">					retval.tree = root_0;</span>
					}

					}
<span class="nc" id="L6770">					break;</span>
				case 5 :
					// AcslParser.g:352:7: LCURLY term RCURLY
					{
<span class="nc bnc" id="L6774" title="All 2 branches missed.">					LCURLY175=(Token)match(input,LCURLY,FOLLOW_LCURLY_in_primaryExpression2651); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6775" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LCURLY.add(LCURLY175);</span>

<span class="nc" id="L6777">					pushFollow(FOLLOW_term_in_primaryExpression2653);</span>
<span class="nc" id="L6778">					term176=term();</span>
<span class="nc" id="L6779">					state._fsp--;</span>
<span class="nc bnc" id="L6780" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6781" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term176.getTree());</span>
<span class="nc bnc" id="L6782" title="All 2 branches missed.">					RCURLY177=(Token)match(input,RCURLY,FOLLOW_RCURLY_in_primaryExpression2655); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6783" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RCURLY.add(RCURLY177);</span>

					// AST REWRITE
					// elements: term
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6792" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6793">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6794" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6796">					root_0 = (Object)adaptor.nil();</span>
					// 353:9: -&gt; ^( SET_SIMPLE term )
					{
						// AcslParser.g:353:11: ^( SET_SIMPLE term )
						{
<span class="nc" id="L6801">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6802">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SET_SIMPLE, &quot;SET_SIMPLE&quot;), root_1);</span>
<span class="nc" id="L6803">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L6804">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6810">					retval.tree = root_0;</span>
<span class="nc" id="L6811">					}</span>

					}
					break;
				case 6 :
					// AcslParser.g:354:4: LPAREN term RPAREN
					{
<span class="nc bnc" id="L6818" title="All 2 branches missed.">					LPAREN178=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_primaryExpression2675); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6819" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN178);</span>

<span class="nc" id="L6821">					pushFollow(FOLLOW_term_in_primaryExpression2677);</span>
<span class="nc" id="L6822">					term179=term();</span>
<span class="nc" id="L6823">					state._fsp--;</span>
<span class="nc bnc" id="L6824" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6825" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term179.getTree());</span>
<span class="nc bnc" id="L6826" title="All 2 branches missed.">					RPAREN180=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_primaryExpression2679); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6827" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN180);</span>

					// AST REWRITE
					// elements: term
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6836" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6837">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6838" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6840">					root_0 = (Object)adaptor.nil();</span>
					// 355:4: -&gt; ^( TERM_PARENTHESIZED term )
					{
						// AcslParser.g:355:7: ^( TERM_PARENTHESIZED term )
						{
<span class="nc" id="L6845">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6846">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(TERM_PARENTHESIZED, &quot;TERM_PARENTHESIZED&quot;), root_1);</span>
<span class="nc" id="L6847">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L6848">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6854">					retval.tree = root_0;</span>
<span class="nc" id="L6855">					}</span>

					}
					break;
				case 7 :
					// AcslParser.g:356:7: mpi_expression
					{
<span class="nc" id="L6862">					pushFollow(FOLLOW_mpi_expression_in_primaryExpression2699);</span>
<span class="nc" id="L6863">					mpi_expression181=mpi_expression();</span>
<span class="nc" id="L6864">					state._fsp--;</span>
<span class="nc bnc" id="L6865" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6866" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_mpi_expression.add(mpi_expression181.getTree());</span>
					// AST REWRITE
					// elements: mpi_expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6874" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6875">					retval.tree = root_0;</span>
<span class="nc bnc" id="L6876" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L6878">					root_0 = (Object)adaptor.nil();</span>
					// 356:22: -&gt; ^( MPI_EXPRESSION mpi_expression )
					{
						// AcslParser.g:356:25: ^( MPI_EXPRESSION mpi_expression )
						{
<span class="nc" id="L6883">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6884">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MPI_EXPRESSION, &quot;MPI_EXPRESSION&quot;), root_1);</span>
<span class="nc" id="L6885">						adaptor.addChild(root_1, stream_mpi_expression.nextTree());</span>
<span class="nc" id="L6886">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6892">					retval.tree = root_0;</span>
<span class="nc" id="L6893">					}</span>

					}
					break;
				case 8 :
					// AcslParser.g:357:7: REMOTE_ACCESS LPAREN a= ID COMMA b= primaryExpression RPAREN
					{
<span class="nc bnc" id="L6900" title="All 2 branches missed.">					REMOTE_ACCESS182=(Token)match(input,REMOTE_ACCESS,FOLLOW_REMOTE_ACCESS_in_primaryExpression2715); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6901" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_REMOTE_ACCESS.add(REMOTE_ACCESS182);</span>

<span class="nc bnc" id="L6903" title="All 2 branches missed.">					LPAREN183=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_primaryExpression2717); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6904" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN183);</span>

<span class="nc bnc" id="L6906" title="All 2 branches missed.">					a=(Token)match(input,ID,FOLLOW_ID_in_primaryExpression2721); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6907" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(a);</span>

<span class="nc bnc" id="L6909" title="All 2 branches missed.">					COMMA184=(Token)match(input,COMMA,FOLLOW_COMMA_in_primaryExpression2723); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6910" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA184);</span>

<span class="nc" id="L6912">					pushFollow(FOLLOW_primaryExpression_in_primaryExpression2727);</span>
<span class="nc" id="L6913">					b=primaryExpression();</span>
<span class="nc" id="L6914">					state._fsp--;</span>
<span class="nc bnc" id="L6915" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L6916" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(b.getTree());</span>
<span class="nc bnc" id="L6917" title="All 2 branches missed.">					RPAREN185=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_primaryExpression2729); if (state.failed) return retval; </span>
<span class="nc bnc" id="L6918" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN185);</span>

					// AST REWRITE
					// elements: a, b, REMOTE_ACCESS
					// token labels: a
					// rule labels: retval, b
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L6927" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6928">					retval.tree = root_0;</span>
<span class="nc" id="L6929">					RewriteRuleTokenStream stream_a=new RewriteRuleTokenStream(adaptor,&quot;token a&quot;,a);</span>
<span class="nc bnc" id="L6930" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L6931" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,&quot;rule b&quot;,b!=null?b.getTree():null);</span>

<span class="nc" id="L6933">					root_0 = (Object)adaptor.nil();</span>
					// 358:7: -&gt; ^( REMOTE_ACCESS $a $b)
					{
						// AcslParser.g:358:10: ^( REMOTE_ACCESS $a $b)
						{
<span class="nc" id="L6938">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L6939">						root_1 = (Object)adaptor.becomeRoot(stream_REMOTE_ACCESS.nextNode(), root_1);</span>
<span class="nc" id="L6940">						adaptor.addChild(root_1, stream_a.nextNode());</span>
<span class="nc" id="L6941">						adaptor.addChild(root_1, stream_b.nextTree());</span>
<span class="nc" id="L6942">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L6948">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L6955">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L6957" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L6958">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L6959">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L6962">		catch (RecognitionException re) {</span>
<span class="nc" id="L6963">			reportError(re);</span>
<span class="nc" id="L6964">			recover(input,re);</span>
<span class="nc" id="L6965">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6967">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6969">		}</span>
<span class="nc" id="L6970">		return retval;</span>
	}
	// $ANTLR end &quot;primaryExpression&quot;


<span class="nc" id="L6975">	public static class postfixExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L6978">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;postfixExpression&quot;
	// AcslParser.g:362:1: postfixExpression : ( primaryExpression -&gt; primaryExpression ) (l= LSQUARE term RSQUARE -&gt; ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE ) | LPAREN argumentExpressionList RPAREN -&gt; ^( FUNC_CALL $postfixExpression argumentExpressionList ) | DOT ID -&gt; ^( DOT $postfixExpression ID ) | ARROW ID -&gt; ^( ARROW $postfixExpression ID ) )* ;
	public final AcslParser.postfixExpression_return postfixExpression() throws RecognitionException {
<span class="nc" id="L6985">		AcslParser.postfixExpression_return retval = new AcslParser.postfixExpression_return();</span>
<span class="nc" id="L6986">		retval.start = input.LT(1);</span>

<span class="nc" id="L6988">		Object root_0 = null;</span>

<span class="nc" id="L6990">		Token l=null;</span>
<span class="nc" id="L6991">		Token RSQUARE188=null;</span>
<span class="nc" id="L6992">		Token LPAREN189=null;</span>
<span class="nc" id="L6993">		Token RPAREN191=null;</span>
<span class="nc" id="L6994">		Token DOT192=null;</span>
<span class="nc" id="L6995">		Token ID193=null;</span>
<span class="nc" id="L6996">		Token ARROW194=null;</span>
<span class="nc" id="L6997">		Token ID195=null;</span>
<span class="nc" id="L6998">		ParserRuleReturnScope primaryExpression186 =null;</span>
<span class="nc" id="L6999">		ParserRuleReturnScope term187 =null;</span>
<span class="nc" id="L7000">		ParserRuleReturnScope argumentExpressionList190 =null;</span>

<span class="nc" id="L7002">		Object l_tree=null;</span>
<span class="nc" id="L7003">		Object RSQUARE188_tree=null;</span>
<span class="nc" id="L7004">		Object LPAREN189_tree=null;</span>
<span class="nc" id="L7005">		Object RPAREN191_tree=null;</span>
<span class="nc" id="L7006">		Object DOT192_tree=null;</span>
<span class="nc" id="L7007">		Object ID193_tree=null;</span>
<span class="nc" id="L7008">		Object ARROW194_tree=null;</span>
<span class="nc" id="L7009">		Object ID195_tree=null;</span>
<span class="nc" id="L7010">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L7011">		RewriteRuleTokenStream stream_ARROW=new RewriteRuleTokenStream(adaptor,&quot;token ARROW&quot;);</span>
<span class="nc" id="L7012">		RewriteRuleTokenStream stream_LSQUARE=new RewriteRuleTokenStream(adaptor,&quot;token LSQUARE&quot;);</span>
<span class="nc" id="L7013">		RewriteRuleTokenStream stream_RSQUARE=new RewriteRuleTokenStream(adaptor,&quot;token RSQUARE&quot;);</span>
<span class="nc" id="L7014">		RewriteRuleTokenStream stream_DOT=new RewriteRuleTokenStream(adaptor,&quot;token DOT&quot;);</span>
<span class="nc" id="L7015">		RewriteRuleTokenStream stream_ID=new RewriteRuleTokenStream(adaptor,&quot;token ID&quot;);</span>
<span class="nc" id="L7016">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L7017">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L7018">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>
<span class="nc" id="L7019">		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule primaryExpression&quot;);</span>

		try {
			// AcslParser.g:363:2: ( ( primaryExpression -&gt; primaryExpression ) (l= LSQUARE term RSQUARE -&gt; ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE ) | LPAREN argumentExpressionList RPAREN -&gt; ^( FUNC_CALL $postfixExpression argumentExpressionList ) | DOT ID -&gt; ^( DOT $postfixExpression ID ) | ARROW ID -&gt; ^( ARROW $postfixExpression ID ) )* )
			// AcslParser.g:363:4: ( primaryExpression -&gt; primaryExpression ) (l= LSQUARE term RSQUARE -&gt; ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE ) | LPAREN argumentExpressionList RPAREN -&gt; ^( FUNC_CALL $postfixExpression argumentExpressionList ) | DOT ID -&gt; ^( DOT $postfixExpression ID ) | ARROW ID -&gt; ^( ARROW $postfixExpression ID ) )*
			{
			// AcslParser.g:363:4: ( primaryExpression -&gt; primaryExpression )
			// AcslParser.g:363:5: primaryExpression
			{
<span class="nc" id="L7028">			pushFollow(FOLLOW_primaryExpression_in_postfixExpression2761);</span>
<span class="nc" id="L7029">			primaryExpression186=primaryExpression();</span>
<span class="nc" id="L7030">			state._fsp--;</span>
<span class="nc bnc" id="L7031" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L7032" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_primaryExpression.add(primaryExpression186.getTree());</span>
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L7040" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7041">			retval.tree = root_0;</span>
<span class="nc bnc" id="L7042" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7044">			root_0 = (Object)adaptor.nil();</span>
			// 363:23: -&gt; primaryExpression
			{
<span class="nc" id="L7047">				adaptor.addChild(root_0, stream_primaryExpression.nextTree());</span>
			}


<span class="nc" id="L7051">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:365:4: (l= LSQUARE term RSQUARE -&gt; ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE ) | LPAREN argumentExpressionList RPAREN -&gt; ^( FUNC_CALL $postfixExpression argumentExpressionList ) | DOT ID -&gt; ^( DOT $postfixExpression ID ) | ARROW ID -&gt; ^( ARROW $postfixExpression ID ) )*
			loop40:
			while (true) {
<span class="nc" id="L7059">				int alt40=5;</span>
<span class="nc bnc" id="L7060" title="All 5 branches missed.">				switch ( input.LA(1) ) {</span>
				case LSQUARE:
					{
<span class="nc" id="L7063">					alt40=1;</span>
					}
<span class="nc" id="L7065">					break;</span>
				case LPAREN:
					{
<span class="nc" id="L7068">					alt40=2;</span>
					}
<span class="nc" id="L7070">					break;</span>
				case DOT:
					{
<span class="nc" id="L7073">					alt40=3;</span>
					}
<span class="nc" id="L7075">					break;</span>
				case ARROW:
					{
<span class="nc" id="L7078">					alt40=4;</span>
					}
					break;
				}
<span class="nc bnc" id="L7082" title="All 5 branches missed.">				switch (alt40) {</span>
				case 1 :
					// AcslParser.g:365:6: l= LSQUARE term RSQUARE
					{
<span class="nc bnc" id="L7086" title="All 2 branches missed.">					l=(Token)match(input,LSQUARE,FOLLOW_LSQUARE_in_postfixExpression2778); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7087" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LSQUARE.add(l);</span>

<span class="nc" id="L7089">					pushFollow(FOLLOW_term_in_postfixExpression2780);</span>
<span class="nc" id="L7090">					term187=term();</span>
<span class="nc" id="L7091">					state._fsp--;</span>
<span class="nc bnc" id="L7092" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7093" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term187.getTree());</span>
<span class="nc bnc" id="L7094" title="All 2 branches missed.">					RSQUARE188=(Token)match(input,RSQUARE,FOLLOW_RSQUARE_in_postfixExpression2782); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7095" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RSQUARE.add(RSQUARE188);</span>

					// AST REWRITE
					// elements: term, RSQUARE, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7104" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7105">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7106" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7108">					root_0 = (Object)adaptor.nil();</span>
					// 366:6: -&gt; ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE )
					{
						// AcslParser.g:366:9: ^( OPERATOR INDEX[$l] ^( ARGUMENT_LIST $postfixExpression term ) RSQUARE )
						{
<span class="nc" id="L7113">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7114">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L7115">						adaptor.addChild(root_1, (Object)adaptor.create(INDEX, l));</span>
						// AcslParser.g:368:13: ^( ARGUMENT_LIST $postfixExpression term )
						{
<span class="nc" id="L7118">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L7119">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L7120">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L7121">						adaptor.addChild(root_2, stream_term.nextTree());</span>
<span class="nc" id="L7122">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L7125">						adaptor.addChild(root_1, stream_RSQUARE.nextNode());</span>
<span class="nc" id="L7126">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7132">					retval.tree = root_0;</span>
<span class="nc" id="L7133">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:371:6: LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L7140" title="All 2 branches missed.">					LPAREN189=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_postfixExpression2856); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7141" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN189);</span>

<span class="nc" id="L7143">					pushFollow(FOLLOW_argumentExpressionList_in_postfixExpression2858);</span>
<span class="nc" id="L7144">					argumentExpressionList190=argumentExpressionList();</span>
<span class="nc" id="L7145">					state._fsp--;</span>
<span class="nc bnc" id="L7146" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7147" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList190.getTree());</span>
<span class="nc bnc" id="L7148" title="All 2 branches missed.">					RPAREN191=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_postfixExpression2860); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7149" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN191);</span>

					// AST REWRITE
					// elements: argumentExpressionList, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7158" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7159">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7160" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7162">					root_0 = (Object)adaptor.nil();</span>
					// 372:6: -&gt; ^( FUNC_CALL $postfixExpression argumentExpressionList )
					{
						// AcslParser.g:372:9: ^( FUNC_CALL $postfixExpression argumentExpressionList )
						{
<span class="nc" id="L7167">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7168">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FUNC_CALL, &quot;FUNC_CALL&quot;), root_1);</span>
<span class="nc" id="L7169">						adaptor.addChild(root_1, stream_retval.nextTree());</span>
<span class="nc" id="L7170">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L7171">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7177">					retval.tree = root_0;</span>
<span class="nc" id="L7178">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:374:6: DOT ID
					{
<span class="nc bnc" id="L7185" title="All 2 branches missed.">					DOT192=(Token)match(input,DOT,FOLLOW_DOT_in_postfixExpression2891); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7186" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_DOT.add(DOT192);</span>

<span class="nc bnc" id="L7188" title="All 2 branches missed.">					ID193=(Token)match(input,ID,FOLLOW_ID_in_postfixExpression2893); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7189" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID193);</span>

					// AST REWRITE
					// elements: postfixExpression, ID, DOT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7198" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7199">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7200" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7202">					root_0 = (Object)adaptor.nil();</span>
					// 375:6: -&gt; ^( DOT $postfixExpression ID )
					{
						// AcslParser.g:375:9: ^( DOT $postfixExpression ID )
						{
<span class="nc" id="L7207">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7208">						root_1 = (Object)adaptor.becomeRoot(stream_DOT.nextNode(), root_1);</span>
<span class="nc" id="L7209">						adaptor.addChild(root_1, stream_retval.nextTree());</span>
<span class="nc" id="L7210">						adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L7211">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7217">					retval.tree = root_0;</span>
<span class="nc" id="L7218">					}</span>

					}
					break;
				case 4 :
					// AcslParser.g:376:6: ARROW ID
					{
<span class="nc bnc" id="L7225" title="All 2 branches missed.">					ARROW194=(Token)match(input,ARROW,FOLLOW_ARROW_in_postfixExpression2916); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7226" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ARROW.add(ARROW194);</span>

<span class="nc bnc" id="L7228" title="All 2 branches missed.">					ID195=(Token)match(input,ID,FOLLOW_ID_in_postfixExpression2918); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7229" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ID.add(ID195);</span>

					// AST REWRITE
					// elements: ID, ARROW, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7238" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7239">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7240" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7242">					root_0 = (Object)adaptor.nil();</span>
					// 377:6: -&gt; ^( ARROW $postfixExpression ID )
					{
						// AcslParser.g:377:9: ^( ARROW $postfixExpression ID )
						{
<span class="nc" id="L7247">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7248">						root_1 = (Object)adaptor.becomeRoot(stream_ARROW.nextNode(), root_1);</span>
<span class="nc" id="L7249">						adaptor.addChild(root_1, stream_retval.nextTree());</span>
<span class="nc" id="L7250">						adaptor.addChild(root_1, stream_ID.nextNode());</span>
<span class="nc" id="L7251">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7257">					retval.tree = root_0;</span>
<span class="nc" id="L7258">					}</span>

					}
					break;

				default :
<span class="nc" id="L7264">					break loop40;</span>
				}
<span class="nc" id="L7266">			}</span>

			}

<span class="nc" id="L7270">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L7272" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7273">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L7274">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L7277">		catch (RecognitionException re) {</span>
<span class="nc" id="L7278">			reportError(re);</span>
<span class="nc" id="L7279">			recover(input,re);</span>
<span class="nc" id="L7280">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L7282">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L7284">		}</span>
<span class="nc" id="L7285">		return retval;</span>
	}
	// $ANTLR end &quot;postfixExpression&quot;


<span class="nc" id="L7290">	public static class argumentExpressionList_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L7293">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;argumentExpressionList&quot;
	// AcslParser.g:382:1: argumentExpressionList : ( -&gt; ^( ARGUMENT_LIST ) | assignmentExpression ( COMMA assignmentExpression )* -&gt; ^( ARGUMENT_LIST ( assignmentExpression )+ ) );
	public final AcslParser.argumentExpressionList_return argumentExpressionList() throws RecognitionException {
<span class="nc" id="L7300">		AcslParser.argumentExpressionList_return retval = new AcslParser.argumentExpressionList_return();</span>
<span class="nc" id="L7301">		retval.start = input.LT(1);</span>

<span class="nc" id="L7303">		Object root_0 = null;</span>

<span class="nc" id="L7305">		Token COMMA197=null;</span>
<span class="nc" id="L7306">		ParserRuleReturnScope assignmentExpression196 =null;</span>
<span class="nc" id="L7307">		ParserRuleReturnScope assignmentExpression198 =null;</span>

<span class="nc" id="L7309">		Object COMMA197_tree=null;</span>
<span class="nc" id="L7310">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L7311">		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule assignmentExpression&quot;);</span>

		try {
			// AcslParser.g:383:2: ( -&gt; ^( ARGUMENT_LIST ) | assignmentExpression ( COMMA assignmentExpression )* -&gt; ^( ARGUMENT_LIST ( assignmentExpression )+ ) )
<span class="nc" id="L7315">			int alt42=2;</span>
<span class="nc" id="L7316">			int LA42_0 = input.LA(1);</span>
<span class="nc bnc" id="L7317" title="All 8 branches missed.">			if ( (LA42_0==EOF||LA42_0==COMMA||LA42_0==RPAREN||LA42_0==SEMICOL) ) {</span>
<span class="nc" id="L7318">				alt42=1;</span>
			}
<span class="nc bnc" id="L7320" title="All 56 branches missed.">			else if ( (LA42_0==AMPERSAND||LA42_0==COMP||LA42_0==ELLIPSIS||LA42_0==EXISTS||LA42_0==FALSE||LA42_0==FLOATING_CONSTANT||LA42_0==FORALL||LA42_0==ID||(LA42_0 &gt;= INTEGER_CONSTANT &amp;&amp; LA42_0 &lt;= INTER)||LA42_0==LCURLY||LA42_0==LPAREN||LA42_0==MPI_AGREE||(LA42_0 &gt;= MPI_COMM_RANK &amp;&amp; LA42_0 &lt;= MPI_REGION)||(LA42_0 &gt;= NOT &amp;&amp; LA42_0 &lt;= NULL)||LA42_0==PLUS||LA42_0==REMOTE_ACCESS||LA42_0==RESULT||LA42_0==SELF||(LA42_0 &gt;= SIZEOF &amp;&amp; LA42_0 &lt;= STRING_LITERAL)||(LA42_0 &gt;= TRUE &amp;&amp; LA42_0 &lt;= UNION)||LA42_0==VALID||LA42_0==CHARACTER_CONSTANT||LA42_0==MINUS) ) {</span>
<span class="nc" id="L7321">				alt42=2;</span>
			}

			else {
<span class="nc bnc" id="L7325" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7326">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 42, 0, input);
<span class="nc" id="L7328">				throw nvae;</span>
			}

<span class="nc bnc" id="L7331" title="All 3 branches missed.">			switch (alt42) {</span>
				case 1 :
					// AcslParser.g:383:4: 
					{
					// AST REWRITE
					// elements: 
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7342" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7343">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7344" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7346">					root_0 = (Object)adaptor.nil();</span>
					// 383:4: -&gt; ^( ARGUMENT_LIST )
					{
						// AcslParser.g:383:7: ^( ARGUMENT_LIST )
						{
<span class="nc" id="L7351">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7352">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_1);</span>
<span class="nc" id="L7353">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7359">					retval.tree = root_0;</span>
<span class="nc" id="L7360">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:384:4: assignmentExpression ( COMMA assignmentExpression )*
					{
<span class="nc" id="L7367">					pushFollow(FOLLOW_assignmentExpression_in_argumentExpressionList2962);</span>
<span class="nc" id="L7368">					assignmentExpression196=assignmentExpression();</span>
<span class="nc" id="L7369">					state._fsp--;</span>
<span class="nc bnc" id="L7370" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7371" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_assignmentExpression.add(assignmentExpression196.getTree());</span>
					// AcslParser.g:384:25: ( COMMA assignmentExpression )*
					loop41:
					while (true) {
<span class="nc" id="L7375">						int alt41=2;</span>
<span class="nc" id="L7376">						int LA41_0 = input.LA(1);</span>
<span class="nc bnc" id="L7377" title="All 2 branches missed.">						if ( (LA41_0==COMMA) ) {</span>
<span class="nc" id="L7378">							int LA41_2 = input.LA(2);</span>
<span class="nc bnc" id="L7379" title="All 2 branches missed.">							if ( (synpred79_AcslParser()) ) {</span>
<span class="nc" id="L7380">								alt41=1;</span>
							}

						}

<span class="nc bnc" id="L7385" title="All 2 branches missed.">						switch (alt41) {</span>
						case 1 :
							// AcslParser.g:384:26: COMMA assignmentExpression
							{
<span class="nc bnc" id="L7389" title="All 2 branches missed.">							COMMA197=(Token)match(input,COMMA,FOLLOW_COMMA_in_argumentExpressionList2965); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7390" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_COMMA.add(COMMA197);</span>

<span class="nc" id="L7392">							pushFollow(FOLLOW_assignmentExpression_in_argumentExpressionList2967);</span>
<span class="nc" id="L7393">							assignmentExpression198=assignmentExpression();</span>
<span class="nc" id="L7394">							state._fsp--;</span>
<span class="nc bnc" id="L7395" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L7396" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_assignmentExpression.add(assignmentExpression198.getTree());</span>
							}
							break;

						default :
<span class="nc" id="L7401">							break loop41;</span>
						}
<span class="nc" id="L7403">					}</span>

					// AST REWRITE
					// elements: assignmentExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7412" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7413">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7414" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7416">					root_0 = (Object)adaptor.nil();</span>
					// 385:4: -&gt; ^( ARGUMENT_LIST ( assignmentExpression )+ )
					{
						// AcslParser.g:385:7: ^( ARGUMENT_LIST ( assignmentExpression )+ )
						{
<span class="nc" id="L7421">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7422">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_1);</span>
<span class="nc bnc" id="L7423" title="All 2 branches missed.">						if ( !(stream_assignmentExpression.hasNext()) ) {</span>
<span class="nc" id="L7424">							throw new RewriteEarlyExitException();</span>
						}
<span class="nc bnc" id="L7426" title="All 2 branches missed.">						while ( stream_assignmentExpression.hasNext() ) {</span>
<span class="nc" id="L7427">							adaptor.addChild(root_1, stream_assignmentExpression.nextTree());</span>
						}
<span class="nc" id="L7429">						stream_assignmentExpression.reset();</span>

<span class="nc" id="L7431">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7437">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L7444">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L7446" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7447">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L7448">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L7451">		catch (RecognitionException re) {</span>
<span class="nc" id="L7452">			reportError(re);</span>
<span class="nc" id="L7453">			recover(input,re);</span>
<span class="nc" id="L7454">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L7456">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L7458">		}</span>
<span class="nc" id="L7459">		return retval;</span>
	}
	// $ANTLR end &quot;argumentExpressionList&quot;


<span class="nc" id="L7464">	public static class unaryExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L7467">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;unaryExpression&quot;
	// AcslParser.g:389:1: unaryExpression : ( postfixExpression | unary_op castExpression -&gt; ^( OPERATOR unary_op ^( ARGUMENT_LIST castExpression ) ) | ( SIZEOF LPAREN type_expr )=&gt; SIZEOF LPAREN type_expr RPAREN -&gt; ^( SIZEOF_TYPE type_expr ) | SIZEOF unaryExpression -&gt; ^( SIZEOF_EXPR unaryExpression ) | UNION LPAREN argumentExpressionList RPAREN -&gt; ^( UNION argumentExpressionList ) | INTER LPAREN argumentExpressionList RPAREN -&gt; ^( INTER argumentExpressionList ) | VALID LPAREN term RPAREN -&gt; ^( VALID term ) );
	public final AcslParser.unaryExpression_return unaryExpression() throws RecognitionException {
<span class="nc" id="L7474">		AcslParser.unaryExpression_return retval = new AcslParser.unaryExpression_return();</span>
<span class="nc" id="L7475">		retval.start = input.LT(1);</span>

<span class="nc" id="L7477">		Object root_0 = null;</span>

<span class="nc" id="L7479">		Token SIZEOF202=null;</span>
<span class="nc" id="L7480">		Token LPAREN203=null;</span>
<span class="nc" id="L7481">		Token RPAREN205=null;</span>
<span class="nc" id="L7482">		Token SIZEOF206=null;</span>
<span class="nc" id="L7483">		Token UNION208=null;</span>
<span class="nc" id="L7484">		Token LPAREN209=null;</span>
<span class="nc" id="L7485">		Token RPAREN211=null;</span>
<span class="nc" id="L7486">		Token INTER212=null;</span>
<span class="nc" id="L7487">		Token LPAREN213=null;</span>
<span class="nc" id="L7488">		Token RPAREN215=null;</span>
<span class="nc" id="L7489">		Token VALID216=null;</span>
<span class="nc" id="L7490">		Token LPAREN217=null;</span>
<span class="nc" id="L7491">		Token RPAREN219=null;</span>
<span class="nc" id="L7492">		ParserRuleReturnScope postfixExpression199 =null;</span>
<span class="nc" id="L7493">		ParserRuleReturnScope unary_op200 =null;</span>
<span class="nc" id="L7494">		ParserRuleReturnScope castExpression201 =null;</span>
<span class="nc" id="L7495">		ParserRuleReturnScope type_expr204 =null;</span>
<span class="nc" id="L7496">		ParserRuleReturnScope unaryExpression207 =null;</span>
<span class="nc" id="L7497">		ParserRuleReturnScope argumentExpressionList210 =null;</span>
<span class="nc" id="L7498">		ParserRuleReturnScope argumentExpressionList214 =null;</span>
<span class="nc" id="L7499">		ParserRuleReturnScope term218 =null;</span>

<span class="nc" id="L7501">		Object SIZEOF202_tree=null;</span>
<span class="nc" id="L7502">		Object LPAREN203_tree=null;</span>
<span class="nc" id="L7503">		Object RPAREN205_tree=null;</span>
<span class="nc" id="L7504">		Object SIZEOF206_tree=null;</span>
<span class="nc" id="L7505">		Object UNION208_tree=null;</span>
<span class="nc" id="L7506">		Object LPAREN209_tree=null;</span>
<span class="nc" id="L7507">		Object RPAREN211_tree=null;</span>
<span class="nc" id="L7508">		Object INTER212_tree=null;</span>
<span class="nc" id="L7509">		Object LPAREN213_tree=null;</span>
<span class="nc" id="L7510">		Object RPAREN215_tree=null;</span>
<span class="nc" id="L7511">		Object VALID216_tree=null;</span>
<span class="nc" id="L7512">		Object LPAREN217_tree=null;</span>
<span class="nc" id="L7513">		Object RPAREN219_tree=null;</span>
<span class="nc" id="L7514">		RewriteRuleTokenStream stream_SIZEOF=new RewriteRuleTokenStream(adaptor,&quot;token SIZEOF&quot;);</span>
<span class="nc" id="L7515">		RewriteRuleTokenStream stream_INTER=new RewriteRuleTokenStream(adaptor,&quot;token INTER&quot;);</span>
<span class="nc" id="L7516">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L7517">		RewriteRuleTokenStream stream_UNION=new RewriteRuleTokenStream(adaptor,&quot;token UNION&quot;);</span>
<span class="nc" id="L7518">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L7519">		RewriteRuleTokenStream stream_VALID=new RewriteRuleTokenStream(adaptor,&quot;token VALID&quot;);</span>
<span class="nc" id="L7520">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L7521">		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule unaryExpression&quot;);</span>
<span class="nc" id="L7522">		RewriteRuleSubtreeStream stream_castExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule castExpression&quot;);</span>
<span class="nc" id="L7523">		RewriteRuleSubtreeStream stream_argumentExpressionList=new RewriteRuleSubtreeStream(adaptor,&quot;rule argumentExpressionList&quot;);</span>
<span class="nc" id="L7524">		RewriteRuleSubtreeStream stream_type_expr=new RewriteRuleSubtreeStream(adaptor,&quot;rule type_expr&quot;);</span>
<span class="nc" id="L7525">		RewriteRuleSubtreeStream stream_unary_op=new RewriteRuleSubtreeStream(adaptor,&quot;rule unary_op&quot;);</span>

		try {
			// AcslParser.g:390:2: ( postfixExpression | unary_op castExpression -&gt; ^( OPERATOR unary_op ^( ARGUMENT_LIST castExpression ) ) | ( SIZEOF LPAREN type_expr )=&gt; SIZEOF LPAREN type_expr RPAREN -&gt; ^( SIZEOF_TYPE type_expr ) | SIZEOF unaryExpression -&gt; ^( SIZEOF_EXPR unaryExpression ) | UNION LPAREN argumentExpressionList RPAREN -&gt; ^( UNION argumentExpressionList ) | INTER LPAREN argumentExpressionList RPAREN -&gt; ^( INTER argumentExpressionList ) | VALID LPAREN term RPAREN -&gt; ^( VALID term ) )
<span class="nc" id="L7529">			int alt43=7;</span>
<span class="nc bnc" id="L7530" title="All 7 branches missed.">			switch ( input.LA(1) ) {</span>
			case ELLIPSIS:
			case FALSE:
			case FLOATING_CONSTANT:
			case ID:
			case INTEGER_CONSTANT:
			case LCURLY:
			case LPAREN:
			case MPI_AGREE:
			case MPI_COMM_RANK:
			case MPI_COMM_SIZE:
			case MPI_EMPTY_IN:
			case MPI_EMPTY_OUT:
			case MPI_EQUALS:
			case MPI_REGION:
			case NOTHING:
			case NULL:
			case REMOTE_ACCESS:
			case RESULT:
			case SELF:
			case STRING_LITERAL:
			case TRUE:
			case CHARACTER_CONSTANT:
				{
<span class="nc" id="L7554">				alt43=1;</span>
				}
<span class="nc" id="L7556">				break;</span>
			case AMPERSAND:
			case COMP:
			case NOT:
			case PLUS:
			case STAR:
			case MINUS:
				{
<span class="nc" id="L7564">				alt43=2;</span>
				}
<span class="nc" id="L7566">				break;</span>
			case SIZEOF:
				{
<span class="nc" id="L7569">				int LA43_3 = input.LA(2);</span>
<span class="nc bnc" id="L7570" title="All 2 branches missed.">				if ( (LA43_3==LPAREN) ) {</span>
<span class="nc" id="L7571">					int LA43_7 = input.LA(3);</span>
<span class="nc bnc" id="L7572" title="All 8 branches missed.">					if ( (LA43_7==BOOLEAN||LA43_7==INTEGER||LA43_7==REAL) &amp;&amp; (synpred82_AcslParser())) {</span>
<span class="nc" id="L7573">						alt43=3;</span>
					}
<span class="nc bnc" id="L7575" title="All 2 branches missed.">					else if ( (LA43_7==ID) ) {</span>
<span class="nc" id="L7576">						int LA43_10 = input.LA(4);</span>
<span class="nc bnc" id="L7577" title="All 2 branches missed.">						if ( (LA43_10==RPAREN) ) {</span>
<span class="nc" id="L7578">							int LA43_12 = input.LA(5);</span>
<span class="nc bnc" id="L7579" title="All 2 branches missed.">							if ( (synpred82_AcslParser()) ) {</span>
<span class="nc" id="L7580">								alt43=3;</span>
							}
<span class="nc bnc" id="L7582" title="All 2 branches missed.">							else if ( (synpred83_AcslParser()) ) {</span>
<span class="nc" id="L7583">								alt43=4;</span>
							}

							else {
<span class="nc bnc" id="L7587" title="All 2 branches missed.">								if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7588">								int nvaeMark = input.mark();</span>
								try {
<span class="nc bnc" id="L7590" title="All 2 branches missed.">									for (int nvaeConsume = 0; nvaeConsume &lt; 5 - 1; nvaeConsume++) {</span>
<span class="nc" id="L7591">										input.consume();</span>
									}
<span class="nc" id="L7593">									NoViableAltException nvae =</span>
										new NoViableAltException(&quot;&quot;, 43, 12, input);
<span class="nc" id="L7595">									throw nvae;</span>
								} finally {
<span class="nc" id="L7597">									input.rewind(nvaeMark);</span>
								}
							}

<span class="nc" id="L7601">						}</span>
<span class="nc bnc" id="L7602" title="All 46 branches missed.">						else if ( (LA43_10==AMPERSAND||(LA43_10 &gt;= ARROW &amp;&amp; LA43_10 &lt;= ASSIGN)||LA43_10==BAR||LA43_10==BITXOR||(LA43_10 &gt;= DIVIDE &amp;&amp; LA43_10 &lt;= DOTDOT)||LA43_10==EQ||(LA43_10 &gt;= GT &amp;&amp; LA43_10 &lt;= GTE)||LA43_10==HASH||LA43_10==IMPLY||LA43_10==LAND||(LA43_10 &gt;= LOR &amp;&amp; LA43_10 &lt;= LTE)||LA43_10==MOD||LA43_10==NEQ||LA43_10==PLUS||LA43_10==QUESTION||(LA43_10 &gt;= SHIFTLEFT &amp;&amp; LA43_10 &lt;= SHIFTRIGHT)||LA43_10==STAR||LA43_10==SUB) ) {</span>
<span class="nc" id="L7603">							alt43=4;</span>
						}

						else {
<span class="nc bnc" id="L7607" title="All 2 branches missed.">							if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7608">							int nvaeMark = input.mark();</span>
							try {
<span class="nc bnc" id="L7610" title="All 2 branches missed.">								for (int nvaeConsume = 0; nvaeConsume &lt; 4 - 1; nvaeConsume++) {</span>
<span class="nc" id="L7611">									input.consume();</span>
								}
<span class="nc" id="L7613">								NoViableAltException nvae =</span>
									new NoViableAltException(&quot;&quot;, 43, 10, input);
<span class="nc" id="L7615">								throw nvae;</span>
							} finally {
<span class="nc" id="L7617">								input.rewind(nvaeMark);</span>
							}
						}

<span class="nc" id="L7621">					}</span>
<span class="nc bnc" id="L7622" title="All 16 branches missed.">					else if ( (LA43_7==CHAR||LA43_7==DOUBLE||LA43_7==FLOAT||LA43_7==INT||LA43_7==LONG||LA43_7==SHORT||LA43_7==VOID) &amp;&amp; (synpred82_AcslParser())) {</span>
<span class="nc" id="L7623">						alt43=3;</span>
					}
<span class="nc bnc" id="L7625" title="All 54 branches missed.">					else if ( (LA43_7==AMPERSAND||LA43_7==COMP||LA43_7==ELLIPSIS||LA43_7==EXISTS||LA43_7==FALSE||LA43_7==FLOATING_CONSTANT||LA43_7==FORALL||(LA43_7 &gt;= INTEGER_CONSTANT &amp;&amp; LA43_7 &lt;= INTER)||LA43_7==LCURLY||LA43_7==LPAREN||LA43_7==MPI_AGREE||(LA43_7 &gt;= MPI_COMM_RANK &amp;&amp; LA43_7 &lt;= MPI_REGION)||(LA43_7 &gt;= NOT &amp;&amp; LA43_7 &lt;= NULL)||LA43_7==PLUS||LA43_7==REMOTE_ACCESS||LA43_7==RESULT||LA43_7==SELF||(LA43_7 &gt;= SIZEOF &amp;&amp; LA43_7 &lt;= STRING_LITERAL)||(LA43_7 &gt;= TRUE &amp;&amp; LA43_7 &lt;= UNION)||LA43_7==VALID||LA43_7==CHARACTER_CONSTANT||LA43_7==MINUS) ) {</span>
<span class="nc" id="L7626">						alt43=4;</span>
					}

					else {
<span class="nc bnc" id="L7630" title="All 2 branches missed.">						if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7631">						int nvaeMark = input.mark();</span>
						try {
<span class="nc bnc" id="L7633" title="All 2 branches missed.">							for (int nvaeConsume = 0; nvaeConsume &lt; 3 - 1; nvaeConsume++) {</span>
<span class="nc" id="L7634">								input.consume();</span>
							}
<span class="nc" id="L7636">							NoViableAltException nvae =</span>
								new NoViableAltException(&quot;&quot;, 43, 7, input);
<span class="nc" id="L7638">							throw nvae;</span>
						} finally {
<span class="nc" id="L7640">							input.rewind(nvaeMark);</span>
						}
					}

<span class="nc" id="L7644">				}</span>
<span class="nc bnc" id="L7645" title="All 50 branches missed.">				else if ( (LA43_3==AMPERSAND||LA43_3==COMP||LA43_3==ELLIPSIS||LA43_3==FALSE||LA43_3==FLOATING_CONSTANT||LA43_3==ID||(LA43_3 &gt;= INTEGER_CONSTANT &amp;&amp; LA43_3 &lt;= INTER)||LA43_3==LCURLY||LA43_3==MPI_AGREE||(LA43_3 &gt;= MPI_COMM_RANK &amp;&amp; LA43_3 &lt;= MPI_REGION)||(LA43_3 &gt;= NOT &amp;&amp; LA43_3 &lt;= NULL)||LA43_3==PLUS||LA43_3==REMOTE_ACCESS||LA43_3==RESULT||LA43_3==SELF||(LA43_3 &gt;= SIZEOF &amp;&amp; LA43_3 &lt;= STRING_LITERAL)||(LA43_3 &gt;= TRUE &amp;&amp; LA43_3 &lt;= UNION)||LA43_3==VALID||LA43_3==CHARACTER_CONSTANT||LA43_3==MINUS) ) {</span>
<span class="nc" id="L7646">					alt43=4;</span>
				}

				else {
<span class="nc bnc" id="L7650" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7651">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L7653">						input.consume();</span>
<span class="nc" id="L7654">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 43, 3, input);
<span class="nc" id="L7656">						throw nvae;</span>
					} finally {
<span class="nc" id="L7658">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L7663">				break;</span>
			case UNION:
				{
<span class="nc" id="L7666">				alt43=5;</span>
				}
<span class="nc" id="L7668">				break;</span>
			case INTER:
				{
<span class="nc" id="L7671">				alt43=6;</span>
				}
<span class="nc" id="L7673">				break;</span>
			case VALID:
				{
<span class="nc" id="L7676">				alt43=7;</span>
				}
<span class="nc" id="L7678">				break;</span>
			default:
<span class="nc bnc" id="L7680" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L7681">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 43, 0, input);
<span class="nc" id="L7683">				throw nvae;</span>
			}
<span class="nc bnc" id="L7685" title="All 8 branches missed.">			switch (alt43) {</span>
				case 1 :
					// AcslParser.g:390:4: postfixExpression
					{
<span class="nc" id="L7689">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L7692">					pushFollow(FOLLOW_postfixExpression_in_unaryExpression2994);</span>
<span class="nc" id="L7693">					postfixExpression199=postfixExpression();</span>
<span class="nc" id="L7694">					state._fsp--;</span>
<span class="nc bnc" id="L7695" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7696" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, postfixExpression199.getTree());</span>

					}
					break;
				case 2 :
					// AcslParser.g:391:4: unary_op castExpression
					{
<span class="nc" id="L7703">					pushFollow(FOLLOW_unary_op_in_unaryExpression2999);</span>
<span class="nc" id="L7704">					unary_op200=unary_op();</span>
<span class="nc" id="L7705">					state._fsp--;</span>
<span class="nc bnc" id="L7706" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7707" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_unary_op.add(unary_op200.getTree());</span>
<span class="nc" id="L7708">					pushFollow(FOLLOW_castExpression_in_unaryExpression3001);</span>
<span class="nc" id="L7709">					castExpression201=castExpression();</span>
<span class="nc" id="L7710">					state._fsp--;</span>
<span class="nc bnc" id="L7711" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7712" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_castExpression.add(castExpression201.getTree());</span>
					// AST REWRITE
					// elements: unary_op, castExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7720" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7721">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7722" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7724">					root_0 = (Object)adaptor.nil();</span>
					// 392:4: -&gt; ^( OPERATOR unary_op ^( ARGUMENT_LIST castExpression ) )
					{
						// AcslParser.g:392:7: ^( OPERATOR unary_op ^( ARGUMENT_LIST castExpression ) )
						{
<span class="nc" id="L7729">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7730">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L7731">						adaptor.addChild(root_1, stream_unary_op.nextTree());</span>
						// AcslParser.g:392:27: ^( ARGUMENT_LIST castExpression )
						{
<span class="nc" id="L7734">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L7735">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L7736">						adaptor.addChild(root_2, stream_castExpression.nextTree());</span>
<span class="nc" id="L7737">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L7740">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7746">					retval.tree = root_0;</span>
<span class="nc" id="L7747">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:393:4: ( SIZEOF LPAREN type_expr )=&gt; SIZEOF LPAREN type_expr RPAREN
					{
<span class="nc bnc" id="L7754" title="All 2 branches missed.">					SIZEOF202=(Token)match(input,SIZEOF,FOLLOW_SIZEOF_in_unaryExpression3032); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7755" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SIZEOF.add(SIZEOF202);</span>

<span class="nc bnc" id="L7757" title="All 2 branches missed.">					LPAREN203=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_unaryExpression3034); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7758" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN203);</span>

<span class="nc" id="L7760">					pushFollow(FOLLOW_type_expr_in_unaryExpression3036);</span>
<span class="nc" id="L7761">					type_expr204=type_expr();</span>
<span class="nc" id="L7762">					state._fsp--;</span>
<span class="nc bnc" id="L7763" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7764" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_type_expr.add(type_expr204.getTree());</span>
<span class="nc bnc" id="L7765" title="All 2 branches missed.">					RPAREN205=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_unaryExpression3038); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7766" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN205);</span>

					// AST REWRITE
					// elements: type_expr
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7775" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7776">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7777" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7779">					root_0 = (Object)adaptor.nil();</span>
					// 394:4: -&gt; ^( SIZEOF_TYPE type_expr )
					{
						// AcslParser.g:394:7: ^( SIZEOF_TYPE type_expr )
						{
<span class="nc" id="L7784">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7785">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SIZEOF_TYPE, &quot;SIZEOF_TYPE&quot;), root_1);</span>
<span class="nc" id="L7786">						adaptor.addChild(root_1, stream_type_expr.nextTree());</span>
<span class="nc" id="L7787">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7793">					retval.tree = root_0;</span>
<span class="nc" id="L7794">					}</span>

					}
					break;
				case 4 :
					// AcslParser.g:395:4: SIZEOF unaryExpression
					{
<span class="nc bnc" id="L7801" title="All 2 branches missed.">					SIZEOF206=(Token)match(input,SIZEOF,FOLLOW_SIZEOF_in_unaryExpression3054); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7802" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SIZEOF.add(SIZEOF206);</span>

<span class="nc" id="L7804">					pushFollow(FOLLOW_unaryExpression_in_unaryExpression3056);</span>
<span class="nc" id="L7805">					unaryExpression207=unaryExpression();</span>
<span class="nc" id="L7806">					state._fsp--;</span>
<span class="nc bnc" id="L7807" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7808" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_unaryExpression.add(unaryExpression207.getTree());</span>
					// AST REWRITE
					// elements: unaryExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7816" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7817">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7818" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7820">					root_0 = (Object)adaptor.nil();</span>
					// 396:4: -&gt; ^( SIZEOF_EXPR unaryExpression )
					{
						// AcslParser.g:396:7: ^( SIZEOF_EXPR unaryExpression )
						{
<span class="nc" id="L7825">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7826">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(SIZEOF_EXPR, &quot;SIZEOF_EXPR&quot;), root_1);</span>
<span class="nc" id="L7827">						adaptor.addChild(root_1, stream_unaryExpression.nextTree());</span>
<span class="nc" id="L7828">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7834">					retval.tree = root_0;</span>
<span class="nc" id="L7835">					}</span>

					}
					break;
				case 5 :
					// AcslParser.g:398:7: UNION LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L7842" title="All 2 branches missed.">					UNION208=(Token)match(input,UNION,FOLLOW_UNION_in_unaryExpression3077); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7843" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_UNION.add(UNION208);</span>

<span class="nc bnc" id="L7845" title="All 2 branches missed.">					LPAREN209=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_unaryExpression3079); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7846" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN209);</span>

<span class="nc" id="L7848">					pushFollow(FOLLOW_argumentExpressionList_in_unaryExpression3081);</span>
<span class="nc" id="L7849">					argumentExpressionList210=argumentExpressionList();</span>
<span class="nc" id="L7850">					state._fsp--;</span>
<span class="nc bnc" id="L7851" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7852" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList210.getTree());</span>
<span class="nc bnc" id="L7853" title="All 2 branches missed.">					RPAREN211=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_unaryExpression3083); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7854" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN211);</span>

					// AST REWRITE
					// elements: argumentExpressionList, UNION
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7863" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7864">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7865" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7867">					root_0 = (Object)adaptor.nil();</span>
					// 399:9: -&gt; ^( UNION argumentExpressionList )
					{
						// AcslParser.g:399:12: ^( UNION argumentExpressionList )
						{
<span class="nc" id="L7872">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7873">						root_1 = (Object)adaptor.becomeRoot(stream_UNION.nextNode(), root_1);</span>
<span class="nc" id="L7874">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L7875">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7881">					retval.tree = root_0;</span>
<span class="nc" id="L7882">					}</span>

					}
					break;
				case 6 :
					// AcslParser.g:400:7: INTER LPAREN argumentExpressionList RPAREN
					{
<span class="nc bnc" id="L7889" title="All 2 branches missed.">					INTER212=(Token)match(input,INTER,FOLLOW_INTER_in_unaryExpression3107); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7890" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_INTER.add(INTER212);</span>

<span class="nc bnc" id="L7892" title="All 2 branches missed.">					LPAREN213=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_unaryExpression3109); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7893" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN213);</span>

<span class="nc" id="L7895">					pushFollow(FOLLOW_argumentExpressionList_in_unaryExpression3111);</span>
<span class="nc" id="L7896">					argumentExpressionList214=argumentExpressionList();</span>
<span class="nc" id="L7897">					state._fsp--;</span>
<span class="nc bnc" id="L7898" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7899" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_argumentExpressionList.add(argumentExpressionList214.getTree());</span>
<span class="nc bnc" id="L7900" title="All 2 branches missed.">					RPAREN215=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_unaryExpression3113); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7901" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN215);</span>

					// AST REWRITE
					// elements: argumentExpressionList, INTER
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7910" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7911">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7912" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7914">					root_0 = (Object)adaptor.nil();</span>
					// 401:9: -&gt; ^( INTER argumentExpressionList )
					{
						// AcslParser.g:401:12: ^( INTER argumentExpressionList )
						{
<span class="nc" id="L7919">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7920">						root_1 = (Object)adaptor.becomeRoot(stream_INTER.nextNode(), root_1);</span>
<span class="nc" id="L7921">						adaptor.addChild(root_1, stream_argumentExpressionList.nextTree());</span>
<span class="nc" id="L7922">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7928">					retval.tree = root_0;</span>
<span class="nc" id="L7929">					}</span>

					}
					break;
				case 7 :
					// AcslParser.g:402:7: VALID LPAREN term RPAREN
					{
<span class="nc bnc" id="L7936" title="All 2 branches missed.">					VALID216=(Token)match(input,VALID,FOLLOW_VALID_in_unaryExpression3137); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7937" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_VALID.add(VALID216);</span>

<span class="nc bnc" id="L7939" title="All 2 branches missed.">					LPAREN217=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_unaryExpression3139); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7940" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN217);</span>

<span class="nc" id="L7942">					pushFollow(FOLLOW_term_in_unaryExpression3141);</span>
<span class="nc" id="L7943">					term218=term();</span>
<span class="nc" id="L7944">					state._fsp--;</span>
<span class="nc bnc" id="L7945" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L7946" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term218.getTree());</span>
<span class="nc bnc" id="L7947" title="All 2 branches missed.">					RPAREN219=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_unaryExpression3143); if (state.failed) return retval; </span>
<span class="nc bnc" id="L7948" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN219);</span>

					// AST REWRITE
					// elements: term, VALID
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L7957" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7958">					retval.tree = root_0;</span>
<span class="nc bnc" id="L7959" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L7961">					root_0 = (Object)adaptor.nil();</span>
					// 403:9: -&gt; ^( VALID term )
					{
						// AcslParser.g:403:12: ^( VALID term )
						{
<span class="nc" id="L7966">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L7967">						root_1 = (Object)adaptor.becomeRoot(stream_VALID.nextNode(), root_1);</span>
<span class="nc" id="L7968">						adaptor.addChild(root_1, stream_term.nextTree());</span>
<span class="nc" id="L7969">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L7975">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L7982">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L7984" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L7985">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L7986">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L7989">		catch (RecognitionException re) {</span>
<span class="nc" id="L7990">			reportError(re);</span>
<span class="nc" id="L7991">			recover(input,re);</span>
<span class="nc" id="L7992">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L7994">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L7996">		}</span>
<span class="nc" id="L7997">		return retval;</span>
	}
	// $ANTLR end &quot;unaryExpression&quot;


<span class="nc" id="L8002">	public static class castExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8005">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;castExpression&quot;
	// AcslParser.g:419:1: castExpression : ( ( LPAREN type_expr RPAREN )=&gt;l= LPAREN type_expr RPAREN castExpression -&gt; ^( CAST type_expr castExpression ) | unaryExpression );
	public final AcslParser.castExpression_return castExpression() throws RecognitionException {
<span class="nc" id="L8012">		AcslParser.castExpression_return retval = new AcslParser.castExpression_return();</span>
<span class="nc" id="L8013">		retval.start = input.LT(1);</span>

<span class="nc" id="L8015">		Object root_0 = null;</span>

<span class="nc" id="L8017">		Token l=null;</span>
<span class="nc" id="L8018">		Token RPAREN221=null;</span>
<span class="nc" id="L8019">		ParserRuleReturnScope type_expr220 =null;</span>
<span class="nc" id="L8020">		ParserRuleReturnScope castExpression222 =null;</span>
<span class="nc" id="L8021">		ParserRuleReturnScope unaryExpression223 =null;</span>

<span class="nc" id="L8023">		Object l_tree=null;</span>
<span class="nc" id="L8024">		Object RPAREN221_tree=null;</span>
<span class="nc" id="L8025">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L8026">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L8027">		RewriteRuleSubtreeStream stream_castExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule castExpression&quot;);</span>
<span class="nc" id="L8028">		RewriteRuleSubtreeStream stream_type_expr=new RewriteRuleSubtreeStream(adaptor,&quot;rule type_expr&quot;);</span>

		try {
			// AcslParser.g:420:2: ( ( LPAREN type_expr RPAREN )=&gt;l= LPAREN type_expr RPAREN castExpression -&gt; ^( CAST type_expr castExpression ) | unaryExpression )
<span class="nc" id="L8032">			int alt44=2;</span>
<span class="nc" id="L8033">			int LA44_0 = input.LA(1);</span>
<span class="nc bnc" id="L8034" title="All 2 branches missed.">			if ( (LA44_0==LPAREN) ) {</span>
<span class="nc" id="L8035">				int LA44_1 = input.LA(2);</span>
<span class="nc bnc" id="L8036" title="All 2 branches missed.">				if ( (synpred86_AcslParser()) ) {</span>
<span class="nc" id="L8037">					alt44=1;</span>
				}
				else if ( (true) ) {
<span class="nc" id="L8040">					alt44=2;</span>
				}

<span class="nc" id="L8043">			}</span>
<span class="nc bnc" id="L8044" title="All 50 branches missed.">			else if ( (LA44_0==AMPERSAND||LA44_0==COMP||LA44_0==ELLIPSIS||LA44_0==FALSE||LA44_0==FLOATING_CONSTANT||LA44_0==ID||(LA44_0 &gt;= INTEGER_CONSTANT &amp;&amp; LA44_0 &lt;= INTER)||LA44_0==LCURLY||LA44_0==MPI_AGREE||(LA44_0 &gt;= MPI_COMM_RANK &amp;&amp; LA44_0 &lt;= MPI_REGION)||(LA44_0 &gt;= NOT &amp;&amp; LA44_0 &lt;= NULL)||LA44_0==PLUS||LA44_0==REMOTE_ACCESS||LA44_0==RESULT||LA44_0==SELF||(LA44_0 &gt;= SIZEOF &amp;&amp; LA44_0 &lt;= STRING_LITERAL)||(LA44_0 &gt;= TRUE &amp;&amp; LA44_0 &lt;= UNION)||LA44_0==VALID||LA44_0==CHARACTER_CONSTANT||LA44_0==MINUS) ) {</span>
<span class="nc" id="L8045">				alt44=2;</span>
			}

			else {
<span class="nc bnc" id="L8049" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L8050">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 44, 0, input);
<span class="nc" id="L8052">				throw nvae;</span>
			}

<span class="nc bnc" id="L8055" title="All 3 branches missed.">			switch (alt44) {</span>
				case 1 :
					// AcslParser.g:420:4: ( LPAREN type_expr RPAREN )=&gt;l= LPAREN type_expr RPAREN castExpression
					{
<span class="nc bnc" id="L8059" title="All 2 branches missed.">					l=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_castExpression3213); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8060" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(l);</span>

<span class="nc" id="L8062">					pushFollow(FOLLOW_type_expr_in_castExpression3215);</span>
<span class="nc" id="L8063">					type_expr220=type_expr();</span>
<span class="nc" id="L8064">					state._fsp--;</span>
<span class="nc bnc" id="L8065" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8066" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_type_expr.add(type_expr220.getTree());</span>
<span class="nc bnc" id="L8067" title="All 2 branches missed.">					RPAREN221=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_castExpression3217); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8068" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN221);</span>

<span class="nc" id="L8070">					pushFollow(FOLLOW_castExpression_in_castExpression3219);</span>
<span class="nc" id="L8071">					castExpression222=castExpression();</span>
<span class="nc" id="L8072">					state._fsp--;</span>
<span class="nc bnc" id="L8073" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8074" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_castExpression.add(castExpression222.getTree());</span>
					// AST REWRITE
					// elements: type_expr, castExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8082" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8083">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8084" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L8086">					root_0 = (Object)adaptor.nil();</span>
					// 421:4: -&gt; ^( CAST type_expr castExpression )
					{
						// AcslParser.g:421:7: ^( CAST type_expr castExpression )
						{
<span class="nc" id="L8091">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8092">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(CAST, &quot;CAST&quot;), root_1);</span>
<span class="nc" id="L8093">						adaptor.addChild(root_1, stream_type_expr.nextTree());</span>
<span class="nc" id="L8094">						adaptor.addChild(root_1, stream_castExpression.nextTree());</span>
<span class="nc" id="L8095">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8101">					retval.tree = root_0;</span>
<span class="nc" id="L8102">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:422:4: unaryExpression
					{
<span class="nc" id="L8109">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L8112">					pushFollow(FOLLOW_unaryExpression_in_castExpression3237);</span>
<span class="nc" id="L8113">					unaryExpression223=unaryExpression();</span>
<span class="nc" id="L8114">					state._fsp--;</span>
<span class="nc bnc" id="L8115" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8116" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, unaryExpression223.getTree());</span>

					}
					break;

			}
<span class="nc" id="L8122">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L8124" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8125">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L8126">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L8129">		catch (RecognitionException re) {</span>
<span class="nc" id="L8130">			reportError(re);</span>
<span class="nc" id="L8131">			recover(input,re);</span>
<span class="nc" id="L8132">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L8134">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L8136">		}</span>
<span class="nc" id="L8137">		return retval;</span>
	}
	// $ANTLR end &quot;castExpression&quot;


<span class="nc" id="L8142">	public static class remoteExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8145">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;remoteExpression&quot;
	// AcslParser.g:425:1: remoteExpression : ( castExpression -&gt; castExpression ) ( HASH y= castExpression -&gt; ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) ) )* ;
	public final AcslParser.remoteExpression_return remoteExpression() throws RecognitionException {
<span class="nc" id="L8152">		AcslParser.remoteExpression_return retval = new AcslParser.remoteExpression_return();</span>
<span class="nc" id="L8153">		retval.start = input.LT(1);</span>

<span class="nc" id="L8155">		Object root_0 = null;</span>

<span class="nc" id="L8157">		Token HASH225=null;</span>
<span class="nc" id="L8158">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L8159">		ParserRuleReturnScope castExpression224 =null;</span>

<span class="nc" id="L8161">		Object HASH225_tree=null;</span>
<span class="nc" id="L8162">		RewriteRuleTokenStream stream_HASH=new RewriteRuleTokenStream(adaptor,&quot;token HASH&quot;);</span>
<span class="nc" id="L8163">		RewriteRuleSubtreeStream stream_castExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule castExpression&quot;);</span>

		try {
			// AcslParser.g:426:2: ( ( castExpression -&gt; castExpression ) ( HASH y= castExpression -&gt; ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) ) )* )
			// AcslParser.g:426:3: ( castExpression -&gt; castExpression ) ( HASH y= castExpression -&gt; ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) ) )*
			{
			// AcslParser.g:426:3: ( castExpression -&gt; castExpression )
			// AcslParser.g:426:4: castExpression
			{
<span class="nc" id="L8172">			pushFollow(FOLLOW_castExpression_in_remoteExpression3248);</span>
<span class="nc" id="L8173">			castExpression224=castExpression();</span>
<span class="nc" id="L8174">			state._fsp--;</span>
<span class="nc bnc" id="L8175" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L8176" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_castExpression.add(castExpression224.getTree());</span>
			// AST REWRITE
			// elements: castExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L8184" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8185">			retval.tree = root_0;</span>
<span class="nc bnc" id="L8186" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L8188">			root_0 = (Object)adaptor.nil();</span>
			// 426:19: -&gt; castExpression
			{
<span class="nc" id="L8191">				adaptor.addChild(root_0, stream_castExpression.nextTree());</span>
			}


<span class="nc" id="L8195">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:427:2: ( HASH y= castExpression -&gt; ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) ) )*
			loop45:
			while (true) {
<span class="nc" id="L8203">				int alt45=2;</span>
<span class="nc" id="L8204">				int LA45_0 = input.LA(1);</span>
<span class="nc bnc" id="L8205" title="All 2 branches missed.">				if ( (LA45_0==HASH) ) {</span>
<span class="nc" id="L8206">					int LA45_27 = input.LA(2);</span>
<span class="nc bnc" id="L8207" title="All 2 branches missed.">					if ( (synpred87_AcslParser()) ) {</span>
<span class="nc" id="L8208">						alt45=1;</span>
					}

				}

<span class="nc bnc" id="L8213" title="All 2 branches missed.">				switch (alt45) {</span>
				case 1 :
					// AcslParser.g:427:4: HASH y= castExpression
					{
<span class="nc bnc" id="L8217" title="All 2 branches missed.">					HASH225=(Token)match(input,HASH,FOLLOW_HASH_in_remoteExpression3258); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8218" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_HASH.add(HASH225);</span>

<span class="nc" id="L8220">					pushFollow(FOLLOW_castExpression_in_remoteExpression3262);</span>
<span class="nc" id="L8221">					y=castExpression();</span>
<span class="nc" id="L8222">					state._fsp--;</span>
<span class="nc bnc" id="L8223" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8224" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_castExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: HASH, remoteExpression, y
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8232" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8233">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8234" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8235" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8237">					root_0 = (Object)adaptor.nil();</span>
					// 428:4: -&gt; ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) )
					{
						// AcslParser.g:428:7: ^( OPERATOR HASH ^( ARGUMENT_LIST $remoteExpression $y) )
						{
<span class="nc" id="L8242">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8243">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8244">						adaptor.addChild(root_1, stream_HASH.nextNode());</span>
						// AcslParser.g:428:23: ^( ARGUMENT_LIST $remoteExpression $y)
						{
<span class="nc" id="L8247">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8248">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8249">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8250">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8251">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8254">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8260">					retval.tree = root_0;</span>
<span class="nc" id="L8261">					}</span>

					}
					break;

				default :
<span class="nc" id="L8267">					break loop45;</span>
				}
<span class="nc" id="L8269">			}</span>

			}

<span class="nc" id="L8273">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L8275" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8276">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L8277">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L8280">		catch (RecognitionException re) {</span>
<span class="nc" id="L8281">			reportError(re);</span>
<span class="nc" id="L8282">			recover(input,re);</span>
<span class="nc" id="L8283">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L8285">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L8287">		}</span>
<span class="nc" id="L8288">		return retval;</span>
	}
	// $ANTLR end &quot;remoteExpression&quot;


<span class="nc" id="L8293">	public static class multiplicativeExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8296">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;multiplicativeExpression&quot;
	// AcslParser.g:433:1: multiplicativeExpression : ( remoteExpression -&gt; remoteExpression ) ( STAR y= remoteExpression -&gt; ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | DIVIDE y= remoteExpression -&gt; ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | MOD y= remoteExpression -&gt; ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) ) )* ;
	public final AcslParser.multiplicativeExpression_return multiplicativeExpression() throws RecognitionException {
<span class="nc" id="L8303">		AcslParser.multiplicativeExpression_return retval = new AcslParser.multiplicativeExpression_return();</span>
<span class="nc" id="L8304">		retval.start = input.LT(1);</span>

<span class="nc" id="L8306">		Object root_0 = null;</span>

<span class="nc" id="L8308">		Token STAR227=null;</span>
<span class="nc" id="L8309">		Token DIVIDE228=null;</span>
<span class="nc" id="L8310">		Token MOD229=null;</span>
<span class="nc" id="L8311">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L8312">		ParserRuleReturnScope remoteExpression226 =null;</span>

<span class="nc" id="L8314">		Object STAR227_tree=null;</span>
<span class="nc" id="L8315">		Object DIVIDE228_tree=null;</span>
<span class="nc" id="L8316">		Object MOD229_tree=null;</span>
<span class="nc" id="L8317">		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,&quot;token STAR&quot;);</span>
<span class="nc" id="L8318">		RewriteRuleTokenStream stream_MOD=new RewriteRuleTokenStream(adaptor,&quot;token MOD&quot;);</span>
<span class="nc" id="L8319">		RewriteRuleTokenStream stream_DIVIDE=new RewriteRuleTokenStream(adaptor,&quot;token DIVIDE&quot;);</span>
<span class="nc" id="L8320">		RewriteRuleSubtreeStream stream_remoteExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule remoteExpression&quot;);</span>

		try {
			// AcslParser.g:434:2: ( ( remoteExpression -&gt; remoteExpression ) ( STAR y= remoteExpression -&gt; ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | DIVIDE y= remoteExpression -&gt; ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | MOD y= remoteExpression -&gt; ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) ) )* )
			// AcslParser.g:434:4: ( remoteExpression -&gt; remoteExpression ) ( STAR y= remoteExpression -&gt; ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | DIVIDE y= remoteExpression -&gt; ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | MOD y= remoteExpression -&gt; ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) ) )*
			{
			// AcslParser.g:434:4: ( remoteExpression -&gt; remoteExpression )
			// AcslParser.g:434:5: remoteExpression
			{
<span class="nc" id="L8329">			pushFollow(FOLLOW_remoteExpression_in_multiplicativeExpression3304);</span>
<span class="nc" id="L8330">			remoteExpression226=remoteExpression();</span>
<span class="nc" id="L8331">			state._fsp--;</span>
<span class="nc bnc" id="L8332" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L8333" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_remoteExpression.add(remoteExpression226.getTree());</span>
			// AST REWRITE
			// elements: remoteExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L8341" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8342">			retval.tree = root_0;</span>
<span class="nc bnc" id="L8343" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L8345">			root_0 = (Object)adaptor.nil();</span>
			// 434:22: -&gt; remoteExpression
			{
<span class="nc" id="L8348">				adaptor.addChild(root_0, stream_remoteExpression.nextTree());</span>
			}


<span class="nc" id="L8352">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:435:2: ( STAR y= remoteExpression -&gt; ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | DIVIDE y= remoteExpression -&gt; ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) ) | MOD y= remoteExpression -&gt; ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) ) )*
			loop46:
			while (true) {
<span class="nc" id="L8360">				int alt46=4;</span>
<span class="nc bnc" id="L8361" title="All 4 branches missed.">				switch ( input.LA(1) ) {</span>
				case STAR:
					{
<span class="nc" id="L8364">					alt46=1;</span>
					}
<span class="nc" id="L8366">					break;</span>
				case DIVIDE:
					{
<span class="nc" id="L8369">					alt46=2;</span>
					}
<span class="nc" id="L8371">					break;</span>
				case MOD:
					{
<span class="nc" id="L8374">					alt46=3;</span>
					}
					break;
				}
<span class="nc bnc" id="L8378" title="All 4 branches missed.">				switch (alt46) {</span>
				case 1 :
					// AcslParser.g:435:4: STAR y= remoteExpression
					{
<span class="nc bnc" id="L8382" title="All 2 branches missed.">					STAR227=(Token)match(input,STAR,FOLLOW_STAR_in_multiplicativeExpression3314); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8383" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_STAR.add(STAR227);</span>

<span class="nc" id="L8385">					pushFollow(FOLLOW_remoteExpression_in_multiplicativeExpression3318);</span>
<span class="nc" id="L8386">					y=remoteExpression();</span>
<span class="nc" id="L8387">					state._fsp--;</span>
<span class="nc bnc" id="L8388" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8389" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_remoteExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, multiplicativeExpression, STAR
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8397" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8398">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8399" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8400" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8402">					root_0 = (Object)adaptor.nil();</span>
					// 436:4: -&gt; ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) )
					{
						// AcslParser.g:436:7: ^( OPERATOR STAR ^( ARGUMENT_LIST $multiplicativeExpression $y) )
						{
<span class="nc" id="L8407">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8408">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8409">						adaptor.addChild(root_1, stream_STAR.nextNode());</span>
						// AcslParser.g:436:23: ^( ARGUMENT_LIST $multiplicativeExpression $y)
						{
<span class="nc" id="L8412">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8413">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8414">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8415">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8416">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8419">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8425">					retval.tree = root_0;</span>
<span class="nc" id="L8426">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:437:4: DIVIDE y= remoteExpression
					{
<span class="nc bnc" id="L8433" title="All 2 branches missed.">					DIVIDE228=(Token)match(input,DIVIDE,FOLLOW_DIVIDE_in_multiplicativeExpression3344); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8434" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_DIVIDE.add(DIVIDE228);</span>

<span class="nc" id="L8436">					pushFollow(FOLLOW_remoteExpression_in_multiplicativeExpression3348);</span>
<span class="nc" id="L8437">					y=remoteExpression();</span>
<span class="nc" id="L8438">					state._fsp--;</span>
<span class="nc bnc" id="L8439" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8440" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_remoteExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, multiplicativeExpression, DIVIDE
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8448" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8449">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8450" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8451" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8453">					root_0 = (Object)adaptor.nil();</span>
					// 438:4: -&gt; ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) )
					{
						// AcslParser.g:438:7: ^( OPERATOR DIVIDE ^( ARGUMENT_LIST $multiplicativeExpression $y) )
						{
<span class="nc" id="L8458">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8459">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8460">						adaptor.addChild(root_1, stream_DIVIDE.nextNode());</span>
						// AcslParser.g:438:25: ^( ARGUMENT_LIST $multiplicativeExpression $y)
						{
<span class="nc" id="L8463">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8464">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8465">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8466">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8467">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8470">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8476">					retval.tree = root_0;</span>
<span class="nc" id="L8477">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:439:7: MOD y= remoteExpression
					{
<span class="nc bnc" id="L8484" title="All 2 branches missed.">					MOD229=(Token)match(input,MOD,FOLLOW_MOD_in_multiplicativeExpression3377); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8485" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MOD.add(MOD229);</span>

<span class="nc" id="L8487">					pushFollow(FOLLOW_remoteExpression_in_multiplicativeExpression3381);</span>
<span class="nc" id="L8488">					y=remoteExpression();</span>
<span class="nc" id="L8489">					state._fsp--;</span>
<span class="nc bnc" id="L8490" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8491" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_remoteExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: MOD, multiplicativeExpression, y
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8499" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8500">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8501" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8502" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8504">					root_0 = (Object)adaptor.nil();</span>
					// 440:4: -&gt; ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) )
					{
						// AcslParser.g:440:7: ^( OPERATOR MOD ^( ARGUMENT_LIST $multiplicativeExpression $y) )
						{
<span class="nc" id="L8509">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8510">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8511">						adaptor.addChild(root_1, stream_MOD.nextNode());</span>
						// AcslParser.g:440:22: ^( ARGUMENT_LIST $multiplicativeExpression $y)
						{
<span class="nc" id="L8514">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8515">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8516">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8517">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8518">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8521">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8527">					retval.tree = root_0;</span>
<span class="nc" id="L8528">					}</span>

					}
					break;

				default :
<span class="nc" id="L8534">					break loop46;</span>
				}
<span class="nc" id="L8536">			}</span>

			}

<span class="nc" id="L8540">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L8542" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8543">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L8544">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L8547">		catch (RecognitionException re) {</span>
<span class="nc" id="L8548">			reportError(re);</span>
<span class="nc" id="L8549">			recover(input,re);</span>
<span class="nc" id="L8550">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L8552">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L8554">		}</span>
<span class="nc" id="L8555">		return retval;</span>
	}
	// $ANTLR end &quot;multiplicativeExpression&quot;


<span class="nc" id="L8560">	public static class additiveExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8563">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;additiveExpression&quot;
	// AcslParser.g:445:1: additiveExpression : ( multiplicativeExpression -&gt; multiplicativeExpression ) ( PLUS y= multiplicativeExpression -&gt; ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) ) | SUB y= multiplicativeExpression -&gt; ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) ) )* ;
	public final AcslParser.additiveExpression_return additiveExpression() throws RecognitionException {
<span class="nc" id="L8570">		AcslParser.additiveExpression_return retval = new AcslParser.additiveExpression_return();</span>
<span class="nc" id="L8571">		retval.start = input.LT(1);</span>

<span class="nc" id="L8573">		Object root_0 = null;</span>

<span class="nc" id="L8575">		Token PLUS231=null;</span>
<span class="nc" id="L8576">		Token SUB232=null;</span>
<span class="nc" id="L8577">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L8578">		ParserRuleReturnScope multiplicativeExpression230 =null;</span>

<span class="nc" id="L8580">		Object PLUS231_tree=null;</span>
<span class="nc" id="L8581">		Object SUB232_tree=null;</span>
<span class="nc" id="L8582">		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,&quot;token PLUS&quot;);</span>
<span class="nc" id="L8583">		RewriteRuleTokenStream stream_SUB=new RewriteRuleTokenStream(adaptor,&quot;token SUB&quot;);</span>
<span class="nc" id="L8584">		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule multiplicativeExpression&quot;);</span>

		try {
			// AcslParser.g:446:2: ( ( multiplicativeExpression -&gt; multiplicativeExpression ) ( PLUS y= multiplicativeExpression -&gt; ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) ) | SUB y= multiplicativeExpression -&gt; ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) ) )* )
			// AcslParser.g:446:4: ( multiplicativeExpression -&gt; multiplicativeExpression ) ( PLUS y= multiplicativeExpression -&gt; ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) ) | SUB y= multiplicativeExpression -&gt; ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) ) )*
			{
			// AcslParser.g:446:4: ( multiplicativeExpression -&gt; multiplicativeExpression )
			// AcslParser.g:446:5: multiplicativeExpression
			{
<span class="nc" id="L8593">			pushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3423);</span>
<span class="nc" id="L8594">			multiplicativeExpression230=multiplicativeExpression();</span>
<span class="nc" id="L8595">			state._fsp--;</span>
<span class="nc bnc" id="L8596" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L8597" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_multiplicativeExpression.add(multiplicativeExpression230.getTree());</span>
			// AST REWRITE
			// elements: multiplicativeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L8605" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8606">			retval.tree = root_0;</span>
<span class="nc bnc" id="L8607" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L8609">			root_0 = (Object)adaptor.nil();</span>
			// 446:30: -&gt; multiplicativeExpression
			{
<span class="nc" id="L8612">				adaptor.addChild(root_0, stream_multiplicativeExpression.nextTree());</span>
			}


<span class="nc" id="L8616">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:447:9: ( PLUS y= multiplicativeExpression -&gt; ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) ) | SUB y= multiplicativeExpression -&gt; ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) ) )*
			loop47:
			while (true) {
<span class="nc" id="L8624">				int alt47=3;</span>
<span class="nc" id="L8625">				int LA47_0 = input.LA(1);</span>
<span class="nc bnc" id="L8626" title="All 2 branches missed.">				if ( (LA47_0==PLUS) ) {</span>
<span class="nc" id="L8627">					alt47=1;</span>
				}
<span class="nc bnc" id="L8629" title="All 2 branches missed.">				else if ( (LA47_0==SUB) ) {</span>
<span class="nc" id="L8630">					alt47=2;</span>
				}

<span class="nc bnc" id="L8633" title="All 3 branches missed.">				switch (alt47) {</span>
				case 1 :
					// AcslParser.g:447:11: PLUS y= multiplicativeExpression
					{
<span class="nc bnc" id="L8637" title="All 2 branches missed.">					PLUS231=(Token)match(input,PLUS,FOLLOW_PLUS_in_additiveExpression3440); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8638" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_PLUS.add(PLUS231);</span>

<span class="nc" id="L8640">					pushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3444);</span>
<span class="nc" id="L8641">					y=multiplicativeExpression();</span>
<span class="nc" id="L8642">					state._fsp--;</span>
<span class="nc bnc" id="L8643" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8644" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_multiplicativeExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: PLUS, y, additiveExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8652" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8653">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8654" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8655" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8657">					root_0 = (Object)adaptor.nil();</span>
					// 448:11: -&gt; ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) )
					{
						// AcslParser.g:448:14: ^( OPERATOR PLUS ^( ARGUMENT_LIST $additiveExpression $y) )
						{
<span class="nc" id="L8662">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8663">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8664">						adaptor.addChild(root_1, stream_PLUS.nextNode());</span>
						// AcslParser.g:448:30: ^( ARGUMENT_LIST $additiveExpression $y)
						{
<span class="nc" id="L8667">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8668">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8669">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8670">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8671">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8674">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8680">					retval.tree = root_0;</span>
<span class="nc" id="L8681">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:449:11: SUB y= multiplicativeExpression
					{
<span class="nc bnc" id="L8688" title="All 2 branches missed.">					SUB232=(Token)match(input,SUB,FOLLOW_SUB_in_additiveExpression3484); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8689" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SUB.add(SUB232);</span>

<span class="nc" id="L8691">					pushFollow(FOLLOW_multiplicativeExpression_in_additiveExpression3488);</span>
<span class="nc" id="L8692">					y=multiplicativeExpression();</span>
<span class="nc" id="L8693">					state._fsp--;</span>
<span class="nc bnc" id="L8694" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8695" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_multiplicativeExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, additiveExpression, SUB
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L8703" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8704">					retval.tree = root_0;</span>
<span class="nc bnc" id="L8705" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8706" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8708">					root_0 = (Object)adaptor.nil();</span>
					// 450:11: -&gt; ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) )
					{
						// AcslParser.g:450:14: ^( OPERATOR SUB ^( ARGUMENT_LIST $additiveExpression $y) )
						{
<span class="nc" id="L8713">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8714">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L8715">						adaptor.addChild(root_1, stream_SUB.nextNode());</span>
						// AcslParser.g:450:29: ^( ARGUMENT_LIST $additiveExpression $y)
						{
<span class="nc" id="L8718">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L8719">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L8720">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L8721">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L8722">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L8725">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L8731">					retval.tree = root_0;</span>
<span class="nc" id="L8732">					}</span>

					}
					break;

				default :
<span class="nc" id="L8738">					break loop47;</span>
				}
<span class="nc" id="L8740">			}</span>

			}

<span class="nc" id="L8744">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L8746" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8747">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L8748">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L8751">		catch (RecognitionException re) {</span>
<span class="nc" id="L8752">			reportError(re);</span>
<span class="nc" id="L8753">			recover(input,re);</span>
<span class="nc" id="L8754">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L8756">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L8758">		}</span>
<span class="nc" id="L8759">		return retval;</span>
	}
	// $ANTLR end &quot;additiveExpression&quot;


<span class="nc" id="L8764">	public static class rangeExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8767">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;rangeExpression&quot;
	// AcslParser.g:456:1: rangeExpression : ( additiveExpression -&gt; additiveExpression ) ( DOTDOT y= additiveExpression ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) ) )? ;
	public final AcslParser.rangeExpression_return rangeExpression() throws RecognitionException {
<span class="nc" id="L8774">		AcslParser.rangeExpression_return retval = new AcslParser.rangeExpression_return();</span>
<span class="nc" id="L8775">		retval.start = input.LT(1);</span>

<span class="nc" id="L8777">		Object root_0 = null;</span>

<span class="nc" id="L8779">		Token DOTDOT234=null;</span>
<span class="nc" id="L8780">		Token HASH235=null;</span>
<span class="nc" id="L8781">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L8782">		ParserRuleReturnScope z =null;</span>
<span class="nc" id="L8783">		ParserRuleReturnScope additiveExpression233 =null;</span>

<span class="nc" id="L8785">		Object DOTDOT234_tree=null;</span>
<span class="nc" id="L8786">		Object HASH235_tree=null;</span>
<span class="nc" id="L8787">		RewriteRuleTokenStream stream_HASH=new RewriteRuleTokenStream(adaptor,&quot;token HASH&quot;);</span>
<span class="nc" id="L8788">		RewriteRuleTokenStream stream_DOTDOT=new RewriteRuleTokenStream(adaptor,&quot;token DOTDOT&quot;);</span>
<span class="nc" id="L8789">		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule additiveExpression&quot;);</span>

		try {
			// AcslParser.g:457:2: ( ( additiveExpression -&gt; additiveExpression ) ( DOTDOT y= additiveExpression ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) ) )? )
			// AcslParser.g:457:4: ( additiveExpression -&gt; additiveExpression ) ( DOTDOT y= additiveExpression ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) ) )?
			{
			// AcslParser.g:457:4: ( additiveExpression -&gt; additiveExpression )
			// AcslParser.g:457:5: additiveExpression
			{
<span class="nc" id="L8798">			pushFollow(FOLLOW_additiveExpression_in_rangeExpression3542);</span>
<span class="nc" id="L8799">			additiveExpression233=additiveExpression();</span>
<span class="nc" id="L8800">			state._fsp--;</span>
<span class="nc bnc" id="L8801" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L8802" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_additiveExpression.add(additiveExpression233.getTree());</span>
			// AST REWRITE
			// elements: additiveExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L8810" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8811">			retval.tree = root_0;</span>
<span class="nc bnc" id="L8812" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L8814">			root_0 = (Object)adaptor.nil();</span>
			// 457:24: -&gt; additiveExpression
			{
<span class="nc" id="L8817">				adaptor.addChild(root_0, stream_additiveExpression.nextTree());</span>
			}


<span class="nc" id="L8821">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:458:7: ( DOTDOT y= additiveExpression ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) ) )?
<span class="nc" id="L8827">			int alt49=2;</span>
<span class="nc" id="L8828">			int LA49_0 = input.LA(1);</span>
<span class="nc bnc" id="L8829" title="All 2 branches missed.">			if ( (LA49_0==DOTDOT) ) {</span>
<span class="nc" id="L8830">				alt49=1;</span>
			}
<span class="nc bnc" id="L8832" title="All 2 branches missed.">			switch (alt49) {</span>
				case 1 :
					// AcslParser.g:458:9: DOTDOT y= additiveExpression ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) )
					{
<span class="nc bnc" id="L8836" title="All 2 branches missed.">					DOTDOT234=(Token)match(input,DOTDOT,FOLLOW_DOTDOT_in_rangeExpression3557); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8837" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_DOTDOT.add(DOTDOT234);</span>

<span class="nc" id="L8839">					pushFollow(FOLLOW_additiveExpression_in_rangeExpression3561);</span>
<span class="nc" id="L8840">					y=additiveExpression();</span>
<span class="nc" id="L8841">					state._fsp--;</span>
<span class="nc bnc" id="L8842" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L8843" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_additiveExpression.add(y.getTree());</span>
					// AcslParser.g:459:9: ( -&gt; ^( DOTDOT $rangeExpression $y) | HASH z= additiveExpression -&gt; ^( DOTDOT $rangeExpression $y $z) )
<span class="nc" id="L8845">					int alt48=2;</span>
<span class="nc" id="L8846">					int LA48_0 = input.LA(1);</span>
<span class="nc bnc" id="L8847" title="All 44 branches missed.">					if ( (LA48_0==EOF||LA48_0==AMPERSAND||LA48_0==BAR||LA48_0==BITXOR||(LA48_0 &gt;= COLON &amp;&amp; LA48_0 &lt;= COMMA)||LA48_0==EQ||LA48_0==FOR||(LA48_0 &gt;= GT &amp;&amp; LA48_0 &lt;= GTE)||LA48_0==IMPLY||LA48_0==LAND||LA48_0==LOR||(LA48_0 &gt;= LT &amp;&amp; LA48_0 &lt;= LTE)||LA48_0==NEQ||(LA48_0 &gt;= QUESTION &amp;&amp; LA48_0 &lt;= RCURLY)||(LA48_0 &gt;= RPAREN &amp;&amp; LA48_0 &lt;= RSQUARE)||(LA48_0 &gt;= SEMICOL &amp;&amp; LA48_0 &lt;= SHIFTRIGHT)) ) {</span>
<span class="nc" id="L8848">						alt48=1;</span>
					}
<span class="nc bnc" id="L8850" title="All 2 branches missed.">					else if ( (LA48_0==HASH) ) {</span>
<span class="nc" id="L8851">						alt48=2;</span>
					}

					else {
<span class="nc bnc" id="L8855" title="All 2 branches missed.">						if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L8856">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 48, 0, input);
<span class="nc" id="L8858">						throw nvae;</span>
					}

<span class="nc bnc" id="L8861" title="All 3 branches missed.">					switch (alt48) {</span>
						case 1 :
							// AcslParser.g:459:11: 
							{
							// AST REWRITE
							// elements: rangeExpression, DOTDOT, y
							// token labels: 
							// rule labels: retval, y
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
<span class="nc bnc" id="L8872" title="All 2 branches missed.">							if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8873">							retval.tree = root_0;</span>
<span class="nc bnc" id="L8874" title="All 2 branches missed.">							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8875" title="All 2 branches missed.">							RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8877">							root_0 = (Object)adaptor.nil();</span>
							// 459:11: -&gt; ^( DOTDOT $rangeExpression $y)
							{
								// AcslParser.g:459:14: ^( DOTDOT $rangeExpression $y)
								{
<span class="nc" id="L8882">								Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8883">								root_1 = (Object)adaptor.becomeRoot(stream_DOTDOT.nextNode(), root_1);</span>
<span class="nc" id="L8884">								adaptor.addChild(root_1, stream_retval.nextTree());</span>
<span class="nc" id="L8885">								adaptor.addChild(root_1, stream_y.nextTree());</span>
<span class="nc" id="L8886">								adaptor.addChild(root_0, root_1);</span>
								}

							}


<span class="nc" id="L8892">							retval.tree = root_0;</span>
<span class="nc" id="L8893">							}</span>

							}
							break;
						case 2 :
							// AcslParser.g:460:11: HASH z= additiveExpression
							{
<span class="nc bnc" id="L8900" title="All 2 branches missed.">							HASH235=(Token)match(input,HASH,FOLLOW_HASH_in_rangeExpression3595); if (state.failed) return retval; </span>
<span class="nc bnc" id="L8901" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_HASH.add(HASH235);</span>

<span class="nc" id="L8903">							pushFollow(FOLLOW_additiveExpression_in_rangeExpression3599);</span>
<span class="nc" id="L8904">							z=additiveExpression();</span>
<span class="nc" id="L8905">							state._fsp--;</span>
<span class="nc bnc" id="L8906" title="All 2 branches missed.">							if (state.failed) return retval;</span>
<span class="nc bnc" id="L8907" title="All 2 branches missed.">							if ( state.backtracking==0 ) stream_additiveExpression.add(z.getTree());</span>
							// AST REWRITE
							// elements: y, rangeExpression, z, DOTDOT
							// token labels: 
							// rule labels: retval, z, y
							// token list labels: 
							// rule list labels: 
							// wildcard labels: 
<span class="nc bnc" id="L8915" title="All 2 branches missed.">							if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8916">							retval.tree = root_0;</span>
<span class="nc bnc" id="L8917" title="All 2 branches missed.">							RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L8918" title="All 2 branches missed.">							RewriteRuleSubtreeStream stream_z=new RewriteRuleSubtreeStream(adaptor,&quot;rule z&quot;,z!=null?z.getTree():null);</span>
<span class="nc bnc" id="L8919" title="All 2 branches missed.">							RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L8921">							root_0 = (Object)adaptor.nil();</span>
							// 461:11: -&gt; ^( DOTDOT $rangeExpression $y $z)
							{
								// AcslParser.g:461:14: ^( DOTDOT $rangeExpression $y $z)
								{
<span class="nc" id="L8926">								Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L8927">								root_1 = (Object)adaptor.becomeRoot(stream_DOTDOT.nextNode(), root_1);</span>
<span class="nc" id="L8928">								adaptor.addChild(root_1, stream_retval.nextTree());</span>
<span class="nc" id="L8929">								adaptor.addChild(root_1, stream_y.nextTree());</span>
<span class="nc" id="L8930">								adaptor.addChild(root_1, stream_z.nextTree());</span>
<span class="nc" id="L8931">								adaptor.addChild(root_0, root_1);</span>
								}

							}


<span class="nc" id="L8937">							retval.tree = root_0;</span>
							}

							}
							break;

					}

					}
					break;

			}

			}

<span class="nc" id="L8952">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L8954" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L8955">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L8956">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L8959">		catch (RecognitionException re) {</span>
<span class="nc" id="L8960">			reportError(re);</span>
<span class="nc" id="L8961">			recover(input,re);</span>
<span class="nc" id="L8962">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L8964">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L8966">		}</span>
<span class="nc" id="L8967">		return retval;</span>
	}
	// $ANTLR end &quot;rangeExpression&quot;


<span class="nc" id="L8972">	public static class shiftExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L8975">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;shiftExpression&quot;
	// AcslParser.g:467:1: shiftExpression : ( rangeExpression -&gt; rangeExpression ) ( SHIFTLEFT y= rangeExpression -&gt; ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) ) | SHIFTRIGHT y= rangeExpression -&gt; ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) ) )* ;
	public final AcslParser.shiftExpression_return shiftExpression() throws RecognitionException {
<span class="nc" id="L8982">		AcslParser.shiftExpression_return retval = new AcslParser.shiftExpression_return();</span>
<span class="nc" id="L8983">		retval.start = input.LT(1);</span>

<span class="nc" id="L8985">		Object root_0 = null;</span>

<span class="nc" id="L8987">		Token SHIFTLEFT237=null;</span>
<span class="nc" id="L8988">		Token SHIFTRIGHT238=null;</span>
<span class="nc" id="L8989">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L8990">		ParserRuleReturnScope rangeExpression236 =null;</span>

<span class="nc" id="L8992">		Object SHIFTLEFT237_tree=null;</span>
<span class="nc" id="L8993">		Object SHIFTRIGHT238_tree=null;</span>
<span class="nc" id="L8994">		RewriteRuleTokenStream stream_SHIFTLEFT=new RewriteRuleTokenStream(adaptor,&quot;token SHIFTLEFT&quot;);</span>
<span class="nc" id="L8995">		RewriteRuleTokenStream stream_SHIFTRIGHT=new RewriteRuleTokenStream(adaptor,&quot;token SHIFTRIGHT&quot;);</span>
<span class="nc" id="L8996">		RewriteRuleSubtreeStream stream_rangeExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule rangeExpression&quot;);</span>

		try {
			// AcslParser.g:468:2: ( ( rangeExpression -&gt; rangeExpression ) ( SHIFTLEFT y= rangeExpression -&gt; ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) ) | SHIFTRIGHT y= rangeExpression -&gt; ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) ) )* )
			// AcslParser.g:468:4: ( rangeExpression -&gt; rangeExpression ) ( SHIFTLEFT y= rangeExpression -&gt; ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) ) | SHIFTRIGHT y= rangeExpression -&gt; ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) ) )*
			{
			// AcslParser.g:468:4: ( rangeExpression -&gt; rangeExpression )
			// AcslParser.g:468:5: rangeExpression
			{
<span class="nc" id="L9005">			pushFollow(FOLLOW_rangeExpression_in_shiftExpression3660);</span>
<span class="nc" id="L9006">			rangeExpression236=rangeExpression();</span>
<span class="nc" id="L9007">			state._fsp--;</span>
<span class="nc bnc" id="L9008" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9009" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_rangeExpression.add(rangeExpression236.getTree());</span>
			// AST REWRITE
			// elements: rangeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9017" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9018">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9019" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9021">			root_0 = (Object)adaptor.nil();</span>
			// 468:21: -&gt; rangeExpression
			{
<span class="nc" id="L9024">				adaptor.addChild(root_0, stream_rangeExpression.nextTree());</span>
			}


<span class="nc" id="L9028">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:469:9: ( SHIFTLEFT y= rangeExpression -&gt; ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) ) | SHIFTRIGHT y= rangeExpression -&gt; ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) ) )*
			loop50:
			while (true) {
<span class="nc" id="L9036">				int alt50=3;</span>
<span class="nc" id="L9037">				int LA50_0 = input.LA(1);</span>
<span class="nc bnc" id="L9038" title="All 2 branches missed.">				if ( (LA50_0==SHIFTLEFT) ) {</span>
<span class="nc" id="L9039">					alt50=1;</span>
				}
<span class="nc bnc" id="L9041" title="All 2 branches missed.">				else if ( (LA50_0==SHIFTRIGHT) ) {</span>
<span class="nc" id="L9042">					alt50=2;</span>
				}

<span class="nc bnc" id="L9045" title="All 3 branches missed.">				switch (alt50) {</span>
				case 1 :
					// AcslParser.g:469:11: SHIFTLEFT y= rangeExpression
					{
<span class="nc bnc" id="L9049" title="All 2 branches missed.">					SHIFTLEFT237=(Token)match(input,SHIFTLEFT,FOLLOW_SHIFTLEFT_in_shiftExpression3677); if (state.failed) return retval; </span>
<span class="nc bnc" id="L9050" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SHIFTLEFT.add(SHIFTLEFT237);</span>

<span class="nc" id="L9052">					pushFollow(FOLLOW_rangeExpression_in_shiftExpression3681);</span>
<span class="nc" id="L9053">					y=rangeExpression();</span>
<span class="nc" id="L9054">					state._fsp--;</span>
<span class="nc bnc" id="L9055" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9056" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_rangeExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: SHIFTLEFT, y, shiftExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9064" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9065">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9066" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9067" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9069">					root_0 = (Object)adaptor.nil();</span>
					// 470:11: -&gt; ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) )
					{
						// AcslParser.g:470:14: ^( OPERATOR SHIFTLEFT ^( ARGUMENT_LIST $shiftExpression $y) )
						{
<span class="nc" id="L9074">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9075">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9076">						adaptor.addChild(root_1, stream_SHIFTLEFT.nextNode());</span>
						// AcslParser.g:470:35: ^( ARGUMENT_LIST $shiftExpression $y)
						{
<span class="nc" id="L9079">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9080">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9081">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9082">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9083">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9086">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9092">					retval.tree = root_0;</span>
<span class="nc" id="L9093">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:471:11: SHIFTRIGHT y= rangeExpression
					{
<span class="nc bnc" id="L9100" title="All 2 branches missed.">					SHIFTRIGHT238=(Token)match(input,SHIFTRIGHT,FOLLOW_SHIFTRIGHT_in_shiftExpression3721); if (state.failed) return retval; </span>
<span class="nc bnc" id="L9101" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_SHIFTRIGHT.add(SHIFTRIGHT238);</span>

<span class="nc" id="L9103">					pushFollow(FOLLOW_rangeExpression_in_shiftExpression3725);</span>
<span class="nc" id="L9104">					y=rangeExpression();</span>
<span class="nc" id="L9105">					state._fsp--;</span>
<span class="nc bnc" id="L9106" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9107" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_rangeExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: SHIFTRIGHT, y, shiftExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9115" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9116">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9117" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9118" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9120">					root_0 = (Object)adaptor.nil();</span>
					// 472:11: -&gt; ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) )
					{
						// AcslParser.g:472:14: ^( OPERATOR SHIFTRIGHT ^( ARGUMENT_LIST $shiftExpression $y) )
						{
<span class="nc" id="L9125">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9126">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9127">						adaptor.addChild(root_1, stream_SHIFTRIGHT.nextNode());</span>
						// AcslParser.g:472:36: ^( ARGUMENT_LIST $shiftExpression $y)
						{
<span class="nc" id="L9130">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9131">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9132">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9133">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9134">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9137">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9143">					retval.tree = root_0;</span>
<span class="nc" id="L9144">					}</span>

					}
					break;

				default :
<span class="nc" id="L9150">					break loop50;</span>
				}
<span class="nc" id="L9152">			}</span>

			}

<span class="nc" id="L9156">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9158" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9159">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9160">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9163">		catch (RecognitionException re) {</span>
<span class="nc" id="L9164">			reportError(re);</span>
<span class="nc" id="L9165">			recover(input,re);</span>
<span class="nc" id="L9166">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9168">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9170">		}</span>
<span class="nc" id="L9171">		return retval;</span>
	}
	// $ANTLR end &quot;shiftExpression&quot;


<span class="nc" id="L9176">	public static class relationalExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9179">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;relationalExpression&quot;
	// AcslParser.g:477:1: relationalExpression : ( shiftExpression -&gt; shiftExpression ) ( relationalOperator y= shiftExpression -&gt; ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) ) )* ;
	public final AcslParser.relationalExpression_return relationalExpression() throws RecognitionException {
<span class="nc" id="L9186">		AcslParser.relationalExpression_return retval = new AcslParser.relationalExpression_return();</span>
<span class="nc" id="L9187">		retval.start = input.LT(1);</span>

<span class="nc" id="L9189">		Object root_0 = null;</span>

<span class="nc" id="L9191">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L9192">		ParserRuleReturnScope shiftExpression239 =null;</span>
<span class="nc" id="L9193">		ParserRuleReturnScope relationalOperator240 =null;</span>

<span class="nc" id="L9195">		RewriteRuleSubtreeStream stream_relationalOperator=new RewriteRuleSubtreeStream(adaptor,&quot;rule relationalOperator&quot;);</span>
<span class="nc" id="L9196">		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule shiftExpression&quot;);</span>

		try {
			// AcslParser.g:478:2: ( ( shiftExpression -&gt; shiftExpression ) ( relationalOperator y= shiftExpression -&gt; ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) ) )* )
			// AcslParser.g:478:4: ( shiftExpression -&gt; shiftExpression ) ( relationalOperator y= shiftExpression -&gt; ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) ) )*
			{
			// AcslParser.g:478:4: ( shiftExpression -&gt; shiftExpression )
			// AcslParser.g:478:6: shiftExpression
			{
<span class="nc" id="L9205">			pushFollow(FOLLOW_shiftExpression_in_relationalExpression3779);</span>
<span class="nc" id="L9206">			shiftExpression239=shiftExpression();</span>
<span class="nc" id="L9207">			state._fsp--;</span>
<span class="nc bnc" id="L9208" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9209" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_shiftExpression.add(shiftExpression239.getTree());</span>
			// AST REWRITE
			// elements: shiftExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9217" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9218">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9219" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9221">			root_0 = (Object)adaptor.nil();</span>
			// 478:22: -&gt; shiftExpression
			{
<span class="nc" id="L9224">				adaptor.addChild(root_0, stream_shiftExpression.nextTree());</span>
			}


<span class="nc" id="L9228">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:479:4: ( relationalOperator y= shiftExpression -&gt; ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) ) )*
			loop51:
			while (true) {
<span class="nc" id="L9236">				int alt51=2;</span>
<span class="nc" id="L9237">				int LA51_0 = input.LA(1);</span>
<span class="nc bnc" id="L9238" title="All 8 branches missed.">				if ( ((LA51_0 &gt;= GT &amp;&amp; LA51_0 &lt;= GTE)||(LA51_0 &gt;= LT &amp;&amp; LA51_0 &lt;= LTE)) ) {</span>
<span class="nc" id="L9239">					alt51=1;</span>
				}

<span class="nc bnc" id="L9242" title="All 2 branches missed.">				switch (alt51) {</span>
				case 1 :
					// AcslParser.g:479:6: relationalOperator y= shiftExpression
					{
<span class="nc" id="L9246">					pushFollow(FOLLOW_relationalOperator_in_relationalExpression3792);</span>
<span class="nc" id="L9247">					relationalOperator240=relationalOperator();</span>
<span class="nc" id="L9248">					state._fsp--;</span>
<span class="nc bnc" id="L9249" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9250" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_relationalOperator.add(relationalOperator240.getTree());</span>
<span class="nc" id="L9251">					pushFollow(FOLLOW_shiftExpression_in_relationalExpression3796);</span>
<span class="nc" id="L9252">					y=shiftExpression();</span>
<span class="nc" id="L9253">					state._fsp--;</span>
<span class="nc bnc" id="L9254" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9255" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_shiftExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, relationalExpression, relationalOperator
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9263" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9264">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9265" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9266" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9268">					root_0 = (Object)adaptor.nil();</span>
					// 480:6: -&gt; ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) )
					{
						// AcslParser.g:480:9: ^( OPERATOR relationalOperator ^( ARGUMENT_LIST $relationalExpression $y) )
						{
<span class="nc" id="L9273">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9274">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9275">						adaptor.addChild(root_1, stream_relationalOperator.nextTree());</span>
						// AcslParser.g:480:39: ^( ARGUMENT_LIST $relationalExpression $y)
						{
<span class="nc" id="L9278">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9279">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9280">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9281">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9282">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9285">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9291">					retval.tree = root_0;</span>
<span class="nc" id="L9292">					}</span>

					}
					break;

				default :
<span class="nc" id="L9298">					break loop51;</span>
				}
<span class="nc" id="L9300">			}</span>

			}

<span class="nc" id="L9304">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9306" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9307">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9308">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9311">		catch (RecognitionException re) {</span>
<span class="nc" id="L9312">			reportError(re);</span>
<span class="nc" id="L9313">			recover(input,re);</span>
<span class="nc" id="L9314">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9316">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9318">		}</span>
<span class="nc" id="L9319">		return retval;</span>
	}
	// $ANTLR end &quot;relationalExpression&quot;


<span class="nc" id="L9324">	public static class relationalOperator_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9327">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;relationalOperator&quot;
	// AcslParser.g:484:1: relationalOperator : ( LT | GT | LTE | GTE );
	public final AcslParser.relationalOperator_return relationalOperator() throws RecognitionException {
<span class="nc" id="L9334">		AcslParser.relationalOperator_return retval = new AcslParser.relationalOperator_return();</span>
<span class="nc" id="L9335">		retval.start = input.LT(1);</span>

<span class="nc" id="L9337">		Object root_0 = null;</span>

<span class="nc" id="L9339">		Token set241=null;</span>

<span class="nc" id="L9341">		Object set241_tree=null;</span>

		try {
			// AcslParser.g:485:2: ( LT | GT | LTE | GTE )
			// AcslParser.g:
			{
<span class="nc" id="L9347">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L9350">			set241=input.LT(1);</span>
<span class="nc bnc" id="L9351" title="All 8 branches missed.">			if ( (input.LA(1) &gt;= GT &amp;&amp; input.LA(1) &lt;= GTE)||(input.LA(1) &gt;= LT &amp;&amp; input.LA(1) &lt;= LTE) ) {</span>
<span class="nc" id="L9352">				input.consume();</span>
<span class="nc bnc" id="L9353" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set241));</span>
<span class="nc" id="L9354">				state.errorRecovery=false;</span>
<span class="nc" id="L9355">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L9358" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L9359">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L9360">				throw mse;</span>
			}
			}

<span class="nc" id="L9364">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9366" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9367">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9368">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9371">		catch (RecognitionException re) {</span>
<span class="nc" id="L9372">			reportError(re);</span>
<span class="nc" id="L9373">			recover(input,re);</span>
<span class="nc" id="L9374">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9376">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9378">		}</span>
<span class="nc" id="L9379">		return retval;</span>
	}
	// $ANTLR end &quot;relationalOperator&quot;


<span class="nc" id="L9384">	public static class equalityExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9387">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;equalityExpression&quot;
	// AcslParser.g:489:1: equalityExpression : ( relationalExpression -&gt; relationalExpression ) ( equalityOperator y= relationalExpression -&gt; ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) ) )* ;
	public final AcslParser.equalityExpression_return equalityExpression() throws RecognitionException {
<span class="nc" id="L9394">		AcslParser.equalityExpression_return retval = new AcslParser.equalityExpression_return();</span>
<span class="nc" id="L9395">		retval.start = input.LT(1);</span>

<span class="nc" id="L9397">		Object root_0 = null;</span>

<span class="nc" id="L9399">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L9400">		ParserRuleReturnScope relationalExpression242 =null;</span>
<span class="nc" id="L9401">		ParserRuleReturnScope equalityOperator243 =null;</span>

<span class="nc" id="L9403">		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule relationalExpression&quot;);</span>
<span class="nc" id="L9404">		RewriteRuleSubtreeStream stream_equalityOperator=new RewriteRuleSubtreeStream(adaptor,&quot;rule equalityOperator&quot;);</span>

		try {
			// AcslParser.g:490:2: ( ( relationalExpression -&gt; relationalExpression ) ( equalityOperator y= relationalExpression -&gt; ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) ) )* )
			// AcslParser.g:490:4: ( relationalExpression -&gt; relationalExpression ) ( equalityOperator y= relationalExpression -&gt; ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) ) )*
			{
			// AcslParser.g:490:4: ( relationalExpression -&gt; relationalExpression )
			// AcslParser.g:490:6: relationalExpression
			{
<span class="nc" id="L9413">			pushFollow(FOLLOW_relationalExpression_in_equalityExpression3864);</span>
<span class="nc" id="L9414">			relationalExpression242=relationalExpression();</span>
<span class="nc" id="L9415">			state._fsp--;</span>
<span class="nc bnc" id="L9416" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9417" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_relationalExpression.add(relationalExpression242.getTree());</span>
			// AST REWRITE
			// elements: relationalExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9425" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9426">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9427" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9429">			root_0 = (Object)adaptor.nil();</span>
			// 490:27: -&gt; relationalExpression
			{
<span class="nc" id="L9432">				adaptor.addChild(root_0, stream_relationalExpression.nextTree());</span>
			}


<span class="nc" id="L9436">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:491:4: ( equalityOperator y= relationalExpression -&gt; ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) ) )*
			loop52:
			while (true) {
<span class="nc" id="L9444">				int alt52=2;</span>
<span class="nc" id="L9445">				int LA52_0 = input.LA(1);</span>
<span class="nc bnc" id="L9446" title="All 4 branches missed.">				if ( (LA52_0==EQ||LA52_0==NEQ) ) {</span>
<span class="nc" id="L9447">					alt52=1;</span>
				}

<span class="nc bnc" id="L9450" title="All 2 branches missed.">				switch (alt52) {</span>
				case 1 :
					// AcslParser.g:491:6: equalityOperator y= relationalExpression
					{
<span class="nc" id="L9454">					pushFollow(FOLLOW_equalityOperator_in_equalityExpression3877);</span>
<span class="nc" id="L9455">					equalityOperator243=equalityOperator();</span>
<span class="nc" id="L9456">					state._fsp--;</span>
<span class="nc bnc" id="L9457" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9458" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_equalityOperator.add(equalityOperator243.getTree());</span>
<span class="nc" id="L9459">					pushFollow(FOLLOW_relationalExpression_in_equalityExpression3881);</span>
<span class="nc" id="L9460">					y=relationalExpression();</span>
<span class="nc" id="L9461">					state._fsp--;</span>
<span class="nc bnc" id="L9462" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9463" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_relationalExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: equalityExpression, y, equalityOperator
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9471" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9472">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9473" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9474" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9476">					root_0 = (Object)adaptor.nil();</span>
					// 492:6: -&gt; ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) )
					{
						// AcslParser.g:492:9: ^( OPERATOR equalityOperator ^( ARGUMENT_LIST $equalityExpression $y) )
						{
<span class="nc" id="L9481">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9482">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9483">						adaptor.addChild(root_1, stream_equalityOperator.nextTree());</span>
						// AcslParser.g:492:37: ^( ARGUMENT_LIST $equalityExpression $y)
						{
<span class="nc" id="L9486">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9487">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9488">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9489">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9490">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9493">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9499">					retval.tree = root_0;</span>
<span class="nc" id="L9500">					}</span>

					}
					break;

				default :
<span class="nc" id="L9506">					break loop52;</span>
				}
<span class="nc" id="L9508">			}</span>

			}

<span class="nc" id="L9512">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9514" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9515">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9516">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9519">		catch (RecognitionException re) {</span>
<span class="nc" id="L9520">			reportError(re);</span>
<span class="nc" id="L9521">			recover(input,re);</span>
<span class="nc" id="L9522">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9524">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9526">		}</span>
<span class="nc" id="L9527">		return retval;</span>
	}
	// $ANTLR end &quot;equalityExpression&quot;


<span class="nc" id="L9532">	public static class equalityOperator_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9535">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;equalityOperator&quot;
	// AcslParser.g:496:1: equalityOperator : ( EQ | NEQ );
	public final AcslParser.equalityOperator_return equalityOperator() throws RecognitionException {
<span class="nc" id="L9542">		AcslParser.equalityOperator_return retval = new AcslParser.equalityOperator_return();</span>
<span class="nc" id="L9543">		retval.start = input.LT(1);</span>

<span class="nc" id="L9545">		Object root_0 = null;</span>

<span class="nc" id="L9547">		Token set244=null;</span>

<span class="nc" id="L9549">		Object set244_tree=null;</span>

		try {
			// AcslParser.g:497:2: ( EQ | NEQ )
			// AcslParser.g:
			{
<span class="nc" id="L9555">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L9558">			set244=input.LT(1);</span>
<span class="nc bnc" id="L9559" title="All 4 branches missed.">			if ( input.LA(1)==EQ||input.LA(1)==NEQ ) {</span>
<span class="nc" id="L9560">				input.consume();</span>
<span class="nc bnc" id="L9561" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set244));</span>
<span class="nc" id="L9562">				state.errorRecovery=false;</span>
<span class="nc" id="L9563">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L9566" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L9567">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L9568">				throw mse;</span>
			}
			}

<span class="nc" id="L9572">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9574" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9575">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9576">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9579">		catch (RecognitionException re) {</span>
<span class="nc" id="L9580">			reportError(re);</span>
<span class="nc" id="L9581">			recover(input,re);</span>
<span class="nc" id="L9582">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9584">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9586">		}</span>
<span class="nc" id="L9587">		return retval;</span>
	}
	// $ANTLR end &quot;equalityOperator&quot;


<span class="nc" id="L9592">	public static class andExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9595">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;andExpression&quot;
	// AcslParser.g:501:1: andExpression : ( equalityExpression -&gt; equalityExpression ) ( AMPERSAND y= equalityExpression -&gt; ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) ) )* ;
	public final AcslParser.andExpression_return andExpression() throws RecognitionException {
<span class="nc" id="L9602">		AcslParser.andExpression_return retval = new AcslParser.andExpression_return();</span>
<span class="nc" id="L9603">		retval.start = input.LT(1);</span>

<span class="nc" id="L9605">		Object root_0 = null;</span>

<span class="nc" id="L9607">		Token AMPERSAND246=null;</span>
<span class="nc" id="L9608">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L9609">		ParserRuleReturnScope equalityExpression245 =null;</span>

<span class="nc" id="L9611">		Object AMPERSAND246_tree=null;</span>
<span class="nc" id="L9612">		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,&quot;token AMPERSAND&quot;);</span>
<span class="nc" id="L9613">		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule equalityExpression&quot;);</span>

		try {
			// AcslParser.g:502:2: ( ( equalityExpression -&gt; equalityExpression ) ( AMPERSAND y= equalityExpression -&gt; ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) ) )* )
			// AcslParser.g:502:4: ( equalityExpression -&gt; equalityExpression ) ( AMPERSAND y= equalityExpression -&gt; ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) ) )*
			{
			// AcslParser.g:502:4: ( equalityExpression -&gt; equalityExpression )
			// AcslParser.g:502:6: equalityExpression
			{
<span class="nc" id="L9622">			pushFollow(FOLLOW_equalityExpression_in_andExpression3940);</span>
<span class="nc" id="L9623">			equalityExpression245=equalityExpression();</span>
<span class="nc" id="L9624">			state._fsp--;</span>
<span class="nc bnc" id="L9625" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9626" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_equalityExpression.add(equalityExpression245.getTree());</span>
			// AST REWRITE
			// elements: equalityExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9634" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9635">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9636" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9638">			root_0 = (Object)adaptor.nil();</span>
			// 502:25: -&gt; equalityExpression
			{
<span class="nc" id="L9641">				adaptor.addChild(root_0, stream_equalityExpression.nextTree());</span>
			}


<span class="nc" id="L9645">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:503:4: ( AMPERSAND y= equalityExpression -&gt; ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) ) )*
			loop53:
			while (true) {
<span class="nc" id="L9653">				int alt53=2;</span>
<span class="nc" id="L9654">				int LA53_0 = input.LA(1);</span>
<span class="nc bnc" id="L9655" title="All 2 branches missed.">				if ( (LA53_0==AMPERSAND) ) {</span>
<span class="nc" id="L9656">					alt53=1;</span>
				}

<span class="nc bnc" id="L9659" title="All 2 branches missed.">				switch (alt53) {</span>
				case 1 :
					// AcslParser.g:503:6: AMPERSAND y= equalityExpression
					{
<span class="nc bnc" id="L9663" title="All 2 branches missed.">					AMPERSAND246=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_andExpression3953); if (state.failed) return retval; </span>
<span class="nc bnc" id="L9664" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_AMPERSAND.add(AMPERSAND246);</span>

<span class="nc" id="L9666">					pushFollow(FOLLOW_equalityExpression_in_andExpression3957);</span>
<span class="nc" id="L9667">					y=equalityExpression();</span>
<span class="nc" id="L9668">					state._fsp--;</span>
<span class="nc bnc" id="L9669" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9670" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_equalityExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: AMPERSAND, y, andExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9678" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9679">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9680" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9681" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9683">					root_0 = (Object)adaptor.nil();</span>
					// 504:6: -&gt; ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) )
					{
						// AcslParser.g:504:9: ^( OPERATOR AMPERSAND ^( ARGUMENT_LIST $andExpression $y) )
						{
<span class="nc" id="L9688">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9689">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9690">						adaptor.addChild(root_1, stream_AMPERSAND.nextNode());</span>
						// AcslParser.g:504:30: ^( ARGUMENT_LIST $andExpression $y)
						{
<span class="nc" id="L9693">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9694">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9695">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9696">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9697">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9700">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9706">					retval.tree = root_0;</span>
<span class="nc" id="L9707">					}</span>

					}
					break;

				default :
<span class="nc" id="L9713">					break loop53;</span>
				}
<span class="nc" id="L9715">			}</span>

			}

<span class="nc" id="L9719">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9721" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9722">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9723">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9726">		catch (RecognitionException re) {</span>
<span class="nc" id="L9727">			reportError(re);</span>
<span class="nc" id="L9728">			recover(input,re);</span>
<span class="nc" id="L9729">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9731">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9733">		}</span>
<span class="nc" id="L9734">		return retval;</span>
	}
	// $ANTLR end &quot;andExpression&quot;


<span class="nc" id="L9739">	public static class exclusiveOrExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9742">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;exclusiveOrExpression&quot;
	// AcslParser.g:509:1: exclusiveOrExpression : ( andExpression -&gt; andExpression ) ( BITXOR y= andExpression -&gt; ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) ) )* ;
	public final AcslParser.exclusiveOrExpression_return exclusiveOrExpression() throws RecognitionException {
<span class="nc" id="L9749">		AcslParser.exclusiveOrExpression_return retval = new AcslParser.exclusiveOrExpression_return();</span>
<span class="nc" id="L9750">		retval.start = input.LT(1);</span>

<span class="nc" id="L9752">		Object root_0 = null;</span>

<span class="nc" id="L9754">		Token BITXOR248=null;</span>
<span class="nc" id="L9755">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L9756">		ParserRuleReturnScope andExpression247 =null;</span>

<span class="nc" id="L9758">		Object BITXOR248_tree=null;</span>
<span class="nc" id="L9759">		RewriteRuleTokenStream stream_BITXOR=new RewriteRuleTokenStream(adaptor,&quot;token BITXOR&quot;);</span>
<span class="nc" id="L9760">		RewriteRuleSubtreeStream stream_andExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule andExpression&quot;);</span>

		try {
			// AcslParser.g:510:3: ( ( andExpression -&gt; andExpression ) ( BITXOR y= andExpression -&gt; ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) ) )* )
			// AcslParser.g:510:3: ( andExpression -&gt; andExpression ) ( BITXOR y= andExpression -&gt; ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) ) )*
			{
			// AcslParser.g:510:3: ( andExpression -&gt; andExpression )
			// AcslParser.g:510:5: andExpression
			{
<span class="nc" id="L9769">			pushFollow(FOLLOW_andExpression_in_exclusiveOrExpression4000);</span>
<span class="nc" id="L9770">			andExpression247=andExpression();</span>
<span class="nc" id="L9771">			state._fsp--;</span>
<span class="nc bnc" id="L9772" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9773" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_andExpression.add(andExpression247.getTree());</span>
			// AST REWRITE
			// elements: andExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9781" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9782">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9783" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9785">			root_0 = (Object)adaptor.nil();</span>
			// 510:19: -&gt; andExpression
			{
<span class="nc" id="L9788">				adaptor.addChild(root_0, stream_andExpression.nextTree());</span>
			}


<span class="nc" id="L9792">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:511:4: ( BITXOR y= andExpression -&gt; ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) ) )*
			loop54:
			while (true) {
<span class="nc" id="L9800">				int alt54=2;</span>
<span class="nc" id="L9801">				int LA54_0 = input.LA(1);</span>
<span class="nc bnc" id="L9802" title="All 2 branches missed.">				if ( (LA54_0==BITXOR) ) {</span>
<span class="nc" id="L9803">					alt54=1;</span>
				}

<span class="nc bnc" id="L9806" title="All 2 branches missed.">				switch (alt54) {</span>
				case 1 :
					// AcslParser.g:511:6: BITXOR y= andExpression
					{
<span class="nc bnc" id="L9810" title="All 2 branches missed.">					BITXOR248=(Token)match(input,BITXOR,FOLLOW_BITXOR_in_exclusiveOrExpression4013); if (state.failed) return retval; </span>
<span class="nc bnc" id="L9811" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_BITXOR.add(BITXOR248);</span>

<span class="nc" id="L9813">					pushFollow(FOLLOW_andExpression_in_exclusiveOrExpression4017);</span>
<span class="nc" id="L9814">					y=andExpression();</span>
<span class="nc" id="L9815">					state._fsp--;</span>
<span class="nc bnc" id="L9816" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9817" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_andExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, exclusiveOrExpression, BITXOR
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9825" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9826">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9827" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9828" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9830">					root_0 = (Object)adaptor.nil();</span>
					// 512:6: -&gt; ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) )
					{
						// AcslParser.g:512:9: ^( OPERATOR BITXOR ^( ARGUMENT_LIST $exclusiveOrExpression $y) )
						{
<span class="nc" id="L9835">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9836">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9837">						adaptor.addChild(root_1, stream_BITXOR.nextNode());</span>
						// AcslParser.g:512:27: ^( ARGUMENT_LIST $exclusiveOrExpression $y)
						{
<span class="nc" id="L9840">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9841">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9842">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9843">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9844">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9847">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L9853">					retval.tree = root_0;</span>
<span class="nc" id="L9854">					}</span>

					}
					break;

				default :
<span class="nc" id="L9860">					break loop54;</span>
				}
<span class="nc" id="L9862">			}</span>

			}

<span class="nc" id="L9866">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L9868" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9869">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L9870">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L9873">		catch (RecognitionException re) {</span>
<span class="nc" id="L9874">			reportError(re);</span>
<span class="nc" id="L9875">			recover(input,re);</span>
<span class="nc" id="L9876">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L9878">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L9880">		}</span>
<span class="nc" id="L9881">		return retval;</span>
	}
	// $ANTLR end &quot;exclusiveOrExpression&quot;


<span class="nc" id="L9886">	public static class inclusiveOrExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L9889">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;inclusiveOrExpression&quot;
	// AcslParser.g:517:1: inclusiveOrExpression : ( exclusiveOrExpression -&gt; exclusiveOrExpression ) ( BAR y= exclusiveOrExpression -&gt; ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) ) )* ;
	public final AcslParser.inclusiveOrExpression_return inclusiveOrExpression() throws RecognitionException {
<span class="nc" id="L9896">		AcslParser.inclusiveOrExpression_return retval = new AcslParser.inclusiveOrExpression_return();</span>
<span class="nc" id="L9897">		retval.start = input.LT(1);</span>

<span class="nc" id="L9899">		Object root_0 = null;</span>

<span class="nc" id="L9901">		Token BAR250=null;</span>
<span class="nc" id="L9902">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L9903">		ParserRuleReturnScope exclusiveOrExpression249 =null;</span>

<span class="nc" id="L9905">		Object BAR250_tree=null;</span>
<span class="nc" id="L9906">		RewriteRuleTokenStream stream_BAR=new RewriteRuleTokenStream(adaptor,&quot;token BAR&quot;);</span>
<span class="nc" id="L9907">		RewriteRuleSubtreeStream stream_exclusiveOrExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule exclusiveOrExpression&quot;);</span>

		try {
			// AcslParser.g:518:2: ( ( exclusiveOrExpression -&gt; exclusiveOrExpression ) ( BAR y= exclusiveOrExpression -&gt; ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) ) )* )
			// AcslParser.g:518:4: ( exclusiveOrExpression -&gt; exclusiveOrExpression ) ( BAR y= exclusiveOrExpression -&gt; ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) ) )*
			{
			// AcslParser.g:518:4: ( exclusiveOrExpression -&gt; exclusiveOrExpression )
			// AcslParser.g:518:6: exclusiveOrExpression
			{
<span class="nc" id="L9916">			pushFollow(FOLLOW_exclusiveOrExpression_in_inclusiveOrExpression4061);</span>
<span class="nc" id="L9917">			exclusiveOrExpression249=exclusiveOrExpression();</span>
<span class="nc" id="L9918">			state._fsp--;</span>
<span class="nc bnc" id="L9919" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L9920" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_exclusiveOrExpression.add(exclusiveOrExpression249.getTree());</span>
			// AST REWRITE
			// elements: exclusiveOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L9928" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9929">			retval.tree = root_0;</span>
<span class="nc bnc" id="L9930" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L9932">			root_0 = (Object)adaptor.nil();</span>
			// 518:28: -&gt; exclusiveOrExpression
			{
<span class="nc" id="L9935">				adaptor.addChild(root_0, stream_exclusiveOrExpression.nextTree());</span>
			}


<span class="nc" id="L9939">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:519:4: ( BAR y= exclusiveOrExpression -&gt; ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) ) )*
			loop55:
			while (true) {
<span class="nc" id="L9947">				int alt55=2;</span>
<span class="nc" id="L9948">				int LA55_0 = input.LA(1);</span>
<span class="nc bnc" id="L9949" title="All 2 branches missed.">				if ( (LA55_0==BAR) ) {</span>
<span class="nc" id="L9950">					int LA55_10 = input.LA(2);</span>
<span class="nc bnc" id="L9951" title="All 2 branches missed.">					if ( (synpred105_AcslParser()) ) {</span>
<span class="nc" id="L9952">						alt55=1;</span>
					}

				}

<span class="nc bnc" id="L9957" title="All 2 branches missed.">				switch (alt55) {</span>
				case 1 :
					// AcslParser.g:519:6: BAR y= exclusiveOrExpression
					{
<span class="nc bnc" id="L9961" title="All 2 branches missed.">					BAR250=(Token)match(input,BAR,FOLLOW_BAR_in_inclusiveOrExpression4074); if (state.failed) return retval; </span>
<span class="nc bnc" id="L9962" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_BAR.add(BAR250);</span>

<span class="nc" id="L9964">					pushFollow(FOLLOW_exclusiveOrExpression_in_inclusiveOrExpression4078);</span>
<span class="nc" id="L9965">					y=exclusiveOrExpression();</span>
<span class="nc" id="L9966">					state._fsp--;</span>
<span class="nc bnc" id="L9967" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L9968" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_exclusiveOrExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: BAR, y, inclusiveOrExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L9976" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L9977">					retval.tree = root_0;</span>
<span class="nc bnc" id="L9978" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L9979" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L9981">					root_0 = (Object)adaptor.nil();</span>
					// 520:6: -&gt; ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) )
					{
						// AcslParser.g:520:9: ^( OPERATOR BAR ^( ARGUMENT_LIST $inclusiveOrExpression $y) )
						{
<span class="nc" id="L9986">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L9987">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L9988">						adaptor.addChild(root_1, stream_BAR.nextNode());</span>
						// AcslParser.g:520:24: ^( ARGUMENT_LIST $inclusiveOrExpression $y)
						{
<span class="nc" id="L9991">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L9992">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L9993">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L9994">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L9995">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L9998">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L10004">					retval.tree = root_0;</span>
<span class="nc" id="L10005">					}</span>

					}
					break;

				default :
<span class="nc" id="L10011">					break loop55;</span>
				}
<span class="nc" id="L10013">			}</span>

			}

<span class="nc" id="L10017">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10019" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10020">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10021">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10024">		catch (RecognitionException re) {</span>
<span class="nc" id="L10025">			reportError(re);</span>
<span class="nc" id="L10026">			recover(input,re);</span>
<span class="nc" id="L10027">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10029">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10031">		}</span>
<span class="nc" id="L10032">		return retval;</span>
	}
	// $ANTLR end &quot;inclusiveOrExpression&quot;


<span class="nc" id="L10037">	public static class logicalAndExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10040">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;logicalAndExpression&quot;
	// AcslParser.g:525:1: logicalAndExpression : ( inclusiveOrExpression -&gt; inclusiveOrExpression ) ( LAND y= inclusiveOrExpression -&gt; ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) ) )* ;
	public final AcslParser.logicalAndExpression_return logicalAndExpression() throws RecognitionException {
<span class="nc" id="L10047">		AcslParser.logicalAndExpression_return retval = new AcslParser.logicalAndExpression_return();</span>
<span class="nc" id="L10048">		retval.start = input.LT(1);</span>

<span class="nc" id="L10050">		Object root_0 = null;</span>

<span class="nc" id="L10052">		Token LAND252=null;</span>
<span class="nc" id="L10053">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L10054">		ParserRuleReturnScope inclusiveOrExpression251 =null;</span>

<span class="nc" id="L10056">		Object LAND252_tree=null;</span>
<span class="nc" id="L10057">		RewriteRuleTokenStream stream_LAND=new RewriteRuleTokenStream(adaptor,&quot;token LAND&quot;);</span>
<span class="nc" id="L10058">		RewriteRuleSubtreeStream stream_inclusiveOrExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule inclusiveOrExpression&quot;);</span>

		try {
			// AcslParser.g:526:2: ( ( inclusiveOrExpression -&gt; inclusiveOrExpression ) ( LAND y= inclusiveOrExpression -&gt; ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) ) )* )
			// AcslParser.g:526:4: ( inclusiveOrExpression -&gt; inclusiveOrExpression ) ( LAND y= inclusiveOrExpression -&gt; ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) ) )*
			{
			// AcslParser.g:526:4: ( inclusiveOrExpression -&gt; inclusiveOrExpression )
			// AcslParser.g:526:6: inclusiveOrExpression
			{
<span class="nc" id="L10067">			pushFollow(FOLLOW_inclusiveOrExpression_in_logicalAndExpression4122);</span>
<span class="nc" id="L10068">			inclusiveOrExpression251=inclusiveOrExpression();</span>
<span class="nc" id="L10069">			state._fsp--;</span>
<span class="nc bnc" id="L10070" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10071" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_inclusiveOrExpression.add(inclusiveOrExpression251.getTree());</span>
			// AST REWRITE
			// elements: inclusiveOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L10079" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10080">			retval.tree = root_0;</span>
<span class="nc bnc" id="L10081" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10083">			root_0 = (Object)adaptor.nil();</span>
			// 526:28: -&gt; inclusiveOrExpression
			{
<span class="nc" id="L10086">				adaptor.addChild(root_0, stream_inclusiveOrExpression.nextTree());</span>
			}


<span class="nc" id="L10090">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:527:4: ( LAND y= inclusiveOrExpression -&gt; ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) ) )*
			loop56:
			while (true) {
<span class="nc" id="L10098">				int alt56=2;</span>
<span class="nc" id="L10099">				int LA56_0 = input.LA(1);</span>
<span class="nc bnc" id="L10100" title="All 2 branches missed.">				if ( (LA56_0==LAND) ) {</span>
<span class="nc" id="L10101">					alt56=1;</span>
				}

<span class="nc bnc" id="L10104" title="All 2 branches missed.">				switch (alt56) {</span>
				case 1 :
					// AcslParser.g:527:6: LAND y= inclusiveOrExpression
					{
<span class="nc bnc" id="L10108" title="All 2 branches missed.">					LAND252=(Token)match(input,LAND,FOLLOW_LAND_in_logicalAndExpression4135); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10109" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LAND.add(LAND252);</span>

<span class="nc" id="L10111">					pushFollow(FOLLOW_inclusiveOrExpression_in_logicalAndExpression4139);</span>
<span class="nc" id="L10112">					y=inclusiveOrExpression();</span>
<span class="nc" id="L10113">					state._fsp--;</span>
<span class="nc bnc" id="L10114" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L10115" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_inclusiveOrExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: LAND, y, logicalAndExpression
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L10123" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10124">					retval.tree = root_0;</span>
<span class="nc bnc" id="L10125" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L10126" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L10128">					root_0 = (Object)adaptor.nil();</span>
					// 528:6: -&gt; ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) )
					{
						// AcslParser.g:528:9: ^( OPERATOR LAND ^( ARGUMENT_LIST $logicalAndExpression $y) )
						{
<span class="nc" id="L10133">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L10134">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L10135">						adaptor.addChild(root_1, stream_LAND.nextNode());</span>
						// AcslParser.g:528:25: ^( ARGUMENT_LIST $logicalAndExpression $y)
						{
<span class="nc" id="L10138">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L10139">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L10140">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L10141">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L10142">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L10145">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L10151">					retval.tree = root_0;</span>
<span class="nc" id="L10152">					}</span>

					}
					break;

				default :
<span class="nc" id="L10158">					break loop56;</span>
				}
<span class="nc" id="L10160">			}</span>

			}

<span class="nc" id="L10164">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10166" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10167">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10168">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10171">		catch (RecognitionException re) {</span>
<span class="nc" id="L10172">			reportError(re);</span>
<span class="nc" id="L10173">			recover(input,re);</span>
<span class="nc" id="L10174">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10176">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10178">		}</span>
<span class="nc" id="L10179">		return retval;</span>
	}
	// $ANTLR end &quot;logicalAndExpression&quot;


<span class="nc" id="L10184">	public static class logicalOrExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10187">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;logicalOrExpression&quot;
	// AcslParser.g:533:1: logicalOrExpression : ( logicalAndExpression -&gt; logicalAndExpression ) ( LOR y= logicalAndExpression -&gt; ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) ) )* ;
	public final AcslParser.logicalOrExpression_return logicalOrExpression() throws RecognitionException {
<span class="nc" id="L10194">		AcslParser.logicalOrExpression_return retval = new AcslParser.logicalOrExpression_return();</span>
<span class="nc" id="L10195">		retval.start = input.LT(1);</span>

<span class="nc" id="L10197">		Object root_0 = null;</span>

<span class="nc" id="L10199">		Token LOR254=null;</span>
<span class="nc" id="L10200">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L10201">		ParserRuleReturnScope logicalAndExpression253 =null;</span>

<span class="nc" id="L10203">		Object LOR254_tree=null;</span>
<span class="nc" id="L10204">		RewriteRuleTokenStream stream_LOR=new RewriteRuleTokenStream(adaptor,&quot;token LOR&quot;);</span>
<span class="nc" id="L10205">		RewriteRuleSubtreeStream stream_logicalAndExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule logicalAndExpression&quot;);</span>

		try {
			// AcslParser.g:534:2: ( ( logicalAndExpression -&gt; logicalAndExpression ) ( LOR y= logicalAndExpression -&gt; ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) ) )* )
			// AcslParser.g:534:4: ( logicalAndExpression -&gt; logicalAndExpression ) ( LOR y= logicalAndExpression -&gt; ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) ) )*
			{
			// AcslParser.g:534:4: ( logicalAndExpression -&gt; logicalAndExpression )
			// AcslParser.g:534:6: logicalAndExpression
			{
<span class="nc" id="L10214">			pushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression4183);</span>
<span class="nc" id="L10215">			logicalAndExpression253=logicalAndExpression();</span>
<span class="nc" id="L10216">			state._fsp--;</span>
<span class="nc bnc" id="L10217" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10218" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_logicalAndExpression.add(logicalAndExpression253.getTree());</span>
			// AST REWRITE
			// elements: logicalAndExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L10226" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10227">			retval.tree = root_0;</span>
<span class="nc bnc" id="L10228" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10230">			root_0 = (Object)adaptor.nil();</span>
			// 534:27: -&gt; logicalAndExpression
			{
<span class="nc" id="L10233">				adaptor.addChild(root_0, stream_logicalAndExpression.nextTree());</span>
			}


<span class="nc" id="L10237">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:535:4: ( LOR y= logicalAndExpression -&gt; ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) ) )*
			loop57:
			while (true) {
<span class="nc" id="L10245">				int alt57=2;</span>
<span class="nc" id="L10246">				int LA57_0 = input.LA(1);</span>
<span class="nc bnc" id="L10247" title="All 2 branches missed.">				if ( (LA57_0==LOR) ) {</span>
<span class="nc" id="L10248">					alt57=1;</span>
				}

<span class="nc bnc" id="L10251" title="All 2 branches missed.">				switch (alt57) {</span>
				case 1 :
					// AcslParser.g:535:6: LOR y= logicalAndExpression
					{
<span class="nc bnc" id="L10255" title="All 2 branches missed.">					LOR254=(Token)match(input,LOR,FOLLOW_LOR_in_logicalOrExpression4196); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10256" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LOR.add(LOR254);</span>

<span class="nc" id="L10258">					pushFollow(FOLLOW_logicalAndExpression_in_logicalOrExpression4200);</span>
<span class="nc" id="L10259">					y=logicalAndExpression();</span>
<span class="nc" id="L10260">					state._fsp--;</span>
<span class="nc bnc" id="L10261" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L10262" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_logicalAndExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: logicalOrExpression, y, LOR
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L10270" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10271">					retval.tree = root_0;</span>
<span class="nc bnc" id="L10272" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L10273" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L10275">					root_0 = (Object)adaptor.nil();</span>
					// 536:6: -&gt; ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) )
					{
						// AcslParser.g:536:9: ^( OPERATOR LOR ^( ARGUMENT_LIST $logicalOrExpression $y) )
						{
<span class="nc" id="L10280">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L10281">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L10282">						adaptor.addChild(root_1, stream_LOR.nextNode());</span>
						// AcslParser.g:536:24: ^( ARGUMENT_LIST $logicalOrExpression $y)
						{
<span class="nc" id="L10285">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L10286">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L10287">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L10288">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L10289">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L10292">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L10298">					retval.tree = root_0;</span>
<span class="nc" id="L10299">					}</span>

					}
					break;

				default :
<span class="nc" id="L10305">					break loop57;</span>
				}
<span class="nc" id="L10307">			}</span>

			}

<span class="nc" id="L10311">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10313" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10314">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10315">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10318">		catch (RecognitionException re) {</span>
<span class="nc" id="L10319">			reportError(re);</span>
<span class="nc" id="L10320">			recover(input,re);</span>
<span class="nc" id="L10321">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10323">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10325">		}</span>
<span class="nc" id="L10326">		return retval;</span>
	}
	// $ANTLR end &quot;logicalOrExpression&quot;


<span class="nc" id="L10331">	public static class logicalImpliesExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10334">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;logicalImpliesExpression&quot;
	// AcslParser.g:541:1: logicalImpliesExpression : ( logicalOrExpression -&gt; logicalOrExpression ) ( IMPLY y= logicalOrExpression -&gt; ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) ) )* ;
	public final AcslParser.logicalImpliesExpression_return logicalImpliesExpression() throws RecognitionException {
<span class="nc" id="L10341">		AcslParser.logicalImpliesExpression_return retval = new AcslParser.logicalImpliesExpression_return();</span>
<span class="nc" id="L10342">		retval.start = input.LT(1);</span>

<span class="nc" id="L10344">		Object root_0 = null;</span>

<span class="nc" id="L10346">		Token IMPLY256=null;</span>
<span class="nc" id="L10347">		ParserRuleReturnScope y =null;</span>
<span class="nc" id="L10348">		ParserRuleReturnScope logicalOrExpression255 =null;</span>

<span class="nc" id="L10350">		Object IMPLY256_tree=null;</span>
<span class="nc" id="L10351">		RewriteRuleTokenStream stream_IMPLY=new RewriteRuleTokenStream(adaptor,&quot;token IMPLY&quot;);</span>
<span class="nc" id="L10352">		RewriteRuleSubtreeStream stream_logicalOrExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule logicalOrExpression&quot;);</span>

		try {
			// AcslParser.g:542:2: ( ( logicalOrExpression -&gt; logicalOrExpression ) ( IMPLY y= logicalOrExpression -&gt; ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) ) )* )
			// AcslParser.g:542:4: ( logicalOrExpression -&gt; logicalOrExpression ) ( IMPLY y= logicalOrExpression -&gt; ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) ) )*
			{
			// AcslParser.g:542:4: ( logicalOrExpression -&gt; logicalOrExpression )
			// AcslParser.g:542:6: logicalOrExpression
			{
<span class="nc" id="L10361">			pushFollow(FOLLOW_logicalOrExpression_in_logicalImpliesExpression4245);</span>
<span class="nc" id="L10362">			logicalOrExpression255=logicalOrExpression();</span>
<span class="nc" id="L10363">			state._fsp--;</span>
<span class="nc bnc" id="L10364" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10365" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_logicalOrExpression.add(logicalOrExpression255.getTree());</span>
			// AST REWRITE
			// elements: logicalOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L10373" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10374">			retval.tree = root_0;</span>
<span class="nc bnc" id="L10375" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10377">			root_0 = (Object)adaptor.nil();</span>
			// 542:26: -&gt; logicalOrExpression
			{
<span class="nc" id="L10380">				adaptor.addChild(root_0, stream_logicalOrExpression.nextTree());</span>
			}


<span class="nc" id="L10384">			retval.tree = root_0;</span>
			}

			}

			// AcslParser.g:543:4: ( IMPLY y= logicalOrExpression -&gt; ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) ) )*
			loop58:
			while (true) {
<span class="nc" id="L10392">				int alt58=2;</span>
<span class="nc" id="L10393">				int LA58_0 = input.LA(1);</span>
<span class="nc bnc" id="L10394" title="All 2 branches missed.">				if ( (LA58_0==IMPLY) ) {</span>
<span class="nc" id="L10395">					alt58=1;</span>
				}

<span class="nc bnc" id="L10398" title="All 2 branches missed.">				switch (alt58) {</span>
				case 1 :
					// AcslParser.g:543:6: IMPLY y= logicalOrExpression
					{
<span class="nc bnc" id="L10402" title="All 2 branches missed.">					IMPLY256=(Token)match(input,IMPLY,FOLLOW_IMPLY_in_logicalImpliesExpression4258); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10403" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_IMPLY.add(IMPLY256);</span>

<span class="nc" id="L10405">					pushFollow(FOLLOW_logicalOrExpression_in_logicalImpliesExpression4262);</span>
<span class="nc" id="L10406">					y=logicalOrExpression();</span>
<span class="nc" id="L10407">					state._fsp--;</span>
<span class="nc bnc" id="L10408" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L10409" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_logicalOrExpression.add(y.getTree());</span>
					// AST REWRITE
					// elements: y, logicalImpliesExpression, IMPLY
					// token labels: 
					// rule labels: retval, y
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L10417" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10418">					retval.tree = root_0;</span>
<span class="nc bnc" id="L10419" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L10420" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_y=new RewriteRuleSubtreeStream(adaptor,&quot;rule y&quot;,y!=null?y.getTree():null);</span>

<span class="nc" id="L10422">					root_0 = (Object)adaptor.nil();</span>
					// 544:6: -&gt; ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) )
					{
						// AcslParser.g:544:9: ^( OPERATOR IMPLY ^( ARGUMENT_LIST $logicalImpliesExpression $y) )
						{
<span class="nc" id="L10427">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L10428">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L10429">						adaptor.addChild(root_1, stream_IMPLY.nextNode());</span>
						// AcslParser.g:544:26: ^( ARGUMENT_LIST $logicalImpliesExpression $y)
						{
<span class="nc" id="L10432">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L10433">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L10434">						adaptor.addChild(root_2, stream_retval.nextTree());</span>
<span class="nc" id="L10435">						adaptor.addChild(root_2, stream_y.nextTree());</span>
<span class="nc" id="L10436">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L10439">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L10445">					retval.tree = root_0;</span>
<span class="nc" id="L10446">					}</span>

					}
					break;

				default :
<span class="nc" id="L10452">					break loop58;</span>
				}
<span class="nc" id="L10454">			}</span>

			}

<span class="nc" id="L10458">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10460" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10461">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10462">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10465">		catch (RecognitionException re) {</span>
<span class="nc" id="L10466">			reportError(re);</span>
<span class="nc" id="L10467">			recover(input,re);</span>
<span class="nc" id="L10468">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10470">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10472">		}</span>
<span class="nc" id="L10473">		return retval;</span>
	}
	// $ANTLR end &quot;logicalImpliesExpression&quot;


<span class="nc" id="L10478">	public static class conditionalExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10481">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;conditionalExpression&quot;
	// AcslParser.g:549:1: conditionalExpression : logicalImpliesExpression ( -&gt; logicalImpliesExpression | QUESTION term COLON conditionalExpression -&gt; ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) ) ) ;
	public final AcslParser.conditionalExpression_return conditionalExpression() throws RecognitionException {
<span class="nc" id="L10488">		AcslParser.conditionalExpression_return retval = new AcslParser.conditionalExpression_return();</span>
<span class="nc" id="L10489">		retval.start = input.LT(1);</span>

<span class="nc" id="L10491">		Object root_0 = null;</span>

<span class="nc" id="L10493">		Token QUESTION258=null;</span>
<span class="nc" id="L10494">		Token COLON260=null;</span>
<span class="nc" id="L10495">		ParserRuleReturnScope logicalImpliesExpression257 =null;</span>
<span class="nc" id="L10496">		ParserRuleReturnScope term259 =null;</span>
<span class="nc" id="L10497">		ParserRuleReturnScope conditionalExpression261 =null;</span>

<span class="nc" id="L10499">		Object QUESTION258_tree=null;</span>
<span class="nc" id="L10500">		Object COLON260_tree=null;</span>
<span class="nc" id="L10501">		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,&quot;token COLON&quot;);</span>
<span class="nc" id="L10502">		RewriteRuleTokenStream stream_QUESTION=new RewriteRuleTokenStream(adaptor,&quot;token QUESTION&quot;);</span>
<span class="nc" id="L10503">		RewriteRuleSubtreeStream stream_logicalImpliesExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule logicalImpliesExpression&quot;);</span>
<span class="nc" id="L10504">		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,&quot;rule term&quot;);</span>
<span class="nc" id="L10505">		RewriteRuleSubtreeStream stream_conditionalExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule conditionalExpression&quot;);</span>

		try {
			// AcslParser.g:550:2: ( logicalImpliesExpression ( -&gt; logicalImpliesExpression | QUESTION term COLON conditionalExpression -&gt; ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) ) ) )
			// AcslParser.g:550:4: logicalImpliesExpression ( -&gt; logicalImpliesExpression | QUESTION term COLON conditionalExpression -&gt; ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) ) )
			{
<span class="nc" id="L10511">			pushFollow(FOLLOW_logicalImpliesExpression_in_conditionalExpression4308);</span>
<span class="nc" id="L10512">			logicalImpliesExpression257=logicalImpliesExpression();</span>
<span class="nc" id="L10513">			state._fsp--;</span>
<span class="nc bnc" id="L10514" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10515" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_logicalImpliesExpression.add(logicalImpliesExpression257.getTree());</span>
			// AcslParser.g:551:2: ( -&gt; logicalImpliesExpression | QUESTION term COLON conditionalExpression -&gt; ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) ) )
<span class="nc" id="L10517">			int alt59=2;</span>
<span class="nc" id="L10518">			int LA59_0 = input.LA(1);</span>
<span class="nc bnc" id="L10519" title="All 20 branches missed.">			if ( (LA59_0==EOF||LA59_0==BAR||(LA59_0 &gt;= COLON &amp;&amp; LA59_0 &lt;= COMMA)||LA59_0==FOR||(LA59_0 &gt;= RCOMMENT &amp;&amp; LA59_0 &lt;= RCURLY)||(LA59_0 &gt;= RPAREN &amp;&amp; LA59_0 &lt;= RSQUARE)||LA59_0==SEMICOL) ) {</span>
<span class="nc" id="L10520">				alt59=1;</span>
			}
<span class="nc bnc" id="L10522" title="All 2 branches missed.">			else if ( (LA59_0==QUESTION) ) {</span>
<span class="nc" id="L10523">				alt59=2;</span>
			}

			else {
<span class="nc bnc" id="L10527" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10528">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 59, 0, input);
<span class="nc" id="L10530">				throw nvae;</span>
			}

<span class="nc bnc" id="L10533" title="All 3 branches missed.">			switch (alt59) {</span>
				case 1 :
					// AcslParser.g:551:4: 
					{
					// AST REWRITE
					// elements: logicalImpliesExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L10544" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10545">					retval.tree = root_0;</span>
<span class="nc bnc" id="L10546" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10548">					root_0 = (Object)adaptor.nil();</span>
					// 551:4: -&gt; logicalImpliesExpression
					{
<span class="nc" id="L10551">						adaptor.addChild(root_0, stream_logicalImpliesExpression.nextTree());</span>
					}


<span class="nc" id="L10555">					retval.tree = root_0;</span>
<span class="nc" id="L10556">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:552:8: QUESTION term COLON conditionalExpression
					{
<span class="nc bnc" id="L10563" title="All 2 branches missed.">					QUESTION258=(Token)match(input,QUESTION,FOLLOW_QUESTION_in_conditionalExpression4324); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10564" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_QUESTION.add(QUESTION258);</span>

<span class="nc" id="L10566">					pushFollow(FOLLOW_term_in_conditionalExpression4326);</span>
<span class="nc" id="L10567">					term259=term();</span>
<span class="nc" id="L10568">					state._fsp--;</span>
<span class="nc bnc" id="L10569" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L10570" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_term.add(term259.getTree());</span>
<span class="nc bnc" id="L10571" title="All 2 branches missed.">					COLON260=(Token)match(input,COLON,FOLLOW_COLON_in_conditionalExpression4328); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10572" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COLON.add(COLON260);</span>

<span class="nc" id="L10574">					pushFollow(FOLLOW_conditionalExpression_in_conditionalExpression4330);</span>
<span class="nc" id="L10575">					conditionalExpression261=conditionalExpression();</span>
<span class="nc" id="L10576">					state._fsp--;</span>
<span class="nc bnc" id="L10577" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L10578" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_conditionalExpression.add(conditionalExpression261.getTree());</span>
					// AST REWRITE
					// elements: QUESTION, term, conditionalExpression, logicalImpliesExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L10586" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10587">					retval.tree = root_0;</span>
<span class="nc bnc" id="L10588" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10590">					root_0 = (Object)adaptor.nil();</span>
					// 553:8: -&gt; ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) )
					{
						// AcslParser.g:553:11: ^( OPERATOR QUESTION ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression ) )
						{
<span class="nc" id="L10595">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L10596">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L10597">						adaptor.addChild(root_1, stream_QUESTION.nextNode());</span>
						// AcslParser.g:554:13: ^( ARGUMENT_LIST logicalImpliesExpression term conditionalExpression )
						{
<span class="nc" id="L10600">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L10601">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L10602">						adaptor.addChild(root_2, stream_logicalImpliesExpression.nextTree());</span>
<span class="nc" id="L10603">						adaptor.addChild(root_2, stream_term.nextTree());</span>
<span class="nc" id="L10604">						adaptor.addChild(root_2, stream_conditionalExpression.nextTree());</span>
<span class="nc" id="L10605">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L10608">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L10614">					retval.tree = root_0;</span>
					}

					}
					break;

			}

			}

<span class="nc" id="L10624">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10626" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10627">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10628">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10631">		catch (RecognitionException re) {</span>
<span class="nc" id="L10632">			reportError(re);</span>
<span class="nc" id="L10633">			recover(input,re);</span>
<span class="nc" id="L10634">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10636">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10638">		}</span>
<span class="nc" id="L10639">		return retval;</span>
	}
	// $ANTLR end &quot;conditionalExpression&quot;


<span class="nc" id="L10644">	public static class quantifierExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10647">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;quantifierExpression&quot;
	// AcslParser.g:563:1: quantifierExpression : quantifier binders SEMICOL assignmentExpression -&gt; ^( quantifier binders assignmentExpression ) ;
	public final AcslParser.quantifierExpression_return quantifierExpression() throws RecognitionException {
<span class="nc" id="L10654">		AcslParser.quantifierExpression_return retval = new AcslParser.quantifierExpression_return();</span>
<span class="nc" id="L10655">		retval.start = input.LT(1);</span>

<span class="nc" id="L10657">		Object root_0 = null;</span>

<span class="nc" id="L10659">		Token SEMICOL264=null;</span>
<span class="nc" id="L10660">		ParserRuleReturnScope quantifier262 =null;</span>
<span class="nc" id="L10661">		ParserRuleReturnScope binders263 =null;</span>
<span class="nc" id="L10662">		ParserRuleReturnScope assignmentExpression265 =null;</span>

<span class="nc" id="L10664">		Object SEMICOL264_tree=null;</span>
<span class="nc" id="L10665">		RewriteRuleTokenStream stream_SEMICOL=new RewriteRuleTokenStream(adaptor,&quot;token SEMICOL&quot;);</span>
<span class="nc" id="L10666">		RewriteRuleSubtreeStream stream_quantifier=new RewriteRuleSubtreeStream(adaptor,&quot;rule quantifier&quot;);</span>
<span class="nc" id="L10667">		RewriteRuleSubtreeStream stream_binders=new RewriteRuleSubtreeStream(adaptor,&quot;rule binders&quot;);</span>
<span class="nc" id="L10668">		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule assignmentExpression&quot;);</span>

		try {
			// AcslParser.g:564:2: ( quantifier binders SEMICOL assignmentExpression -&gt; ^( quantifier binders assignmentExpression ) )
			// AcslParser.g:564:4: quantifier binders SEMICOL assignmentExpression
			{
<span class="nc" id="L10674">			pushFollow(FOLLOW_quantifier_in_quantifierExpression4429);</span>
<span class="nc" id="L10675">			quantifier262=quantifier();</span>
<span class="nc" id="L10676">			state._fsp--;</span>
<span class="nc bnc" id="L10677" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10678" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_quantifier.add(quantifier262.getTree());</span>
<span class="nc" id="L10679">			pushFollow(FOLLOW_binders_in_quantifierExpression4431);</span>
<span class="nc" id="L10680">			binders263=binders();</span>
<span class="nc" id="L10681">			state._fsp--;</span>
<span class="nc bnc" id="L10682" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10683" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_binders.add(binders263.getTree());</span>
<span class="nc bnc" id="L10684" title="All 2 branches missed.">			SEMICOL264=(Token)match(input,SEMICOL,FOLLOW_SEMICOL_in_quantifierExpression4433); if (state.failed) return retval; </span>
<span class="nc bnc" id="L10685" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_SEMICOL.add(SEMICOL264);</span>

<span class="nc" id="L10687">			pushFollow(FOLLOW_assignmentExpression_in_quantifierExpression4435);</span>
<span class="nc" id="L10688">			assignmentExpression265=assignmentExpression();</span>
<span class="nc" id="L10689">			state._fsp--;</span>
<span class="nc bnc" id="L10690" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L10691" title="All 2 branches missed.">			if ( state.backtracking==0 ) stream_assignmentExpression.add(assignmentExpression265.getTree());</span>
			// AST REWRITE
			// elements: quantifier, assignmentExpression, binders
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc bnc" id="L10699" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10700">			retval.tree = root_0;</span>
<span class="nc bnc" id="L10701" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L10703">			root_0 = (Object)adaptor.nil();</span>
			// 565:4: -&gt; ^( quantifier binders assignmentExpression )
			{
				// AcslParser.g:565:7: ^( quantifier binders assignmentExpression )
				{
<span class="nc" id="L10708">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L10709">				root_1 = (Object)adaptor.becomeRoot(stream_quantifier.nextNode(), root_1);</span>
<span class="nc" id="L10710">				adaptor.addChild(root_1, stream_binders.nextTree());</span>
<span class="nc" id="L10711">				adaptor.addChild(root_1, stream_assignmentExpression.nextTree());</span>
<span class="nc" id="L10712">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L10718">			retval.tree = root_0;</span>
			}

			}

<span class="nc" id="L10723">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10725" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10726">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10727">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10730">		catch (RecognitionException re) {</span>
<span class="nc" id="L10731">			reportError(re);</span>
<span class="nc" id="L10732">			recover(input,re);</span>
<span class="nc" id="L10733">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10735">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10737">		}</span>
<span class="nc" id="L10738">		return retval;</span>
	}
	// $ANTLR end &quot;quantifierExpression&quot;


<span class="nc" id="L10743">	public static class quantifier_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10746">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;quantifier&quot;
	// AcslParser.g:579:1: quantifier : ( FORALL | EXISTS );
	public final AcslParser.quantifier_return quantifier() throws RecognitionException {
<span class="nc" id="L10753">		AcslParser.quantifier_return retval = new AcslParser.quantifier_return();</span>
<span class="nc" id="L10754">		retval.start = input.LT(1);</span>

<span class="nc" id="L10756">		Object root_0 = null;</span>

<span class="nc" id="L10758">		Token set266=null;</span>

<span class="nc" id="L10760">		Object set266_tree=null;</span>

		try {
			// AcslParser.g:580:2: ( FORALL | EXISTS )
			// AcslParser.g:
			{
<span class="nc" id="L10766">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L10769">			set266=input.LT(1);</span>
<span class="nc bnc" id="L10770" title="All 4 branches missed.">			if ( input.LA(1)==EXISTS||input.LA(1)==FORALL ) {</span>
<span class="nc" id="L10771">				input.consume();</span>
<span class="nc bnc" id="L10772" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set266));</span>
<span class="nc" id="L10773">				state.errorRecovery=false;</span>
<span class="nc" id="L10774">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L10777" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10778">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L10779">				throw mse;</span>
			}
			}

<span class="nc" id="L10783">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L10785" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L10786">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L10787">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L10790">		catch (RecognitionException re) {</span>
<span class="nc" id="L10791">			reportError(re);</span>
<span class="nc" id="L10792">			recover(input,re);</span>
<span class="nc" id="L10793">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L10795">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L10797">		}</span>
<span class="nc" id="L10798">		return retval;</span>
	}
	// $ANTLR end &quot;quantifier&quot;


<span class="nc" id="L10803">	public static class assignmentExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L10806">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;assignmentExpression&quot;
	// AcslParser.g:591:1: assignmentExpression : ( ( unaryExpression ASSIGN )=&gt; unaryExpression ASSIGN assignmentExpression -&gt; ^( OPERATOR ASSIGN ^( ARGUMENT_LIST unaryExpression assignmentExpression ) ) | conditionalExpression | quantifierExpression );
	public final AcslParser.assignmentExpression_return assignmentExpression() throws RecognitionException {
<span class="nc" id="L10813">		AcslParser.assignmentExpression_return retval = new AcslParser.assignmentExpression_return();</span>
<span class="nc" id="L10814">		retval.start = input.LT(1);</span>

<span class="nc" id="L10816">		Object root_0 = null;</span>

<span class="nc" id="L10818">		Token ASSIGN268=null;</span>
<span class="nc" id="L10819">		ParserRuleReturnScope unaryExpression267 =null;</span>
<span class="nc" id="L10820">		ParserRuleReturnScope assignmentExpression269 =null;</span>
<span class="nc" id="L10821">		ParserRuleReturnScope conditionalExpression270 =null;</span>
<span class="nc" id="L10822">		ParserRuleReturnScope quantifierExpression271 =null;</span>

<span class="nc" id="L10824">		Object ASSIGN268_tree=null;</span>
<span class="nc" id="L10825">		RewriteRuleTokenStream stream_ASSIGN=new RewriteRuleTokenStream(adaptor,&quot;token ASSIGN&quot;);</span>
<span class="nc" id="L10826">		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule assignmentExpression&quot;);</span>
<span class="nc" id="L10827">		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule unaryExpression&quot;);</span>

		try {
			// AcslParser.g:592:2: ( ( unaryExpression ASSIGN )=&gt; unaryExpression ASSIGN assignmentExpression -&gt; ^( OPERATOR ASSIGN ^( ARGUMENT_LIST unaryExpression assignmentExpression ) ) | conditionalExpression | quantifierExpression )
<span class="nc" id="L10831">			int alt60=3;</span>
<span class="nc bnc" id="L10832" title="All 28 branches missed.">			switch ( input.LA(1) ) {</span>
			case INTEGER_CONSTANT:
				{
<span class="nc" id="L10835">				int LA60_1 = input.LA(2);</span>
<span class="nc bnc" id="L10836" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10837">					alt60=1;</span>
				}
<span class="nc bnc" id="L10839" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10840">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10844" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10845">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10847">						input.consume();</span>
<span class="nc" id="L10848">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 1, input);
<span class="nc" id="L10850">						throw nvae;</span>
					} finally {
<span class="nc" id="L10852">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10857">				break;</span>
			case FLOATING_CONSTANT:
				{
<span class="nc" id="L10860">				int LA60_2 = input.LA(2);</span>
<span class="nc bnc" id="L10861" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10862">					alt60=1;</span>
				}
<span class="nc bnc" id="L10864" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10865">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10869" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10870">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10872">						input.consume();</span>
<span class="nc" id="L10873">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 2, input);
<span class="nc" id="L10875">						throw nvae;</span>
					} finally {
<span class="nc" id="L10877">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10882">				break;</span>
			case CHARACTER_CONSTANT:
				{
<span class="nc" id="L10885">				int LA60_3 = input.LA(2);</span>
<span class="nc bnc" id="L10886" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10887">					alt60=1;</span>
				}
<span class="nc bnc" id="L10889" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10890">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10894" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10895">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10897">						input.consume();</span>
<span class="nc" id="L10898">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 3, input);
<span class="nc" id="L10900">						throw nvae;</span>
					} finally {
<span class="nc" id="L10902">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10907">				break;</span>
			case TRUE:
				{
<span class="nc" id="L10910">				int LA60_4 = input.LA(2);</span>
<span class="nc bnc" id="L10911" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10912">					alt60=1;</span>
				}
<span class="nc bnc" id="L10914" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10915">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10919" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10920">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10922">						input.consume();</span>
<span class="nc" id="L10923">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 4, input);
<span class="nc" id="L10925">						throw nvae;</span>
					} finally {
<span class="nc" id="L10927">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10932">				break;</span>
			case FALSE:
				{
<span class="nc" id="L10935">				int LA60_5 = input.LA(2);</span>
<span class="nc bnc" id="L10936" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10937">					alt60=1;</span>
				}
<span class="nc bnc" id="L10939" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10940">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10944" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10945">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10947">						input.consume();</span>
<span class="nc" id="L10948">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 5, input);
<span class="nc" id="L10950">						throw nvae;</span>
					} finally {
<span class="nc" id="L10952">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10957">				break;</span>
			case RESULT:
				{
<span class="nc" id="L10960">				int LA60_6 = input.LA(2);</span>
<span class="nc bnc" id="L10961" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10962">					alt60=1;</span>
				}
<span class="nc bnc" id="L10964" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10965">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10969" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10970">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10972">						input.consume();</span>
<span class="nc" id="L10973">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 6, input);
<span class="nc" id="L10975">						throw nvae;</span>
					} finally {
<span class="nc" id="L10977">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L10982">				break;</span>
			case NOTHING:
				{
<span class="nc" id="L10985">				int LA60_7 = input.LA(2);</span>
<span class="nc bnc" id="L10986" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L10987">					alt60=1;</span>
				}
<span class="nc bnc" id="L10989" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L10990">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L10994" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L10995">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L10997">						input.consume();</span>
<span class="nc" id="L10998">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 7, input);
<span class="nc" id="L11000">						throw nvae;</span>
					} finally {
<span class="nc" id="L11002">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11007">				break;</span>
			case ELLIPSIS:
				{
<span class="nc" id="L11010">				int LA60_8 = input.LA(2);</span>
<span class="nc bnc" id="L11011" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11012">					alt60=1;</span>
				}
<span class="nc bnc" id="L11014" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11015">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11019" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11020">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11022">						input.consume();</span>
<span class="nc" id="L11023">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 8, input);
<span class="nc" id="L11025">						throw nvae;</span>
					} finally {
<span class="nc" id="L11027">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11032">				break;</span>
			case SELF:
				{
<span class="nc" id="L11035">				int LA60_9 = input.LA(2);</span>
<span class="nc bnc" id="L11036" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11037">					alt60=1;</span>
				}
<span class="nc bnc" id="L11039" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11040">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11044" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11045">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11047">						input.consume();</span>
<span class="nc" id="L11048">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 9, input);
<span class="nc" id="L11050">						throw nvae;</span>
					} finally {
<span class="nc" id="L11052">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11057">				break;</span>
			case NULL:
				{
<span class="nc" id="L11060">				int LA60_10 = input.LA(2);</span>
<span class="nc bnc" id="L11061" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11062">					alt60=1;</span>
				}
<span class="nc bnc" id="L11064" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11065">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11069" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11070">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11072">						input.consume();</span>
<span class="nc" id="L11073">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 10, input);
<span class="nc" id="L11075">						throw nvae;</span>
					} finally {
<span class="nc" id="L11077">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11082">				break;</span>
			case MPI_COMM_RANK:
			case MPI_COMM_SIZE:
				{
<span class="nc" id="L11086">				int LA60_11 = input.LA(2);</span>
<span class="nc bnc" id="L11087" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11088">					alt60=1;</span>
				}
<span class="nc bnc" id="L11090" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11091">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11095" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11096">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11098">						input.consume();</span>
<span class="nc" id="L11099">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 11, input);
<span class="nc" id="L11101">						throw nvae;</span>
					} finally {
<span class="nc" id="L11103">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11108">				break;</span>
			case ID:
				{
<span class="nc" id="L11111">				int LA60_12 = input.LA(2);</span>
<span class="nc bnc" id="L11112" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11113">					alt60=1;</span>
				}
<span class="nc bnc" id="L11115" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11116">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11120" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11121">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11123">						input.consume();</span>
<span class="nc" id="L11124">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 12, input);
<span class="nc" id="L11126">						throw nvae;</span>
					} finally {
<span class="nc" id="L11128">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11133">				break;</span>
			case STRING_LITERAL:
				{
<span class="nc" id="L11136">				int LA60_13 = input.LA(2);</span>
<span class="nc bnc" id="L11137" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11138">					alt60=1;</span>
				}
<span class="nc bnc" id="L11140" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11141">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11145" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11146">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11148">						input.consume();</span>
<span class="nc" id="L11149">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 13, input);
<span class="nc" id="L11151">						throw nvae;</span>
					} finally {
<span class="nc" id="L11153">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11158">				break;</span>
			case LCURLY:
				{
<span class="nc" id="L11161">				int LA60_14 = input.LA(2);</span>
<span class="nc bnc" id="L11162" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11163">					alt60=1;</span>
				}
<span class="nc bnc" id="L11165" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11166">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11170" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11171">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11173">						input.consume();</span>
<span class="nc" id="L11174">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 14, input);
<span class="nc" id="L11176">						throw nvae;</span>
					} finally {
<span class="nc" id="L11178">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11183">				break;</span>
			case LPAREN:
				{
<span class="nc" id="L11186">				int LA60_15 = input.LA(2);</span>
<span class="nc bnc" id="L11187" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11188">					alt60=1;</span>
				}
<span class="nc bnc" id="L11190" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11191">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11195" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11196">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11198">						input.consume();</span>
<span class="nc" id="L11199">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 15, input);
<span class="nc" id="L11201">						throw nvae;</span>
					} finally {
<span class="nc" id="L11203">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11208">				break;</span>
			case MPI_EMPTY_IN:
				{
<span class="nc" id="L11211">				int LA60_16 = input.LA(2);</span>
<span class="nc bnc" id="L11212" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11213">					alt60=1;</span>
				}
<span class="nc bnc" id="L11215" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11216">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11220" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11221">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11223">						input.consume();</span>
<span class="nc" id="L11224">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 16, input);
<span class="nc" id="L11226">						throw nvae;</span>
					} finally {
<span class="nc" id="L11228">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11233">				break;</span>
			case MPI_EMPTY_OUT:
				{
<span class="nc" id="L11236">				int LA60_17 = input.LA(2);</span>
<span class="nc bnc" id="L11237" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11238">					alt60=1;</span>
				}
<span class="nc bnc" id="L11240" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11241">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11245" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11246">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11248">						input.consume();</span>
<span class="nc" id="L11249">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 17, input);
<span class="nc" id="L11251">						throw nvae;</span>
					} finally {
<span class="nc" id="L11253">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11258">				break;</span>
			case MPI_AGREE:
				{
<span class="nc" id="L11261">				int LA60_18 = input.LA(2);</span>
<span class="nc bnc" id="L11262" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11263">					alt60=1;</span>
				}
<span class="nc bnc" id="L11265" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11266">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11270" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11271">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11273">						input.consume();</span>
<span class="nc" id="L11274">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 18, input);
<span class="nc" id="L11276">						throw nvae;</span>
					} finally {
<span class="nc" id="L11278">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11283">				break;</span>
			case MPI_REGION:
				{
<span class="nc" id="L11286">				int LA60_19 = input.LA(2);</span>
<span class="nc bnc" id="L11287" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11288">					alt60=1;</span>
				}
<span class="nc bnc" id="L11290" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11291">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11295" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11296">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11298">						input.consume();</span>
<span class="nc" id="L11299">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 19, input);
<span class="nc" id="L11301">						throw nvae;</span>
					} finally {
<span class="nc" id="L11303">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11308">				break;</span>
			case MPI_EQUALS:
				{
<span class="nc" id="L11311">				int LA60_20 = input.LA(2);</span>
<span class="nc bnc" id="L11312" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11313">					alt60=1;</span>
				}
<span class="nc bnc" id="L11315" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11316">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11320" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11321">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11323">						input.consume();</span>
<span class="nc" id="L11324">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 20, input);
<span class="nc" id="L11326">						throw nvae;</span>
					} finally {
<span class="nc" id="L11328">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11333">				break;</span>
			case REMOTE_ACCESS:
				{
<span class="nc" id="L11336">				int LA60_21 = input.LA(2);</span>
<span class="nc bnc" id="L11337" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11338">					alt60=1;</span>
				}
<span class="nc bnc" id="L11340" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11341">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11345" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11346">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11348">						input.consume();</span>
<span class="nc" id="L11349">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 21, input);
<span class="nc" id="L11351">						throw nvae;</span>
					} finally {
<span class="nc" id="L11353">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11358">				break;</span>
			case AMPERSAND:
			case COMP:
			case NOT:
			case PLUS:
			case STAR:
			case MINUS:
				{
<span class="nc" id="L11366">				int LA60_22 = input.LA(2);</span>
<span class="nc bnc" id="L11367" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11368">					alt60=1;</span>
				}
<span class="nc bnc" id="L11370" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11371">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11375" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11376">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11378">						input.consume();</span>
<span class="nc" id="L11379">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 22, input);
<span class="nc" id="L11381">						throw nvae;</span>
					} finally {
<span class="nc" id="L11383">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11388">				break;</span>
			case SIZEOF:
				{
<span class="nc" id="L11391">				int LA60_23 = input.LA(2);</span>
<span class="nc bnc" id="L11392" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11393">					alt60=1;</span>
				}
<span class="nc bnc" id="L11395" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11396">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11400" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11401">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11403">						input.consume();</span>
<span class="nc" id="L11404">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 23, input);
<span class="nc" id="L11406">						throw nvae;</span>
					} finally {
<span class="nc" id="L11408">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11413">				break;</span>
			case UNION:
				{
<span class="nc" id="L11416">				int LA60_24 = input.LA(2);</span>
<span class="nc bnc" id="L11417" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11418">					alt60=1;</span>
				}
<span class="nc bnc" id="L11420" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11421">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11425" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11426">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11428">						input.consume();</span>
<span class="nc" id="L11429">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 24, input);
<span class="nc" id="L11431">						throw nvae;</span>
					} finally {
<span class="nc" id="L11433">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11438">				break;</span>
			case INTER:
				{
<span class="nc" id="L11441">				int LA60_25 = input.LA(2);</span>
<span class="nc bnc" id="L11442" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11443">					alt60=1;</span>
				}
<span class="nc bnc" id="L11445" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11446">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11450" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11451">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11453">						input.consume();</span>
<span class="nc" id="L11454">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 25, input);
<span class="nc" id="L11456">						throw nvae;</span>
					} finally {
<span class="nc" id="L11458">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11463">				break;</span>
			case VALID:
				{
<span class="nc" id="L11466">				int LA60_26 = input.LA(2);</span>
<span class="nc bnc" id="L11467" title="All 2 branches missed.">				if ( (synpred111_AcslParser()) ) {</span>
<span class="nc" id="L11468">					alt60=1;</span>
				}
<span class="nc bnc" id="L11470" title="All 2 branches missed.">				else if ( (synpred112_AcslParser()) ) {</span>
<span class="nc" id="L11471">					alt60=2;</span>
				}

				else {
<span class="nc bnc" id="L11475" title="All 2 branches missed.">					if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11476">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L11478">						input.consume();</span>
<span class="nc" id="L11479">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 60, 26, input);
<span class="nc" id="L11481">						throw nvae;</span>
					} finally {
<span class="nc" id="L11483">						input.rewind(nvaeMark);</span>
					}
				}

				}
<span class="nc" id="L11488">				break;</span>
			case EXISTS:
			case FORALL:
				{
<span class="nc" id="L11492">				alt60=3;</span>
				}
<span class="nc" id="L11494">				break;</span>
			default:
<span class="nc bnc" id="L11496" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11497">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 60, 0, input);
<span class="nc" id="L11499">				throw nvae;</span>
			}
<span class="nc bnc" id="L11501" title="All 4 branches missed.">			switch (alt60) {</span>
				case 1 :
					// AcslParser.g:592:4: ( unaryExpression ASSIGN )=&gt; unaryExpression ASSIGN assignmentExpression
					{
<span class="nc" id="L11505">					pushFollow(FOLLOW_unaryExpression_in_assignmentExpression4507);</span>
<span class="nc" id="L11506">					unaryExpression267=unaryExpression();</span>
<span class="nc" id="L11507">					state._fsp--;</span>
<span class="nc bnc" id="L11508" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L11509" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_unaryExpression.add(unaryExpression267.getTree());</span>
<span class="nc bnc" id="L11510" title="All 2 branches missed.">					ASSIGN268=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_assignmentExpression4509); if (state.failed) return retval; </span>
<span class="nc bnc" id="L11511" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_ASSIGN.add(ASSIGN268);</span>

<span class="nc" id="L11513">					pushFollow(FOLLOW_assignmentExpression_in_assignmentExpression4511);</span>
<span class="nc" id="L11514">					assignmentExpression269=assignmentExpression();</span>
<span class="nc" id="L11515">					state._fsp--;</span>
<span class="nc bnc" id="L11516" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L11517" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_assignmentExpression.add(assignmentExpression269.getTree());</span>
					// AST REWRITE
					// elements: unaryExpression, assignmentExpression, ASSIGN
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L11525" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11526">					retval.tree = root_0;</span>
<span class="nc bnc" id="L11527" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L11529">					root_0 = (Object)adaptor.nil();</span>
					// 594:4: -&gt; ^( OPERATOR ASSIGN ^( ARGUMENT_LIST unaryExpression assignmentExpression ) )
					{
						// AcslParser.g:594:7: ^( OPERATOR ASSIGN ^( ARGUMENT_LIST unaryExpression assignmentExpression ) )
						{
<span class="nc" id="L11534">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L11535">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(OPERATOR, &quot;OPERATOR&quot;), root_1);</span>
<span class="nc" id="L11536">						adaptor.addChild(root_1, stream_ASSIGN.nextNode());</span>
						// AcslParser.g:595:9: ^( ARGUMENT_LIST unaryExpression assignmentExpression )
						{
<span class="nc" id="L11539">						Object root_2 = (Object)adaptor.nil();</span>
<span class="nc" id="L11540">						root_2 = (Object)adaptor.becomeRoot((Object)adaptor.create(ARGUMENT_LIST, &quot;ARGUMENT_LIST&quot;), root_2);</span>
<span class="nc" id="L11541">						adaptor.addChild(root_2, stream_unaryExpression.nextTree());</span>
<span class="nc" id="L11542">						adaptor.addChild(root_2, stream_assignmentExpression.nextTree());</span>
<span class="nc" id="L11543">						adaptor.addChild(root_1, root_2);</span>
						}

<span class="nc" id="L11546">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L11552">					retval.tree = root_0;</span>
<span class="nc" id="L11553">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:596:4: conditionalExpression
					{
<span class="nc" id="L11560">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L11563">					pushFollow(FOLLOW_conditionalExpression_in_assignmentExpression4543);</span>
<span class="nc" id="L11564">					conditionalExpression270=conditionalExpression();</span>
<span class="nc" id="L11565">					state._fsp--;</span>
<span class="nc bnc" id="L11566" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L11567" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, conditionalExpression270.getTree());</span>

					}
					break;
				case 3 :
					// AcslParser.g:597:4: quantifierExpression
					{
<span class="nc" id="L11574">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L11577">					pushFollow(FOLLOW_quantifierExpression_in_assignmentExpression4548);</span>
<span class="nc" id="L11578">					quantifierExpression271=quantifierExpression();</span>
<span class="nc" id="L11579">					state._fsp--;</span>
<span class="nc bnc" id="L11580" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L11581" title="All 2 branches missed.">					if ( state.backtracking==0 ) adaptor.addChild(root_0, quantifierExpression271.getTree());</span>

					}
					break;

			}
<span class="nc" id="L11587">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L11589" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11590">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L11591">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L11594">		catch (RecognitionException re) {</span>
<span class="nc" id="L11595">			reportError(re);</span>
<span class="nc" id="L11596">			recover(input,re);</span>
<span class="nc" id="L11597">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L11599">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L11601">		}</span>
<span class="nc" id="L11602">		return retval;</span>
	}
	// $ANTLR end &quot;assignmentExpression&quot;


<span class="nc" id="L11607">	public static class term_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L11610">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;term&quot;
	// AcslParser.g:608:1: term : assignmentExpression ;
	public final AcslParser.term_return term() throws RecognitionException {
<span class="nc" id="L11617">		AcslParser.term_return retval = new AcslParser.term_return();</span>
<span class="nc" id="L11618">		retval.start = input.LT(1);</span>

<span class="nc" id="L11620">		Object root_0 = null;</span>

<span class="nc" id="L11622">		ParserRuleReturnScope assignmentExpression272 =null;</span>


		try {
			// AcslParser.g:609:2: ( assignmentExpression )
			// AcslParser.g:609:4: assignmentExpression
			{
<span class="nc" id="L11629">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L11632">			pushFollow(FOLLOW_assignmentExpression_in_term4561);</span>
<span class="nc" id="L11633">			assignmentExpression272=assignmentExpression();</span>
<span class="nc" id="L11634">			state._fsp--;</span>
<span class="nc bnc" id="L11635" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L11636" title="All 2 branches missed.">			if ( state.backtracking==0 ) adaptor.addChild(root_0, assignmentExpression272.getTree());</span>

			}

<span class="nc" id="L11640">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L11642" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11643">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L11644">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L11647">		catch (RecognitionException re) {</span>
<span class="nc" id="L11648">			reportError(re);</span>
<span class="nc" id="L11649">			recover(input,re);</span>
<span class="nc" id="L11650">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L11652">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L11654">		}</span>
<span class="nc" id="L11655">		return retval;</span>
	}
	// $ANTLR end &quot;term&quot;


<span class="nc" id="L11660">	public static class constantExpression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L11663">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;constantExpression&quot;
	// AcslParser.g:613:1: constantExpression : conditionalExpression ;
	public final AcslParser.constantExpression_return constantExpression() throws RecognitionException {
<span class="nc" id="L11670">		AcslParser.constantExpression_return retval = new AcslParser.constantExpression_return();</span>
<span class="nc" id="L11671">		retval.start = input.LT(1);</span>

<span class="nc" id="L11673">		Object root_0 = null;</span>

<span class="nc" id="L11675">		ParserRuleReturnScope conditionalExpression273 =null;</span>


		try {
			// AcslParser.g:614:2: ( conditionalExpression )
			// AcslParser.g:614:4: conditionalExpression
			{
<span class="nc" id="L11682">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L11685">			pushFollow(FOLLOW_conditionalExpression_in_constantExpression4580);</span>
<span class="nc" id="L11686">			conditionalExpression273=conditionalExpression();</span>
<span class="nc" id="L11687">			state._fsp--;</span>
<span class="nc bnc" id="L11688" title="All 2 branches missed.">			if (state.failed) return retval;</span>
<span class="nc bnc" id="L11689" title="All 2 branches missed.">			if ( state.backtracking==0 ) adaptor.addChild(root_0, conditionalExpression273.getTree());</span>

			}

<span class="nc" id="L11693">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L11695" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11696">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L11697">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L11700">		catch (RecognitionException re) {</span>
<span class="nc" id="L11701">			reportError(re);</span>
<span class="nc" id="L11702">			recover(input,re);</span>
<span class="nc" id="L11703">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L11705">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L11707">		}</span>
<span class="nc" id="L11708">		return retval;</span>
	}
	// $ANTLR end &quot;constantExpression&quot;


<span class="nc" id="L11713">	public static class constant_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L11716">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;constant&quot;
	// AcslParser.g:617:1: constant : ( INTEGER_CONSTANT | FLOATING_CONSTANT | CHARACTER_CONSTANT | TRUE | FALSE | RESULT | NOTHING | ELLIPSIS | SELF | NULL | mpi_constant -&gt; ^( MPI_CONSTANT mpi_constant ) );
	public final AcslParser.constant_return constant() throws RecognitionException {
<span class="nc" id="L11723">		AcslParser.constant_return retval = new AcslParser.constant_return();</span>
<span class="nc" id="L11724">		retval.start = input.LT(1);</span>

<span class="nc" id="L11726">		Object root_0 = null;</span>

<span class="nc" id="L11728">		Token INTEGER_CONSTANT274=null;</span>
<span class="nc" id="L11729">		Token FLOATING_CONSTANT275=null;</span>
<span class="nc" id="L11730">		Token CHARACTER_CONSTANT276=null;</span>
<span class="nc" id="L11731">		Token TRUE277=null;</span>
<span class="nc" id="L11732">		Token FALSE278=null;</span>
<span class="nc" id="L11733">		Token RESULT279=null;</span>
<span class="nc" id="L11734">		Token NOTHING280=null;</span>
<span class="nc" id="L11735">		Token ELLIPSIS281=null;</span>
<span class="nc" id="L11736">		Token SELF282=null;</span>
<span class="nc" id="L11737">		Token NULL283=null;</span>
<span class="nc" id="L11738">		ParserRuleReturnScope mpi_constant284 =null;</span>

<span class="nc" id="L11740">		Object INTEGER_CONSTANT274_tree=null;</span>
<span class="nc" id="L11741">		Object FLOATING_CONSTANT275_tree=null;</span>
<span class="nc" id="L11742">		Object CHARACTER_CONSTANT276_tree=null;</span>
<span class="nc" id="L11743">		Object TRUE277_tree=null;</span>
<span class="nc" id="L11744">		Object FALSE278_tree=null;</span>
<span class="nc" id="L11745">		Object RESULT279_tree=null;</span>
<span class="nc" id="L11746">		Object NOTHING280_tree=null;</span>
<span class="nc" id="L11747">		Object ELLIPSIS281_tree=null;</span>
<span class="nc" id="L11748">		Object SELF282_tree=null;</span>
<span class="nc" id="L11749">		Object NULL283_tree=null;</span>
<span class="nc" id="L11750">		RewriteRuleSubtreeStream stream_mpi_constant=new RewriteRuleSubtreeStream(adaptor,&quot;rule mpi_constant&quot;);</span>

		try {
			// AcslParser.g:618:2: ( INTEGER_CONSTANT | FLOATING_CONSTANT | CHARACTER_CONSTANT | TRUE | FALSE | RESULT | NOTHING | ELLIPSIS | SELF | NULL | mpi_constant -&gt; ^( MPI_CONSTANT mpi_constant ) )
<span class="nc" id="L11754">			int alt61=11;</span>
<span class="nc bnc" id="L11755" title="All 12 branches missed.">			switch ( input.LA(1) ) {</span>
			case INTEGER_CONSTANT:
				{
<span class="nc" id="L11758">				alt61=1;</span>
				}
<span class="nc" id="L11760">				break;</span>
			case FLOATING_CONSTANT:
				{
<span class="nc" id="L11763">				alt61=2;</span>
				}
<span class="nc" id="L11765">				break;</span>
			case CHARACTER_CONSTANT:
				{
<span class="nc" id="L11768">				alt61=3;</span>
				}
<span class="nc" id="L11770">				break;</span>
			case TRUE:
				{
<span class="nc" id="L11773">				alt61=4;</span>
				}
<span class="nc" id="L11775">				break;</span>
			case FALSE:
				{
<span class="nc" id="L11778">				alt61=5;</span>
				}
<span class="nc" id="L11780">				break;</span>
			case RESULT:
				{
<span class="nc" id="L11783">				alt61=6;</span>
				}
<span class="nc" id="L11785">				break;</span>
			case NOTHING:
				{
<span class="nc" id="L11788">				alt61=7;</span>
				}
<span class="nc" id="L11790">				break;</span>
			case ELLIPSIS:
				{
<span class="nc" id="L11793">				alt61=8;</span>
				}
<span class="nc" id="L11795">				break;</span>
			case SELF:
				{
<span class="nc" id="L11798">				alt61=9;</span>
				}
<span class="nc" id="L11800">				break;</span>
			case NULL:
				{
<span class="nc" id="L11803">				alt61=10;</span>
				}
<span class="nc" id="L11805">				break;</span>
			case MPI_COMM_RANK:
			case MPI_COMM_SIZE:
				{
<span class="nc" id="L11809">				alt61=11;</span>
				}
<span class="nc" id="L11811">				break;</span>
			default:
<span class="nc bnc" id="L11813" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L11814">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 61, 0, input);
<span class="nc" id="L11816">				throw nvae;</span>
			}
<span class="nc bnc" id="L11818" title="All 12 branches missed.">			switch (alt61) {</span>
				case 1 :
					// AcslParser.g:618:4: INTEGER_CONSTANT
					{
<span class="nc" id="L11822">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11825" title="All 2 branches missed.">					INTEGER_CONSTANT274=(Token)match(input,INTEGER_CONSTANT,FOLLOW_INTEGER_CONSTANT_in_constant4592); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11826" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11827">					INTEGER_CONSTANT274_tree = (Object)adaptor.create(INTEGER_CONSTANT274);</span>
<span class="nc" id="L11828">					adaptor.addChild(root_0, INTEGER_CONSTANT274_tree);</span>
					}

					}
					break;
				case 2 :
					// AcslParser.g:619:4: FLOATING_CONSTANT
					{
<span class="nc" id="L11836">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11839" title="All 2 branches missed.">					FLOATING_CONSTANT275=(Token)match(input,FLOATING_CONSTANT,FOLLOW_FLOATING_CONSTANT_in_constant4597); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11840" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11841">					FLOATING_CONSTANT275_tree = (Object)adaptor.create(FLOATING_CONSTANT275);</span>
<span class="nc" id="L11842">					adaptor.addChild(root_0, FLOATING_CONSTANT275_tree);</span>
					}

					}
					break;
				case 3 :
					// AcslParser.g:620:4: CHARACTER_CONSTANT
					{
<span class="nc" id="L11850">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11853" title="All 2 branches missed.">					CHARACTER_CONSTANT276=(Token)match(input,CHARACTER_CONSTANT,FOLLOW_CHARACTER_CONSTANT_in_constant4602); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11854" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11855">					CHARACTER_CONSTANT276_tree = (Object)adaptor.create(CHARACTER_CONSTANT276);</span>
<span class="nc" id="L11856">					adaptor.addChild(root_0, CHARACTER_CONSTANT276_tree);</span>
					}

					}
					break;
				case 4 :
					// AcslParser.g:621:4: TRUE
					{
<span class="nc" id="L11864">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11867" title="All 2 branches missed.">					TRUE277=(Token)match(input,TRUE,FOLLOW_TRUE_in_constant4607); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11868" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11869">					TRUE277_tree = (Object)adaptor.create(TRUE277);</span>
<span class="nc" id="L11870">					adaptor.addChild(root_0, TRUE277_tree);</span>
					}

					}
					break;
				case 5 :
					// AcslParser.g:621:11: FALSE
					{
<span class="nc" id="L11878">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11881" title="All 2 branches missed.">					FALSE278=(Token)match(input,FALSE,FOLLOW_FALSE_in_constant4611); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11882" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11883">					FALSE278_tree = (Object)adaptor.create(FALSE278);</span>
<span class="nc" id="L11884">					adaptor.addChild(root_0, FALSE278_tree);</span>
					}

					}
					break;
				case 6 :
					// AcslParser.g:621:19: RESULT
					{
<span class="nc" id="L11892">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11895" title="All 2 branches missed.">					RESULT279=(Token)match(input,RESULT,FOLLOW_RESULT_in_constant4615); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11896" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11897">					RESULT279_tree = (Object)adaptor.create(RESULT279);</span>
<span class="nc" id="L11898">					adaptor.addChild(root_0, RESULT279_tree);</span>
					}

					}
					break;
				case 7 :
					// AcslParser.g:621:28: NOTHING
					{
<span class="nc" id="L11906">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11909" title="All 2 branches missed.">					NOTHING280=(Token)match(input,NOTHING,FOLLOW_NOTHING_in_constant4619); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11910" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11911">					NOTHING280_tree = (Object)adaptor.create(NOTHING280);</span>
<span class="nc" id="L11912">					adaptor.addChild(root_0, NOTHING280_tree);</span>
					}

					}
					break;
				case 8 :
					// AcslParser.g:621:38: ELLIPSIS
					{
<span class="nc" id="L11920">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11923" title="All 2 branches missed.">					ELLIPSIS281=(Token)match(input,ELLIPSIS,FOLLOW_ELLIPSIS_in_constant4623); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11924" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11925">					ELLIPSIS281_tree = (Object)adaptor.create(ELLIPSIS281);</span>
<span class="nc" id="L11926">					adaptor.addChild(root_0, ELLIPSIS281_tree);</span>
					}

					}
					break;
				case 9 :
					// AcslParser.g:622:7: SELF
					{
<span class="nc" id="L11934">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11937" title="All 2 branches missed.">					SELF282=(Token)match(input,SELF,FOLLOW_SELF_in_constant4631); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11938" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11939">					SELF282_tree = (Object)adaptor.create(SELF282);</span>
<span class="nc" id="L11940">					adaptor.addChild(root_0, SELF282_tree);</span>
					}

					}
					break;
				case 10 :
					// AcslParser.g:622:14: NULL
					{
<span class="nc" id="L11948">					root_0 = (Object)adaptor.nil();</span>


<span class="nc bnc" id="L11951" title="All 2 branches missed.">					NULL283=(Token)match(input,NULL,FOLLOW_NULL_in_constant4635); if (state.failed) return retval;</span>
<span class="nc bnc" id="L11952" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11953">					NULL283_tree = (Object)adaptor.create(NULL283);</span>
<span class="nc" id="L11954">					adaptor.addChild(root_0, NULL283_tree);</span>
					}

					}
					break;
				case 11 :
					// AcslParser.g:623:7: mpi_constant
					{
<span class="nc" id="L11962">					pushFollow(FOLLOW_mpi_constant_in_constant4643);</span>
<span class="nc" id="L11963">					mpi_constant284=mpi_constant();</span>
<span class="nc" id="L11964">					state._fsp--;</span>
<span class="nc bnc" id="L11965" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L11966" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_mpi_constant.add(mpi_constant284.getTree());</span>
					// AST REWRITE
					// elements: mpi_constant
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L11974" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L11975">					retval.tree = root_0;</span>
<span class="nc bnc" id="L11976" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L11978">					root_0 = (Object)adaptor.nil();</span>
					// 623:20: -&gt; ^( MPI_CONSTANT mpi_constant )
					{
						// AcslParser.g:623:23: ^( MPI_CONSTANT mpi_constant )
						{
<span class="nc" id="L11983">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L11984">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(MPI_CONSTANT, &quot;MPI_CONSTANT&quot;), root_1);</span>
<span class="nc" id="L11985">						adaptor.addChild(root_1, stream_mpi_constant.nextTree());</span>
<span class="nc" id="L11986">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L11992">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L11999">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12001" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12002">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12003">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12006">		catch (RecognitionException re) {</span>
<span class="nc" id="L12007">			reportError(re);</span>
<span class="nc" id="L12008">			recover(input,re);</span>
<span class="nc" id="L12009">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12011">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12013">		}</span>
<span class="nc" id="L12014">		return retval;</span>
	}
	// $ANTLR end &quot;constant&quot;


<span class="nc" id="L12019">	public static class mpi_expression_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L12022">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;mpi_expression&quot;
	// AcslParser.g:627:1: mpi_expression : ( MPI_EMPTY_IN LPAREN primaryExpression RPAREN -&gt; ^( MPI_EMPTY_IN primaryExpression ) | MPI_EMPTY_OUT LPAREN primaryExpression RPAREN -&gt; ^( MPI_EMPTY_OUT primaryExpression ) | MPI_AGREE LPAREN a= variable_ident_base RPAREN -&gt; ^( MPI_AGREE $a) | MPI_REGION LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression RPAREN -&gt; ^( MPI_REGION $a $b $c) | MPI_EQUALS LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression COMMA d= primaryExpression RPAREN -&gt; ^( MPI_EQUALS $a $b $c $d) );
	public final AcslParser.mpi_expression_return mpi_expression() throws RecognitionException {
<span class="nc" id="L12029">		AcslParser.mpi_expression_return retval = new AcslParser.mpi_expression_return();</span>
<span class="nc" id="L12030">		retval.start = input.LT(1);</span>

<span class="nc" id="L12032">		Object root_0 = null;</span>

<span class="nc" id="L12034">		Token MPI_EMPTY_IN285=null;</span>
<span class="nc" id="L12035">		Token LPAREN286=null;</span>
<span class="nc" id="L12036">		Token RPAREN288=null;</span>
<span class="nc" id="L12037">		Token MPI_EMPTY_OUT289=null;</span>
<span class="nc" id="L12038">		Token LPAREN290=null;</span>
<span class="nc" id="L12039">		Token RPAREN292=null;</span>
<span class="nc" id="L12040">		Token MPI_AGREE293=null;</span>
<span class="nc" id="L12041">		Token LPAREN294=null;</span>
<span class="nc" id="L12042">		Token RPAREN295=null;</span>
<span class="nc" id="L12043">		Token MPI_REGION296=null;</span>
<span class="nc" id="L12044">		Token LPAREN297=null;</span>
<span class="nc" id="L12045">		Token COMMA298=null;</span>
<span class="nc" id="L12046">		Token COMMA299=null;</span>
<span class="nc" id="L12047">		Token RPAREN300=null;</span>
<span class="nc" id="L12048">		Token MPI_EQUALS301=null;</span>
<span class="nc" id="L12049">		Token LPAREN302=null;</span>
<span class="nc" id="L12050">		Token COMMA303=null;</span>
<span class="nc" id="L12051">		Token COMMA304=null;</span>
<span class="nc" id="L12052">		Token COMMA305=null;</span>
<span class="nc" id="L12053">		Token RPAREN306=null;</span>
<span class="nc" id="L12054">		ParserRuleReturnScope a =null;</span>
<span class="nc" id="L12055">		ParserRuleReturnScope b =null;</span>
<span class="nc" id="L12056">		ParserRuleReturnScope c =null;</span>
<span class="nc" id="L12057">		ParserRuleReturnScope d =null;</span>
<span class="nc" id="L12058">		ParserRuleReturnScope primaryExpression287 =null;</span>
<span class="nc" id="L12059">		ParserRuleReturnScope primaryExpression291 =null;</span>

<span class="nc" id="L12061">		Object MPI_EMPTY_IN285_tree=null;</span>
<span class="nc" id="L12062">		Object LPAREN286_tree=null;</span>
<span class="nc" id="L12063">		Object RPAREN288_tree=null;</span>
<span class="nc" id="L12064">		Object MPI_EMPTY_OUT289_tree=null;</span>
<span class="nc" id="L12065">		Object LPAREN290_tree=null;</span>
<span class="nc" id="L12066">		Object RPAREN292_tree=null;</span>
<span class="nc" id="L12067">		Object MPI_AGREE293_tree=null;</span>
<span class="nc" id="L12068">		Object LPAREN294_tree=null;</span>
<span class="nc" id="L12069">		Object RPAREN295_tree=null;</span>
<span class="nc" id="L12070">		Object MPI_REGION296_tree=null;</span>
<span class="nc" id="L12071">		Object LPAREN297_tree=null;</span>
<span class="nc" id="L12072">		Object COMMA298_tree=null;</span>
<span class="nc" id="L12073">		Object COMMA299_tree=null;</span>
<span class="nc" id="L12074">		Object RPAREN300_tree=null;</span>
<span class="nc" id="L12075">		Object MPI_EQUALS301_tree=null;</span>
<span class="nc" id="L12076">		Object LPAREN302_tree=null;</span>
<span class="nc" id="L12077">		Object COMMA303_tree=null;</span>
<span class="nc" id="L12078">		Object COMMA304_tree=null;</span>
<span class="nc" id="L12079">		Object COMMA305_tree=null;</span>
<span class="nc" id="L12080">		Object RPAREN306_tree=null;</span>
<span class="nc" id="L12081">		RewriteRuleTokenStream stream_MPI_REGION=new RewriteRuleTokenStream(adaptor,&quot;token MPI_REGION&quot;);</span>
<span class="nc" id="L12082">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L12083">		RewriteRuleTokenStream stream_MPI_EMPTY_OUT=new RewriteRuleTokenStream(adaptor,&quot;token MPI_EMPTY_OUT&quot;);</span>
<span class="nc" id="L12084">		RewriteRuleTokenStream stream_MPI_EMPTY_IN=new RewriteRuleTokenStream(adaptor,&quot;token MPI_EMPTY_IN&quot;);</span>
<span class="nc" id="L12085">		RewriteRuleTokenStream stream_MPI_EQUALS=new RewriteRuleTokenStream(adaptor,&quot;token MPI_EQUALS&quot;);</span>
<span class="nc" id="L12086">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L12087">		RewriteRuleTokenStream stream_MPI_AGREE=new RewriteRuleTokenStream(adaptor,&quot;token MPI_AGREE&quot;);</span>
<span class="nc" id="L12088">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L12089">		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,&quot;rule primaryExpression&quot;);</span>
<span class="nc" id="L12090">		RewriteRuleSubtreeStream stream_variable_ident_base=new RewriteRuleSubtreeStream(adaptor,&quot;rule variable_ident_base&quot;);</span>

		try {
			// AcslParser.g:628:5: ( MPI_EMPTY_IN LPAREN primaryExpression RPAREN -&gt; ^( MPI_EMPTY_IN primaryExpression ) | MPI_EMPTY_OUT LPAREN primaryExpression RPAREN -&gt; ^( MPI_EMPTY_OUT primaryExpression ) | MPI_AGREE LPAREN a= variable_ident_base RPAREN -&gt; ^( MPI_AGREE $a) | MPI_REGION LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression RPAREN -&gt; ^( MPI_REGION $a $b $c) | MPI_EQUALS LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression COMMA d= primaryExpression RPAREN -&gt; ^( MPI_EQUALS $a $b $c $d) )
<span class="nc" id="L12094">			int alt62=5;</span>
<span class="nc bnc" id="L12095" title="All 6 branches missed.">			switch ( input.LA(1) ) {</span>
			case MPI_EMPTY_IN:
				{
<span class="nc" id="L12098">				alt62=1;</span>
				}
<span class="nc" id="L12100">				break;</span>
			case MPI_EMPTY_OUT:
				{
<span class="nc" id="L12103">				alt62=2;</span>
				}
<span class="nc" id="L12105">				break;</span>
			case MPI_AGREE:
				{
<span class="nc" id="L12108">				alt62=3;</span>
				}
<span class="nc" id="L12110">				break;</span>
			case MPI_REGION:
				{
<span class="nc" id="L12113">				alt62=4;</span>
				}
<span class="nc" id="L12115">				break;</span>
			case MPI_EQUALS:
				{
<span class="nc" id="L12118">				alt62=5;</span>
				}
<span class="nc" id="L12120">				break;</span>
			default:
<span class="nc bnc" id="L12122" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L12123">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 62, 0, input);
<span class="nc" id="L12125">				throw nvae;</span>
			}
<span class="nc bnc" id="L12127" title="All 6 branches missed.">			switch (alt62) {</span>
				case 1 :
					// AcslParser.g:628:7: MPI_EMPTY_IN LPAREN primaryExpression RPAREN
					{
<span class="nc bnc" id="L12131" title="All 2 branches missed.">					MPI_EMPTY_IN285=(Token)match(input,MPI_EMPTY_IN,FOLLOW_MPI_EMPTY_IN_in_mpi_expression4667); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12132" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MPI_EMPTY_IN.add(MPI_EMPTY_IN285);</span>

<span class="nc bnc" id="L12134" title="All 2 branches missed.">					LPAREN286=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_expression4669); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12135" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN286);</span>

<span class="nc" id="L12137">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4671);</span>
<span class="nc" id="L12138">					primaryExpression287=primaryExpression();</span>
<span class="nc" id="L12139">					state._fsp--;</span>
<span class="nc bnc" id="L12140" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12141" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(primaryExpression287.getTree());</span>
<span class="nc bnc" id="L12142" title="All 2 branches missed.">					RPAREN288=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_expression4673); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12143" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN288);</span>

					// AST REWRITE
					// elements: primaryExpression, MPI_EMPTY_IN
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L12152" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12153">					retval.tree = root_0;</span>
<span class="nc bnc" id="L12154" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L12156">					root_0 = (Object)adaptor.nil();</span>
					// 629:7: -&gt; ^( MPI_EMPTY_IN primaryExpression )
					{
						// AcslParser.g:629:10: ^( MPI_EMPTY_IN primaryExpression )
						{
<span class="nc" id="L12161">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L12162">						root_1 = (Object)adaptor.becomeRoot(stream_MPI_EMPTY_IN.nextNode(), root_1);</span>
<span class="nc" id="L12163">						adaptor.addChild(root_1, stream_primaryExpression.nextTree());</span>
<span class="nc" id="L12164">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L12170">					retval.tree = root_0;</span>
<span class="nc" id="L12171">					}</span>

					}
					break;
				case 2 :
					// AcslParser.g:630:7: MPI_EMPTY_OUT LPAREN primaryExpression RPAREN
					{
<span class="nc bnc" id="L12178" title="All 2 branches missed.">					MPI_EMPTY_OUT289=(Token)match(input,MPI_EMPTY_OUT,FOLLOW_MPI_EMPTY_OUT_in_mpi_expression4695); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12179" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MPI_EMPTY_OUT.add(MPI_EMPTY_OUT289);</span>

<span class="nc bnc" id="L12181" title="All 2 branches missed.">					LPAREN290=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_expression4697); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12182" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN290);</span>

<span class="nc" id="L12184">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4699);</span>
<span class="nc" id="L12185">					primaryExpression291=primaryExpression();</span>
<span class="nc" id="L12186">					state._fsp--;</span>
<span class="nc bnc" id="L12187" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12188" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(primaryExpression291.getTree());</span>
<span class="nc bnc" id="L12189" title="All 2 branches missed.">					RPAREN292=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_expression4701); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12190" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN292);</span>

					// AST REWRITE
					// elements: primaryExpression, MPI_EMPTY_OUT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L12199" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12200">					retval.tree = root_0;</span>
<span class="nc bnc" id="L12201" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L12203">					root_0 = (Object)adaptor.nil();</span>
					// 631:7: -&gt; ^( MPI_EMPTY_OUT primaryExpression )
					{
						// AcslParser.g:631:10: ^( MPI_EMPTY_OUT primaryExpression )
						{
<span class="nc" id="L12208">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L12209">						root_1 = (Object)adaptor.becomeRoot(stream_MPI_EMPTY_OUT.nextNode(), root_1);</span>
<span class="nc" id="L12210">						adaptor.addChild(root_1, stream_primaryExpression.nextTree());</span>
<span class="nc" id="L12211">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L12217">					retval.tree = root_0;</span>
<span class="nc" id="L12218">					}</span>

					}
					break;
				case 3 :
					// AcslParser.g:632:7: MPI_AGREE LPAREN a= variable_ident_base RPAREN
					{
<span class="nc bnc" id="L12225" title="All 2 branches missed.">					MPI_AGREE293=(Token)match(input,MPI_AGREE,FOLLOW_MPI_AGREE_in_mpi_expression4723); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12226" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MPI_AGREE.add(MPI_AGREE293);</span>

<span class="nc bnc" id="L12228" title="All 2 branches missed.">					LPAREN294=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_expression4725); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12229" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN294);</span>

<span class="nc" id="L12231">					pushFollow(FOLLOW_variable_ident_base_in_mpi_expression4729);</span>
<span class="nc" id="L12232">					a=variable_ident_base();</span>
<span class="nc" id="L12233">					state._fsp--;</span>
<span class="nc bnc" id="L12234" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12235" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_variable_ident_base.add(a.getTree());</span>
<span class="nc bnc" id="L12236" title="All 2 branches missed.">					RPAREN295=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_expression4731); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12237" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN295);</span>

					// AST REWRITE
					// elements: MPI_AGREE, a
					// token labels: 
					// rule labels: retval, a
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L12246" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12247">					retval.tree = root_0;</span>
<span class="nc bnc" id="L12248" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L12249" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,&quot;rule a&quot;,a!=null?a.getTree():null);</span>

<span class="nc" id="L12251">					root_0 = (Object)adaptor.nil();</span>
					// 633:7: -&gt; ^( MPI_AGREE $a)
					{
						// AcslParser.g:633:10: ^( MPI_AGREE $a)
						{
<span class="nc" id="L12256">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L12257">						root_1 = (Object)adaptor.becomeRoot(stream_MPI_AGREE.nextNode(), root_1);</span>
<span class="nc" id="L12258">						adaptor.addChild(root_1, stream_a.nextTree());</span>
<span class="nc" id="L12259">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L12265">					retval.tree = root_0;</span>
<span class="nc" id="L12266">					}</span>

					}
					break;
				case 4 :
					// AcslParser.g:634:7: MPI_REGION LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression RPAREN
					{
<span class="nc bnc" id="L12273" title="All 2 branches missed.">					MPI_REGION296=(Token)match(input,MPI_REGION,FOLLOW_MPI_REGION_in_mpi_expression4757); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12274" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MPI_REGION.add(MPI_REGION296);</span>

<span class="nc bnc" id="L12276" title="All 2 branches missed.">					LPAREN297=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_expression4759); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12277" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN297);</span>

<span class="nc" id="L12279">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4763);</span>
<span class="nc" id="L12280">					a=primaryExpression();</span>
<span class="nc" id="L12281">					state._fsp--;</span>
<span class="nc bnc" id="L12282" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12283" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(a.getTree());</span>
<span class="nc bnc" id="L12284" title="All 2 branches missed.">					COMMA298=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_expression4765); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12285" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA298);</span>

<span class="nc" id="L12287">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4769);</span>
<span class="nc" id="L12288">					b=primaryExpression();</span>
<span class="nc" id="L12289">					state._fsp--;</span>
<span class="nc bnc" id="L12290" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12291" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(b.getTree());</span>
<span class="nc bnc" id="L12292" title="All 2 branches missed.">					COMMA299=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_expression4771); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12293" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA299);</span>

<span class="nc" id="L12295">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4775);</span>
<span class="nc" id="L12296">					c=primaryExpression();</span>
<span class="nc" id="L12297">					state._fsp--;</span>
<span class="nc bnc" id="L12298" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12299" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(c.getTree());</span>
<span class="nc bnc" id="L12300" title="All 2 branches missed.">					RPAREN300=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_expression4777); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12301" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN300);</span>

					// AST REWRITE
					// elements: a, c, b, MPI_REGION
					// token labels: 
					// rule labels: retval, b, c, a
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L12310" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12311">					retval.tree = root_0;</span>
<span class="nc bnc" id="L12312" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L12313" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,&quot;rule b&quot;,b!=null?b.getTree():null);</span>
<span class="nc bnc" id="L12314" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;rule c&quot;,c!=null?c.getTree():null);</span>
<span class="nc bnc" id="L12315" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,&quot;rule a&quot;,a!=null?a.getTree():null);</span>

<span class="nc" id="L12317">					root_0 = (Object)adaptor.nil();</span>
					// 635:7: -&gt; ^( MPI_REGION $a $b $c)
					{
						// AcslParser.g:635:10: ^( MPI_REGION $a $b $c)
						{
<span class="nc" id="L12322">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L12323">						root_1 = (Object)adaptor.becomeRoot(stream_MPI_REGION.nextNode(), root_1);</span>
<span class="nc" id="L12324">						adaptor.addChild(root_1, stream_a.nextTree());</span>
<span class="nc" id="L12325">						adaptor.addChild(root_1, stream_b.nextTree());</span>
<span class="nc" id="L12326">						adaptor.addChild(root_1, stream_c.nextTree());</span>
<span class="nc" id="L12327">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L12333">					retval.tree = root_0;</span>
<span class="nc" id="L12334">					}</span>

					}
					break;
				case 5 :
					// AcslParser.g:636:7: MPI_EQUALS LPAREN a= primaryExpression COMMA b= primaryExpression COMMA c= primaryExpression COMMA d= primaryExpression RPAREN
					{
<span class="nc bnc" id="L12341" title="All 2 branches missed.">					MPI_EQUALS301=(Token)match(input,MPI_EQUALS,FOLLOW_MPI_EQUALS_in_mpi_expression4806); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12342" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_MPI_EQUALS.add(MPI_EQUALS301);</span>

<span class="nc bnc" id="L12344" title="All 2 branches missed.">					LPAREN302=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_mpi_expression4808); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12345" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_LPAREN.add(LPAREN302);</span>

<span class="nc" id="L12347">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4812);</span>
<span class="nc" id="L12348">					a=primaryExpression();</span>
<span class="nc" id="L12349">					state._fsp--;</span>
<span class="nc bnc" id="L12350" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12351" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(a.getTree());</span>
<span class="nc bnc" id="L12352" title="All 2 branches missed.">					COMMA303=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_expression4814); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12353" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA303);</span>

<span class="nc" id="L12355">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4818);</span>
<span class="nc" id="L12356">					b=primaryExpression();</span>
<span class="nc" id="L12357">					state._fsp--;</span>
<span class="nc bnc" id="L12358" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12359" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(b.getTree());</span>
<span class="nc bnc" id="L12360" title="All 2 branches missed.">					COMMA304=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_expression4820); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12361" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA304);</span>

<span class="nc" id="L12363">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4824);</span>
<span class="nc" id="L12364">					c=primaryExpression();</span>
<span class="nc" id="L12365">					state._fsp--;</span>
<span class="nc bnc" id="L12366" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12367" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(c.getTree());</span>
<span class="nc bnc" id="L12368" title="All 2 branches missed.">					COMMA305=(Token)match(input,COMMA,FOLLOW_COMMA_in_mpi_expression4826); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12369" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_COMMA.add(COMMA305);</span>

<span class="nc" id="L12371">					pushFollow(FOLLOW_primaryExpression_in_mpi_expression4830);</span>
<span class="nc" id="L12372">					d=primaryExpression();</span>
<span class="nc" id="L12373">					state._fsp--;</span>
<span class="nc bnc" id="L12374" title="All 2 branches missed.">					if (state.failed) return retval;</span>
<span class="nc bnc" id="L12375" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_primaryExpression.add(d.getTree());</span>
<span class="nc bnc" id="L12376" title="All 2 branches missed.">					RPAREN306=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_mpi_expression4832); if (state.failed) return retval; </span>
<span class="nc bnc" id="L12377" title="All 2 branches missed.">					if ( state.backtracking==0 ) stream_RPAREN.add(RPAREN306);</span>

					// AST REWRITE
					// elements: d, c, a, b, MPI_EQUALS
					// token labels: 
					// rule labels: retval, d, b, c, a
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc bnc" id="L12386" title="All 2 branches missed.">					if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12387">					retval.tree = root_0;</span>
<span class="nc bnc" id="L12388" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L12389" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d=new RewriteRuleSubtreeStream(adaptor,&quot;rule d&quot;,d!=null?d.getTree():null);</span>
<span class="nc bnc" id="L12390" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,&quot;rule b&quot;,b!=null?b.getTree():null);</span>
<span class="nc bnc" id="L12391" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;rule c&quot;,c!=null?c.getTree():null);</span>
<span class="nc bnc" id="L12392" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,&quot;rule a&quot;,a!=null?a.getTree():null);</span>

<span class="nc" id="L12394">					root_0 = (Object)adaptor.nil();</span>
					// 637:7: -&gt; ^( MPI_EQUALS $a $b $c $d)
					{
						// AcslParser.g:637:10: ^( MPI_EQUALS $a $b $c $d)
						{
<span class="nc" id="L12399">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L12400">						root_1 = (Object)adaptor.becomeRoot(stream_MPI_EQUALS.nextNode(), root_1);</span>
<span class="nc" id="L12401">						adaptor.addChild(root_1, stream_a.nextTree());</span>
<span class="nc" id="L12402">						adaptor.addChild(root_1, stream_b.nextTree());</span>
<span class="nc" id="L12403">						adaptor.addChild(root_1, stream_c.nextTree());</span>
<span class="nc" id="L12404">						adaptor.addChild(root_1, stream_d.nextTree());</span>
<span class="nc" id="L12405">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L12411">					retval.tree = root_0;</span>
					}

					}
					break;

			}
<span class="nc" id="L12418">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12420" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12421">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12422">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12425">		catch (RecognitionException re) {</span>
<span class="nc" id="L12426">			reportError(re);</span>
<span class="nc" id="L12427">			recover(input,re);</span>
<span class="nc" id="L12428">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12430">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12432">		}</span>
<span class="nc" id="L12433">		return retval;</span>
	}
	// $ANTLR end &quot;mpi_expression&quot;


<span class="nc" id="L12438">	public static class mpi_constant_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L12441">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;mpi_constant&quot;
	// AcslParser.g:640:1: mpi_constant : ( MPI_COMM_RANK | MPI_COMM_SIZE );
	public final AcslParser.mpi_constant_return mpi_constant() throws RecognitionException {
<span class="nc" id="L12448">		AcslParser.mpi_constant_return retval = new AcslParser.mpi_constant_return();</span>
<span class="nc" id="L12449">		retval.start = input.LT(1);</span>

<span class="nc" id="L12451">		Object root_0 = null;</span>

<span class="nc" id="L12453">		Token set307=null;</span>

<span class="nc" id="L12455">		Object set307_tree=null;</span>

		try {
			// AcslParser.g:641:5: ( MPI_COMM_RANK | MPI_COMM_SIZE )
			// AcslParser.g:
			{
<span class="nc" id="L12461">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L12464">			set307=input.LT(1);</span>
<span class="nc bnc" id="L12465" title="All 4 branches missed.">			if ( (input.LA(1) &gt;= MPI_COMM_RANK &amp;&amp; input.LA(1) &lt;= MPI_COMM_SIZE) ) {</span>
<span class="nc" id="L12466">				input.consume();</span>
<span class="nc bnc" id="L12467" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set307));</span>
<span class="nc" id="L12468">				state.errorRecovery=false;</span>
<span class="nc" id="L12469">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L12472" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L12473">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L12474">				throw mse;</span>
			}
			}

<span class="nc" id="L12478">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12480" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12481">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12482">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12485">		catch (RecognitionException re) {</span>
<span class="nc" id="L12486">			reportError(re);</span>
<span class="nc" id="L12487">			recover(input,re);</span>
<span class="nc" id="L12488">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12490">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12492">		}</span>
<span class="nc" id="L12493">		return retval;</span>
	}
	// $ANTLR end &quot;mpi_constant&quot;


<span class="nc" id="L12498">	public static class mpi_collective_kind_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L12501">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;mpi_collective_kind&quot;
	// AcslParser.g:644:1: mpi_collective_kind : ( COL | P2P | BOTH );
	public final AcslParser.mpi_collective_kind_return mpi_collective_kind() throws RecognitionException {
<span class="nc" id="L12508">		AcslParser.mpi_collective_kind_return retval = new AcslParser.mpi_collective_kind_return();</span>
<span class="nc" id="L12509">		retval.start = input.LT(1);</span>

<span class="nc" id="L12511">		Object root_0 = null;</span>

<span class="nc" id="L12513">		Token set308=null;</span>

<span class="nc" id="L12515">		Object set308_tree=null;</span>

		try {
			// AcslParser.g:645:5: ( COL | P2P | BOTH )
			// AcslParser.g:
			{
<span class="nc" id="L12521">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L12524">			set308=input.LT(1);</span>
<span class="nc bnc" id="L12525" title="All 6 branches missed.">			if ( input.LA(1)==BOTH||input.LA(1)==COL||input.LA(1)==P2P ) {</span>
<span class="nc" id="L12526">				input.consume();</span>
<span class="nc bnc" id="L12527" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set308));</span>
<span class="nc" id="L12528">				state.errorRecovery=false;</span>
<span class="nc" id="L12529">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L12532" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L12533">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L12534">				throw mse;</span>
			}
			}

<span class="nc" id="L12538">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12540" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12541">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12542">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12545">		catch (RecognitionException re) {</span>
<span class="nc" id="L12546">			reportError(re);</span>
<span class="nc" id="L12547">			recover(input,re);</span>
<span class="nc" id="L12548">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12550">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12552">		}</span>
<span class="nc" id="L12553">		return retval;</span>
	}
	// $ANTLR end &quot;mpi_collective_kind&quot;


<span class="nc" id="L12558">	public static class unary_op_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L12561">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;unary_op&quot;
	// AcslParser.g:648:1: unary_op : ( PLUS | MINUS | NOT | COMP | STAR | AMPERSAND );
	public final AcslParser.unary_op_return unary_op() throws RecognitionException {
<span class="nc" id="L12568">		AcslParser.unary_op_return retval = new AcslParser.unary_op_return();</span>
<span class="nc" id="L12569">		retval.start = input.LT(1);</span>

<span class="nc" id="L12571">		Object root_0 = null;</span>

<span class="nc" id="L12573">		Token set309=null;</span>

<span class="nc" id="L12575">		Object set309_tree=null;</span>

		try {
			// AcslParser.g:649:5: ( PLUS | MINUS | NOT | COMP | STAR | AMPERSAND )
			// AcslParser.g:
			{
<span class="nc" id="L12581">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L12584">			set309=input.LT(1);</span>
<span class="nc bnc" id="L12585" title="All 12 branches missed.">			if ( input.LA(1)==AMPERSAND||input.LA(1)==COMP||input.LA(1)==NOT||input.LA(1)==PLUS||input.LA(1)==STAR||input.LA(1)==MINUS ) {</span>
<span class="nc" id="L12586">				input.consume();</span>
<span class="nc bnc" id="L12587" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set309));</span>
<span class="nc" id="L12588">				state.errorRecovery=false;</span>
<span class="nc" id="L12589">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L12592" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L12593">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L12594">				throw mse;</span>
			}
			}

<span class="nc" id="L12598">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12600" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12601">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12602">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12605">		catch (RecognitionException re) {</span>
<span class="nc" id="L12606">			reportError(re);</span>
<span class="nc" id="L12607">			recover(input,re);</span>
<span class="nc" id="L12608">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12610">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12612">		}</span>
<span class="nc" id="L12613">		return retval;</span>
	}
	// $ANTLR end &quot;unary_op&quot;


<span class="nc" id="L12618">	public static class binary_op_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L12621">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;binary_op&quot;
	// AcslParser.g:652:1: binary_op : ( PLUS | MINUS | STAR | DIVIDE | MOD | LSHIFT | RSHIFT | EQ | NEQ | LTE | GTE | LT | GT | LAND | LOR | XOR | AMPERSAND | BAR | IMPLY | EQUIV | BITXOR );
	public final AcslParser.binary_op_return binary_op() throws RecognitionException {
<span class="nc" id="L12628">		AcslParser.binary_op_return retval = new AcslParser.binary_op_return();</span>
<span class="nc" id="L12629">		retval.start = input.LT(1);</span>

<span class="nc" id="L12631">		Object root_0 = null;</span>

<span class="nc" id="L12633">		Token set310=null;</span>

<span class="nc" id="L12635">		Object set310_tree=null;</span>

		try {
			// AcslParser.g:653:5: ( PLUS | MINUS | STAR | DIVIDE | MOD | LSHIFT | RSHIFT | EQ | NEQ | LTE | GTE | LT | GT | LAND | LOR | XOR | AMPERSAND | BAR | IMPLY | EQUIV | BITXOR )
			// AcslParser.g:
			{
<span class="nc" id="L12641">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L12644">			set310=input.LT(1);</span>
<span class="nc bnc" id="L12645" title="All 42 branches missed.">			if ( input.LA(1)==AMPERSAND||input.LA(1)==BAR||input.LA(1)==BITXOR||input.LA(1)==DIVIDE||(input.LA(1) &gt;= EQ &amp;&amp; input.LA(1) &lt;= EQUIV)||(input.LA(1) &gt;= GT &amp;&amp; input.LA(1) &lt;= GTE)||input.LA(1)==IMPLY||input.LA(1)==LAND||input.LA(1)==LOR||(input.LA(1) &gt;= LT &amp;&amp; input.LA(1) &lt;= LTE)||input.LA(1)==MOD||input.LA(1)==NEQ||input.LA(1)==PLUS||input.LA(1)==STAR||input.LA(1)==XOR||(input.LA(1) &gt;= LSHIFT &amp;&amp; input.LA(1) &lt;= MINUS)||input.LA(1)==RSHIFT ) {</span>
<span class="nc" id="L12646">				input.consume();</span>
<span class="nc bnc" id="L12647" title="All 2 branches missed.">				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set310));</span>
<span class="nc" id="L12648">				state.errorRecovery=false;</span>
<span class="nc" id="L12649">				state.failed=false;</span>
			}
			else {
<span class="nc bnc" id="L12652" title="All 2 branches missed.">				if (state.backtracking&gt;0) {state.failed=true; return retval;}</span>
<span class="nc" id="L12653">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L12654">				throw mse;</span>
			}
			}

<span class="nc" id="L12658">			retval.stop = input.LT(-1);</span>

<span class="nc bnc" id="L12660" title="All 2 branches missed.">			if ( state.backtracking==0 ) {</span>
<span class="nc" id="L12661">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L12662">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>
			}
		}
<span class="nc" id="L12665">		catch (RecognitionException re) {</span>
<span class="nc" id="L12666">			reportError(re);</span>
<span class="nc" id="L12667">			recover(input,re);</span>
<span class="nc" id="L12668">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L12670">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L12672">		}</span>
<span class="nc" id="L12673">		return retval;</span>
	}
	// $ANTLR end &quot;binary_op&quot;

	// $ANTLR start synpred1_AcslParser
	public final void synpred1_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:76:7: ( function_contract )
		// AcslParser.g:76:7: function_contract
		{
<span class="nc" id="L12682">		pushFollow(FOLLOW_function_contract_in_synpred1_AcslParser391);</span>
<span class="nc" id="L12683">		function_contract();</span>
<span class="nc" id="L12684">		state._fsp--;</span>
<span class="nc bnc" id="L12685" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12689">	}</span>
	// $ANTLR end synpred1_AcslParser

	// $ANTLR start synpred10_AcslParser
	public final void synpred10_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:124:7: ( LOOP VARIANT term )
		// AcslParser.g:124:7: LOOP VARIANT term
		{
<span class="nc bnc" id="L12697" title="All 2 branches missed.">		match(input,LOOP,FOLLOW_LOOP_in_synpred10_AcslParser816); if (state.failed) return;</span>

<span class="nc bnc" id="L12699" title="All 2 branches missed.">		match(input,VARIANT,FOLLOW_VARIANT_in_synpred10_AcslParser818); if (state.failed) return;</span>

<span class="nc" id="L12701">		pushFollow(FOLLOW_term_in_synpred10_AcslParser820);</span>
<span class="nc" id="L12702">		term();</span>
<span class="nc" id="L12703">		state._fsp--;</span>
<span class="nc bnc" id="L12704" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12708">	}</span>
	// $ANTLR end synpred10_AcslParser

	// $ANTLR start synpred16_AcslParser
	public final void synpred16_AcslParser_fragment() throws RecognitionException {
<span class="nc" id="L12713">		List&lt;Object&gt; list_b=null;</span>
<span class="nc" id="L12714">		RuleReturnScope b = null;</span>

		// AcslParser.g:153:30: (b+= named_behavior_block )
		// AcslParser.g:153:30: b+= named_behavior_block
		{
<span class="nc" id="L12719">		pushFollow(FOLLOW_named_behavior_block_in_synpred16_AcslParser1044);</span>
<span class="nc" id="L12720">		b=named_behavior_block();</span>
<span class="nc" id="L12721">		state._fsp--;</span>
<span class="nc bnc" id="L12722" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12726">	}</span>
	// $ANTLR end synpred16_AcslParser

	// $ANTLR start synpred17_AcslParser
	public final void synpred17_AcslParser_fragment() throws RecognitionException {
<span class="nc" id="L12731">		List&lt;Object&gt; list_c=null;</span>
<span class="nc" id="L12732">		RuleReturnScope c = null;</span>

		// AcslParser.g:154:10: (c+= completeness_clause_block )
		// AcslParser.g:154:10: c+= completeness_clause_block
		{
<span class="nc" id="L12737">		pushFollow(FOLLOW_completeness_clause_block_in_synpred17_AcslParser1060);</span>
<span class="nc" id="L12738">		c=completeness_clause_block();</span>
<span class="nc" id="L12739">		state._fsp--;</span>
<span class="nc bnc" id="L12740" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12744">	}</span>
	// $ANTLR end synpred17_AcslParser

	// $ANTLR start synpred19_AcslParser
	public final void synpred19_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:165:28: ( completeness_clause_block )
		// AcslParser.g:165:28: completeness_clause_block
		{
<span class="nc" id="L12752">		pushFollow(FOLLOW_completeness_clause_block_in_synpred19_AcslParser1119);</span>
<span class="nc" id="L12753">		completeness_clause_block();</span>
<span class="nc" id="L12754">		state._fsp--;</span>
<span class="nc bnc" id="L12755" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12759">	}</span>
	// $ANTLR end synpred19_AcslParser

	// $ANTLR start synpred40_AcslParser
	public final void synpred40_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:225:7: ( variable_ident_base LSQUARE RSQUARE )
		// AcslParser.g:225:7: variable_ident_base LSQUARE RSQUARE
		{
<span class="nc" id="L12767">		pushFollow(FOLLOW_variable_ident_base_in_synpred40_AcslParser1594);</span>
<span class="nc" id="L12768">		variable_ident_base();</span>
<span class="nc" id="L12769">		state._fsp--;</span>
<span class="nc bnc" id="L12770" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12772" title="All 2 branches missed.">		match(input,LSQUARE,FOLLOW_LSQUARE_in_synpred40_AcslParser1596); if (state.failed) return;</span>

<span class="nc bnc" id="L12774" title="All 2 branches missed.">		match(input,RSQUARE,FOLLOW_RSQUARE_in_synpred40_AcslParser1598); if (state.failed) return;</span>

		}

<span class="nc" id="L12778">	}</span>
	// $ANTLR end synpred40_AcslParser

	// $ANTLR start synpred50_AcslParser
	public final void synpred50_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:281:7: ( event_base PLUS event_base )
		// AcslParser.g:281:7: event_base PLUS event_base
		{
<span class="nc" id="L12786">		pushFollow(FOLLOW_event_base_in_synpred50_AcslParser1981);</span>
<span class="nc" id="L12787">		event_base();</span>
<span class="nc" id="L12788">		state._fsp--;</span>
<span class="nc bnc" id="L12789" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12791" title="All 2 branches missed.">		match(input,PLUS,FOLLOW_PLUS_in_synpred50_AcslParser1983); if (state.failed) return;</span>

<span class="nc" id="L12793">		pushFollow(FOLLOW_event_base_in_synpred50_AcslParser1985);</span>
<span class="nc" id="L12794">		event_base();</span>
<span class="nc" id="L12795">		state._fsp--;</span>
<span class="nc bnc" id="L12796" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12800">	}</span>
	// $ANTLR end synpred50_AcslParser

	// $ANTLR start synpred51_AcslParser
	public final void synpred51_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:283:7: ( event_base SUB event_base )
		// AcslParser.g:283:7: event_base SUB event_base
		{
<span class="nc" id="L12808">		pushFollow(FOLLOW_event_base_in_synpred51_AcslParser2011);</span>
<span class="nc" id="L12809">		event_base();</span>
<span class="nc" id="L12810">		state._fsp--;</span>
<span class="nc bnc" id="L12811" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12813" title="All 2 branches missed.">		match(input,SUB,FOLLOW_SUB_in_synpred51_AcslParser2013); if (state.failed) return;</span>

<span class="nc" id="L12815">		pushFollow(FOLLOW_event_base_in_synpred51_AcslParser2015);</span>
<span class="nc" id="L12816">		event_base();</span>
<span class="nc" id="L12817">		state._fsp--;</span>
<span class="nc bnc" id="L12818" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12822">	}</span>
	// $ANTLR end synpred51_AcslParser

	// $ANTLR start synpred52_AcslParser
	public final void synpred52_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:285:7: ( event_base AMPERSAND event_base )
		// AcslParser.g:285:7: event_base AMPERSAND event_base
		{
<span class="nc" id="L12830">		pushFollow(FOLLOW_event_base_in_synpred52_AcslParser2041);</span>
<span class="nc" id="L12831">		event_base();</span>
<span class="nc" id="L12832">		state._fsp--;</span>
<span class="nc bnc" id="L12833" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12835" title="All 2 branches missed.">		match(input,AMPERSAND,FOLLOW_AMPERSAND_in_synpred52_AcslParser2043); if (state.failed) return;</span>

<span class="nc" id="L12837">		pushFollow(FOLLOW_event_base_in_synpred52_AcslParser2045);</span>
<span class="nc" id="L12838">		event_base();</span>
<span class="nc" id="L12839">		state._fsp--;</span>
<span class="nc bnc" id="L12840" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12844">	}</span>
	// $ANTLR end synpred52_AcslParser

	// $ANTLR start synpred70_AcslParser
	public final void synpred70_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:350:7: ( LCURLY term BAR binders ( SEMICOL term )? RCURLY )
		// AcslParser.g:350:7: LCURLY term BAR binders ( SEMICOL term )? RCURLY
		{
<span class="nc bnc" id="L12852" title="All 2 branches missed.">		match(input,LCURLY,FOLLOW_LCURLY_in_synpred70_AcslParser2608); if (state.failed) return;</span>

<span class="nc" id="L12854">		pushFollow(FOLLOW_term_in_synpred70_AcslParser2610);</span>
<span class="nc" id="L12855">		term();</span>
<span class="nc" id="L12856">		state._fsp--;</span>
<span class="nc bnc" id="L12857" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12859" title="All 2 branches missed.">		match(input,BAR,FOLLOW_BAR_in_synpred70_AcslParser2612); if (state.failed) return;</span>

<span class="nc" id="L12861">		pushFollow(FOLLOW_binders_in_synpred70_AcslParser2614);</span>
<span class="nc" id="L12862">		binders();</span>
<span class="nc" id="L12863">		state._fsp--;</span>
<span class="nc bnc" id="L12864" title="All 2 branches missed.">		if (state.failed) return;</span>

		// AcslParser.g:350:31: ( SEMICOL term )?
<span class="nc" id="L12867">		int alt66=2;</span>
<span class="nc" id="L12868">		int LA66_0 = input.LA(1);</span>
<span class="nc bnc" id="L12869" title="All 2 branches missed.">		if ( (LA66_0==SEMICOL) ) {</span>
<span class="nc" id="L12870">			alt66=1;</span>
		}
<span class="nc bnc" id="L12872" title="All 2 branches missed.">		switch (alt66) {</span>
			case 1 :
				// AcslParser.g:350:32: SEMICOL term
				{
<span class="nc bnc" id="L12876" title="All 2 branches missed.">				match(input,SEMICOL,FOLLOW_SEMICOL_in_synpred70_AcslParser2617); if (state.failed) return;</span>

<span class="nc" id="L12878">				pushFollow(FOLLOW_term_in_synpred70_AcslParser2619);</span>
<span class="nc" id="L12879">				term();</span>
<span class="nc" id="L12880">				state._fsp--;</span>
<span class="nc bnc" id="L12881" title="All 2 branches missed.">				if (state.failed) return;</span>

				}
				break;

		}

<span class="nc bnc" id="L12888" title="All 2 branches missed.">		match(input,RCURLY,FOLLOW_RCURLY_in_synpred70_AcslParser2623); if (state.failed) return;</span>

		}

<span class="nc" id="L12892">	}</span>
	// $ANTLR end synpred70_AcslParser

	// $ANTLR start synpred71_AcslParser
	public final void synpred71_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:352:7: ( LCURLY term RCURLY )
		// AcslParser.g:352:7: LCURLY term RCURLY
		{
<span class="nc bnc" id="L12900" title="All 2 branches missed.">		match(input,LCURLY,FOLLOW_LCURLY_in_synpred71_AcslParser2651); if (state.failed) return;</span>

<span class="nc" id="L12902">		pushFollow(FOLLOW_term_in_synpred71_AcslParser2653);</span>
<span class="nc" id="L12903">		term();</span>
<span class="nc" id="L12904">		state._fsp--;</span>
<span class="nc bnc" id="L12905" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12907" title="All 2 branches missed.">		match(input,RCURLY,FOLLOW_RCURLY_in_synpred71_AcslParser2655); if (state.failed) return;</span>

		}

<span class="nc" id="L12911">	}</span>
	// $ANTLR end synpred71_AcslParser

	// $ANTLR start synpred79_AcslParser
	public final void synpred79_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:384:26: ( COMMA assignmentExpression )
		// AcslParser.g:384:26: COMMA assignmentExpression
		{
<span class="nc bnc" id="L12919" title="All 2 branches missed.">		match(input,COMMA,FOLLOW_COMMA_in_synpred79_AcslParser2965); if (state.failed) return;</span>

<span class="nc" id="L12921">		pushFollow(FOLLOW_assignmentExpression_in_synpred79_AcslParser2967);</span>
<span class="nc" id="L12922">		assignmentExpression();</span>
<span class="nc" id="L12923">		state._fsp--;</span>
<span class="nc bnc" id="L12924" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12928">	}</span>
	// $ANTLR end synpred79_AcslParser

	// $ANTLR start synpred82_AcslParser
	public final void synpred82_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:393:4: ( SIZEOF LPAREN type_expr )
		// AcslParser.g:393:5: SIZEOF LPAREN type_expr
		{
<span class="nc bnc" id="L12936" title="All 2 branches missed.">		match(input,SIZEOF,FOLLOW_SIZEOF_in_synpred82_AcslParser3024); if (state.failed) return;</span>

<span class="nc bnc" id="L12938" title="All 2 branches missed.">		match(input,LPAREN,FOLLOW_LPAREN_in_synpred82_AcslParser3026); if (state.failed) return;</span>

<span class="nc" id="L12940">		pushFollow(FOLLOW_type_expr_in_synpred82_AcslParser3028);</span>
<span class="nc" id="L12941">		type_expr();</span>
<span class="nc" id="L12942">		state._fsp--;</span>
<span class="nc bnc" id="L12943" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12947">	}</span>
	// $ANTLR end synpred82_AcslParser

	// $ANTLR start synpred83_AcslParser
	public final void synpred83_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:395:4: ( SIZEOF unaryExpression )
		// AcslParser.g:395:4: SIZEOF unaryExpression
		{
<span class="nc bnc" id="L12955" title="All 2 branches missed.">		match(input,SIZEOF,FOLLOW_SIZEOF_in_synpred83_AcslParser3054); if (state.failed) return;</span>

<span class="nc" id="L12957">		pushFollow(FOLLOW_unaryExpression_in_synpred83_AcslParser3056);</span>
<span class="nc" id="L12958">		unaryExpression();</span>
<span class="nc" id="L12959">		state._fsp--;</span>
<span class="nc bnc" id="L12960" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L12964">	}</span>
	// $ANTLR end synpred83_AcslParser

	// $ANTLR start synpred86_AcslParser
	public final void synpred86_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:420:4: ( LPAREN type_expr RPAREN )
		// AcslParser.g:420:5: LPAREN type_expr RPAREN
		{
<span class="nc bnc" id="L12972" title="All 2 branches missed.">		match(input,LPAREN,FOLLOW_LPAREN_in_synpred86_AcslParser3203); if (state.failed) return;</span>

<span class="nc" id="L12974">		pushFollow(FOLLOW_type_expr_in_synpred86_AcslParser3205);</span>
<span class="nc" id="L12975">		type_expr();</span>
<span class="nc" id="L12976">		state._fsp--;</span>
<span class="nc bnc" id="L12977" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L12979" title="All 2 branches missed.">		match(input,RPAREN,FOLLOW_RPAREN_in_synpred86_AcslParser3207); if (state.failed) return;</span>

		}

<span class="nc" id="L12983">	}</span>
	// $ANTLR end synpred86_AcslParser

	// $ANTLR start synpred87_AcslParser
	public final void synpred87_AcslParser_fragment() throws RecognitionException {
<span class="nc" id="L12988">		ParserRuleReturnScope y =null;</span>


		// AcslParser.g:427:4: ( HASH y= castExpression )
		// AcslParser.g:427:4: HASH y= castExpression
		{
<span class="nc bnc" id="L12994" title="All 2 branches missed.">		match(input,HASH,FOLLOW_HASH_in_synpred87_AcslParser3258); if (state.failed) return;</span>

<span class="nc" id="L12996">		pushFollow(FOLLOW_castExpression_in_synpred87_AcslParser3262);</span>
<span class="nc" id="L12997">		y=castExpression();</span>
<span class="nc" id="L12998">		state._fsp--;</span>
<span class="nc bnc" id="L12999" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L13003">	}</span>
	// $ANTLR end synpred87_AcslParser

	// $ANTLR start synpred105_AcslParser
	public final void synpred105_AcslParser_fragment() throws RecognitionException {
<span class="nc" id="L13008">		ParserRuleReturnScope y =null;</span>


		// AcslParser.g:519:6: ( BAR y= exclusiveOrExpression )
		// AcslParser.g:519:6: BAR y= exclusiveOrExpression
		{
<span class="nc bnc" id="L13014" title="All 2 branches missed.">		match(input,BAR,FOLLOW_BAR_in_synpred105_AcslParser4074); if (state.failed) return;</span>

<span class="nc" id="L13016">		pushFollow(FOLLOW_exclusiveOrExpression_in_synpred105_AcslParser4078);</span>
<span class="nc" id="L13017">		y=exclusiveOrExpression();</span>
<span class="nc" id="L13018">		state._fsp--;</span>
<span class="nc bnc" id="L13019" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L13023">	}</span>
	// $ANTLR end synpred105_AcslParser

	// $ANTLR start synpred111_AcslParser
	public final void synpred111_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:592:4: ( unaryExpression ASSIGN )
		// AcslParser.g:592:5: unaryExpression ASSIGN
		{
<span class="nc" id="L13031">		pushFollow(FOLLOW_unaryExpression_in_synpred111_AcslParser4498);</span>
<span class="nc" id="L13032">		unaryExpression();</span>
<span class="nc" id="L13033">		state._fsp--;</span>
<span class="nc bnc" id="L13034" title="All 2 branches missed.">		if (state.failed) return;</span>

<span class="nc bnc" id="L13036" title="All 2 branches missed.">		match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred111_AcslParser4500); if (state.failed) return;</span>

		}

<span class="nc" id="L13040">	}</span>
	// $ANTLR end synpred111_AcslParser

	// $ANTLR start synpred112_AcslParser
	public final void synpred112_AcslParser_fragment() throws RecognitionException {
		// AcslParser.g:596:4: ( conditionalExpression )
		// AcslParser.g:596:4: conditionalExpression
		{
<span class="nc" id="L13048">		pushFollow(FOLLOW_conditionalExpression_in_synpred112_AcslParser4543);</span>
<span class="nc" id="L13049">		conditionalExpression();</span>
<span class="nc" id="L13050">		state._fsp--;</span>
<span class="nc bnc" id="L13051" title="All 2 branches missed.">		if (state.failed) return;</span>

		}

<span class="nc" id="L13055">	}</span>
	// $ANTLR end synpred112_AcslParser

	// Delegated rules

	public final boolean synpred82_AcslParser() {
<span class="nc" id="L13061">		state.backtracking++;</span>
<span class="nc" id="L13062">		int start = input.mark();</span>
		try {
<span class="nc" id="L13064">			synpred82_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13065">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13066">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13067">		}</span>
<span class="nc bnc" id="L13068" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13069">		input.rewind(start);</span>
<span class="nc" id="L13070">		state.backtracking--;</span>
<span class="nc" id="L13071">		state.failed=false;</span>
<span class="nc" id="L13072">		return success;</span>
	}
	public final boolean synpred10_AcslParser() {
<span class="nc" id="L13075">		state.backtracking++;</span>
<span class="nc" id="L13076">		int start = input.mark();</span>
		try {
<span class="nc" id="L13078">			synpred10_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13079">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13080">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13081">		}</span>
<span class="nc bnc" id="L13082" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13083">		input.rewind(start);</span>
<span class="nc" id="L13084">		state.backtracking--;</span>
<span class="nc" id="L13085">		state.failed=false;</span>
<span class="nc" id="L13086">		return success;</span>
	}
	public final boolean synpred105_AcslParser() {
<span class="nc" id="L13089">		state.backtracking++;</span>
<span class="nc" id="L13090">		int start = input.mark();</span>
		try {
<span class="nc" id="L13092">			synpred105_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13093">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13094">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13095">		}</span>
<span class="nc bnc" id="L13096" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13097">		input.rewind(start);</span>
<span class="nc" id="L13098">		state.backtracking--;</span>
<span class="nc" id="L13099">		state.failed=false;</span>
<span class="nc" id="L13100">		return success;</span>
	}
	public final boolean synpred112_AcslParser() {
<span class="nc" id="L13103">		state.backtracking++;</span>
<span class="nc" id="L13104">		int start = input.mark();</span>
		try {
<span class="nc" id="L13106">			synpred112_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13107">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13108">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13109">		}</span>
<span class="nc bnc" id="L13110" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13111">		input.rewind(start);</span>
<span class="nc" id="L13112">		state.backtracking--;</span>
<span class="nc" id="L13113">		state.failed=false;</span>
<span class="nc" id="L13114">		return success;</span>
	}
	public final boolean synpred87_AcslParser() {
<span class="nc" id="L13117">		state.backtracking++;</span>
<span class="nc" id="L13118">		int start = input.mark();</span>
		try {
<span class="nc" id="L13120">			synpred87_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13121">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13122">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13123">		}</span>
<span class="nc bnc" id="L13124" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13125">		input.rewind(start);</span>
<span class="nc" id="L13126">		state.backtracking--;</span>
<span class="nc" id="L13127">		state.failed=false;</span>
<span class="nc" id="L13128">		return success;</span>
	}
	public final boolean synpred51_AcslParser() {
<span class="nc" id="L13131">		state.backtracking++;</span>
<span class="nc" id="L13132">		int start = input.mark();</span>
		try {
<span class="nc" id="L13134">			synpred51_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13135">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13136">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13137">		}</span>
<span class="nc bnc" id="L13138" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13139">		input.rewind(start);</span>
<span class="nc" id="L13140">		state.backtracking--;</span>
<span class="nc" id="L13141">		state.failed=false;</span>
<span class="nc" id="L13142">		return success;</span>
	}
	public final boolean synpred79_AcslParser() {
<span class="nc" id="L13145">		state.backtracking++;</span>
<span class="nc" id="L13146">		int start = input.mark();</span>
		try {
<span class="nc" id="L13148">			synpred79_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13149">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13150">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13151">		}</span>
<span class="nc bnc" id="L13152" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13153">		input.rewind(start);</span>
<span class="nc" id="L13154">		state.backtracking--;</span>
<span class="nc" id="L13155">		state.failed=false;</span>
<span class="nc" id="L13156">		return success;</span>
	}
	public final boolean synpred111_AcslParser() {
<span class="nc" id="L13159">		state.backtracking++;</span>
<span class="nc" id="L13160">		int start = input.mark();</span>
		try {
<span class="nc" id="L13162">			synpred111_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13163">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13164">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13165">		}</span>
<span class="nc bnc" id="L13166" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13167">		input.rewind(start);</span>
<span class="nc" id="L13168">		state.backtracking--;</span>
<span class="nc" id="L13169">		state.failed=false;</span>
<span class="nc" id="L13170">		return success;</span>
	}
	public final boolean synpred52_AcslParser() {
<span class="nc" id="L13173">		state.backtracking++;</span>
<span class="nc" id="L13174">		int start = input.mark();</span>
		try {
<span class="nc" id="L13176">			synpred52_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13177">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13178">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13179">		}</span>
<span class="nc bnc" id="L13180" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13181">		input.rewind(start);</span>
<span class="nc" id="L13182">		state.backtracking--;</span>
<span class="nc" id="L13183">		state.failed=false;</span>
<span class="nc" id="L13184">		return success;</span>
	}
	public final boolean synpred70_AcslParser() {
<span class="nc" id="L13187">		state.backtracking++;</span>
<span class="nc" id="L13188">		int start = input.mark();</span>
		try {
<span class="nc" id="L13190">			synpred70_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13191">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13192">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13193">		}</span>
<span class="nc bnc" id="L13194" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13195">		input.rewind(start);</span>
<span class="nc" id="L13196">		state.backtracking--;</span>
<span class="nc" id="L13197">		state.failed=false;</span>
<span class="nc" id="L13198">		return success;</span>
	}
	public final boolean synpred17_AcslParser() {
<span class="nc" id="L13201">		state.backtracking++;</span>
<span class="nc" id="L13202">		int start = input.mark();</span>
		try {
<span class="nc" id="L13204">			synpred17_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13205">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13206">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13207">		}</span>
<span class="nc bnc" id="L13208" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13209">		input.rewind(start);</span>
<span class="nc" id="L13210">		state.backtracking--;</span>
<span class="nc" id="L13211">		state.failed=false;</span>
<span class="nc" id="L13212">		return success;</span>
	}
	public final boolean synpred19_AcslParser() {
<span class="nc" id="L13215">		state.backtracking++;</span>
<span class="nc" id="L13216">		int start = input.mark();</span>
		try {
<span class="nc" id="L13218">			synpred19_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13219">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13220">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13221">		}</span>
<span class="nc bnc" id="L13222" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13223">		input.rewind(start);</span>
<span class="nc" id="L13224">		state.backtracking--;</span>
<span class="nc" id="L13225">		state.failed=false;</span>
<span class="nc" id="L13226">		return success;</span>
	}
	public final boolean synpred83_AcslParser() {
<span class="nc" id="L13229">		state.backtracking++;</span>
<span class="nc" id="L13230">		int start = input.mark();</span>
		try {
<span class="nc" id="L13232">			synpred83_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13233">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13234">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13235">		}</span>
<span class="nc bnc" id="L13236" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13237">		input.rewind(start);</span>
<span class="nc" id="L13238">		state.backtracking--;</span>
<span class="nc" id="L13239">		state.failed=false;</span>
<span class="nc" id="L13240">		return success;</span>
	}
	public final boolean synpred40_AcslParser() {
<span class="nc" id="L13243">		state.backtracking++;</span>
<span class="nc" id="L13244">		int start = input.mark();</span>
		try {
<span class="nc" id="L13246">			synpred40_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13247">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13248">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13249">		}</span>
<span class="nc bnc" id="L13250" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13251">		input.rewind(start);</span>
<span class="nc" id="L13252">		state.backtracking--;</span>
<span class="nc" id="L13253">		state.failed=false;</span>
<span class="nc" id="L13254">		return success;</span>
	}
	public final boolean synpred71_AcslParser() {
<span class="nc" id="L13257">		state.backtracking++;</span>
<span class="nc" id="L13258">		int start = input.mark();</span>
		try {
<span class="nc" id="L13260">			synpred71_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13261">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13262">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13263">		}</span>
<span class="nc bnc" id="L13264" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13265">		input.rewind(start);</span>
<span class="nc" id="L13266">		state.backtracking--;</span>
<span class="nc" id="L13267">		state.failed=false;</span>
<span class="nc" id="L13268">		return success;</span>
	}
	public final boolean synpred1_AcslParser() {
<span class="nc" id="L13271">		state.backtracking++;</span>
<span class="nc" id="L13272">		int start = input.mark();</span>
		try {
<span class="nc" id="L13274">			synpred1_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13275">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13276">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13277">		}</span>
<span class="nc bnc" id="L13278" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13279">		input.rewind(start);</span>
<span class="nc" id="L13280">		state.backtracking--;</span>
<span class="nc" id="L13281">		state.failed=false;</span>
<span class="nc" id="L13282">		return success;</span>
	}
	public final boolean synpred86_AcslParser() {
<span class="nc" id="L13285">		state.backtracking++;</span>
<span class="nc" id="L13286">		int start = input.mark();</span>
		try {
<span class="nc" id="L13288">			synpred86_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13289">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13290">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13291">		}</span>
<span class="nc bnc" id="L13292" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13293">		input.rewind(start);</span>
<span class="nc" id="L13294">		state.backtracking--;</span>
<span class="nc" id="L13295">		state.failed=false;</span>
<span class="nc" id="L13296">		return success;</span>
	}
	public final boolean synpred16_AcslParser() {
<span class="nc" id="L13299">		state.backtracking++;</span>
<span class="nc" id="L13300">		int start = input.mark();</span>
		try {
<span class="nc" id="L13302">			synpred16_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13303">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13304">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13305">		}</span>
<span class="nc bnc" id="L13306" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13307">		input.rewind(start);</span>
<span class="nc" id="L13308">		state.backtracking--;</span>
<span class="nc" id="L13309">		state.failed=false;</span>
<span class="nc" id="L13310">		return success;</span>
	}
	public final boolean synpred50_AcslParser() {
<span class="nc" id="L13313">		state.backtracking++;</span>
<span class="nc" id="L13314">		int start = input.mark();</span>
		try {
<span class="nc" id="L13316">			synpred50_AcslParser_fragment(); // can never throw exception</span>
<span class="nc" id="L13317">		} catch (RecognitionException re) {</span>
<span class="nc" id="L13318">			System.err.println(&quot;impossible: &quot;+re);</span>
<span class="nc" id="L13319">		}</span>
<span class="nc bnc" id="L13320" title="All 2 branches missed.">		boolean success = !state.failed;</span>
<span class="nc" id="L13321">		input.rewind(start);</span>
<span class="nc" id="L13322">		state.backtracking--;</span>
<span class="nc" id="L13323">		state.failed=false;</span>
<span class="nc" id="L13324">		return success;</span>
	}


<span class="nc" id="L13328">	protected DFA16 dfa16 = new DFA16(this);</span>
<span class="nc" id="L13329">	protected DFA17 dfa17 = new DFA17(this);</span>
	static final String DFA16_eotS =
		&quot;\23\uffff&quot;;
	static final String DFA16_eofS =
		&quot;\1\3\22\uffff&quot;;
	static final String DFA16_minS =
		&quot;\1\15\2\16\1\uffff\2\76\1\0\1\27\1\0\1\27\1\uffff\1\76\1\0\1\76\1\0\2&quot;+
		&quot;\27\2\0&quot;;
	static final String DFA16_maxS =
		&quot;\1\157\2\16\1\uffff\2\174\1\0\1\174\1\0\1\174\1\uffff\1\76\1\0\1\76\1&quot;+
		&quot;\0\2\174\2\0&quot;;
	static final String DFA16_acceptS =
		&quot;\3\uffff\1\2\6\uffff\1\1\10\uffff&quot;;
	static final String DFA16_specialS =
		&quot;\6\uffff\1\4\1\uffff\1\5\3\uffff\1\3\1\uffff\1\2\2\uffff\1\1\1\0}&gt;&quot;;
<span class="nc" id="L13344">	static final String[] DFA16_transitionS = {</span>
			&quot;\1\3\13\uffff\1\1\2\uffff\1\2\71\uffff\1\3\30\uffff\1\3&quot;,
			&quot;\1\4&quot;,
			&quot;\1\5&quot;,
			&quot;&quot;,
			&quot;\1\7\75\uffff\1\6&quot;,
			&quot;\1\11\75\uffff\1\10&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\13\144\uffff\1\14&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\15\144\uffff\1\16&quot;,
			&quot;&quot;,
			&quot;\1\17&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\20&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\13\144\uffff\1\21&quot;,
			&quot;\1\15\144\uffff\1\22&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\uffff&quot;
	};

<span class="nc" id="L13366">	static final short[] DFA16_eot = DFA.unpackEncodedString(DFA16_eotS);</span>
<span class="nc" id="L13367">	static final short[] DFA16_eof = DFA.unpackEncodedString(DFA16_eofS);</span>
<span class="nc" id="L13368">	static final char[] DFA16_min = DFA.unpackEncodedStringToUnsignedChars(DFA16_minS);</span>
<span class="nc" id="L13369">	static final char[] DFA16_max = DFA.unpackEncodedStringToUnsignedChars(DFA16_maxS);</span>
<span class="nc" id="L13370">	static final short[] DFA16_accept = DFA.unpackEncodedString(DFA16_acceptS);</span>
<span class="nc" id="L13371">	static final short[] DFA16_special = DFA.unpackEncodedString(DFA16_specialS);</span>
	static final short[][] DFA16_transition;

	static {
<span class="nc" id="L13375">		int numStates = DFA16_transitionS.length;</span>
<span class="nc" id="L13376">		DFA16_transition = new short[numStates][];</span>
<span class="nc bnc" id="L13377" title="All 2 branches missed.">		for (int i=0; i&lt;numStates; i++) {</span>
<span class="nc" id="L13378">			DFA16_transition[i] = DFA.unpackEncodedString(DFA16_transitionS[i]);</span>
		}
	}

	protected class DFA16 extends DFA {

<span class="nc" id="L13384">		public DFA16(BaseRecognizer recognizer) {</span>
<span class="nc" id="L13385">			this.recognizer = recognizer;</span>
<span class="nc" id="L13386">			this.decisionNumber = 16;</span>
<span class="nc" id="L13387">			this.eot = DFA16_eot;</span>
<span class="nc" id="L13388">			this.eof = DFA16_eof;</span>
<span class="nc" id="L13389">			this.min = DFA16_min;</span>
<span class="nc" id="L13390">			this.max = DFA16_max;</span>
<span class="nc" id="L13391">			this.accept = DFA16_accept;</span>
<span class="nc" id="L13392">			this.special = DFA16_special;</span>
<span class="nc" id="L13393">			this.transition = DFA16_transition;</span>
<span class="nc" id="L13394">		}</span>
		@Override
		public String getDescription() {
<span class="nc" id="L13397">			return &quot;()* loopback of 154:9: (c+= completeness_clause_block )*&quot;;</span>
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
<span class="nc" id="L13401">			TokenStream input = (TokenStream)_input;</span>
<span class="nc" id="L13402">			int _s = s;</span>
<span class="nc bnc" id="L13403" title="All 7 branches missed.">			switch ( s ) {</span>
					case 0 : 
<span class="nc" id="L13405">						int LA16_18 = input.LA(1);</span>
						 
<span class="nc" id="L13407">						int index16_18 = input.index();</span>
<span class="nc" id="L13408">						input.rewind();</span>
<span class="nc" id="L13409">						s = -1;</span>
<span class="nc bnc" id="L13410" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13411">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13413">						input.seek(index16_18);</span>
<span class="nc bnc" id="L13414" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 1 : 
<span class="nc" id="L13418">						int LA16_17 = input.LA(1);</span>
						 
<span class="nc" id="L13420">						int index16_17 = input.index();</span>
<span class="nc" id="L13421">						input.rewind();</span>
<span class="nc" id="L13422">						s = -1;</span>
<span class="nc bnc" id="L13423" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13424">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13426">						input.seek(index16_17);</span>
<span class="nc bnc" id="L13427" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 2 : 
<span class="nc" id="L13431">						int LA16_14 = input.LA(1);</span>
						 
<span class="nc" id="L13433">						int index16_14 = input.index();</span>
<span class="nc" id="L13434">						input.rewind();</span>
<span class="nc" id="L13435">						s = -1;</span>
<span class="nc bnc" id="L13436" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13437">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13439">						input.seek(index16_14);</span>
<span class="nc bnc" id="L13440" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 3 : 
<span class="nc" id="L13444">						int LA16_12 = input.LA(1);</span>
						 
<span class="nc" id="L13446">						int index16_12 = input.index();</span>
<span class="nc" id="L13447">						input.rewind();</span>
<span class="nc" id="L13448">						s = -1;</span>
<span class="nc bnc" id="L13449" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13450">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13452">						input.seek(index16_12);</span>
<span class="nc bnc" id="L13453" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 4 : 
<span class="nc" id="L13457">						int LA16_6 = input.LA(1);</span>
						 
<span class="nc" id="L13459">						int index16_6 = input.index();</span>
<span class="nc" id="L13460">						input.rewind();</span>
<span class="nc" id="L13461">						s = -1;</span>
<span class="nc bnc" id="L13462" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13463">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13465">						input.seek(index16_6);</span>
<span class="nc bnc" id="L13466" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 5 : 
<span class="nc" id="L13470">						int LA16_8 = input.LA(1);</span>
						 
<span class="nc" id="L13472">						int index16_8 = input.index();</span>
<span class="nc" id="L13473">						input.rewind();</span>
<span class="nc" id="L13474">						s = -1;</span>
<span class="nc bnc" id="L13475" title="All 2 branches missed.">						if ( (synpred17_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13476">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13478">						input.seek(index16_8);</span>
<span class="nc bnc" id="L13479" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;
			}
<span class="nc bnc" id="L13482" title="All 2 branches missed.">			if (state.backtracking&gt;0) {state.failed=true; return -1;}</span>
<span class="nc" id="L13483">			NoViableAltException nvae =</span>
				new NoViableAltException(getDescription(), 16, _s, input);
<span class="nc" id="L13485">			error(nvae);</span>
<span class="nc" id="L13486">			throw nvae;</span>
		}
	}

	static final String DFA17_eotS =
		&quot;\23\uffff&quot;;
	static final String DFA17_eofS =
		&quot;\1\3\22\uffff&quot;;
	static final String DFA17_minS =
		&quot;\1\15\2\16\1\uffff\2\76\1\0\1\27\1\0\1\27\1\uffff\1\76\1\0\1\76\1\0\2&quot;+
		&quot;\27\2\0&quot;;
	static final String DFA17_maxS =
		&quot;\1\157\2\16\1\uffff\2\174\1\0\1\174\1\0\1\174\1\uffff\1\76\1\0\1\76\1&quot;+
		&quot;\0\2\174\2\0&quot;;
	static final String DFA17_acceptS =
		&quot;\3\uffff\1\2\6\uffff\1\1\10\uffff&quot;;
	static final String DFA17_specialS =
		&quot;\6\uffff\1\4\1\uffff\1\5\3\uffff\1\3\1\uffff\1\2\2\uffff\1\1\1\0}&gt;&quot;;
<span class="nc" id="L13504">	static final String[] DFA17_transitionS = {</span>
			&quot;\1\3\13\uffff\1\1\2\uffff\1\2\71\uffff\1\3\30\uffff\1\3&quot;,
			&quot;\1\4&quot;,
			&quot;\1\5&quot;,
			&quot;&quot;,
			&quot;\1\7\75\uffff\1\6&quot;,
			&quot;\1\11\75\uffff\1\10&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\13\144\uffff\1\14&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\15\144\uffff\1\16&quot;,
			&quot;&quot;,
			&quot;\1\17&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\20&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\13\144\uffff\1\21&quot;,
			&quot;\1\15\144\uffff\1\22&quot;,
			&quot;\1\uffff&quot;,
			&quot;\1\uffff&quot;
	};

<span class="nc" id="L13526">	static final short[] DFA17_eot = DFA.unpackEncodedString(DFA17_eotS);</span>
<span class="nc" id="L13527">	static final short[] DFA17_eof = DFA.unpackEncodedString(DFA17_eofS);</span>
<span class="nc" id="L13528">	static final char[] DFA17_min = DFA.unpackEncodedStringToUnsignedChars(DFA17_minS);</span>
<span class="nc" id="L13529">	static final char[] DFA17_max = DFA.unpackEncodedStringToUnsignedChars(DFA17_maxS);</span>
<span class="nc" id="L13530">	static final short[] DFA17_accept = DFA.unpackEncodedString(DFA17_acceptS);</span>
<span class="nc" id="L13531">	static final short[] DFA17_special = DFA.unpackEncodedString(DFA17_specialS);</span>
	static final short[][] DFA17_transition;

	static {
<span class="nc" id="L13535">		int numStates = DFA17_transitionS.length;</span>
<span class="nc" id="L13536">		DFA17_transition = new short[numStates][];</span>
<span class="nc bnc" id="L13537" title="All 2 branches missed.">		for (int i=0; i&lt;numStates; i++) {</span>
<span class="nc" id="L13538">			DFA17_transition[i] = DFA.unpackEncodedString(DFA17_transitionS[i]);</span>
		}
	}

	protected class DFA17 extends DFA {

<span class="nc" id="L13544">		public DFA17(BaseRecognizer recognizer) {</span>
<span class="nc" id="L13545">			this.recognizer = recognizer;</span>
<span class="nc" id="L13546">			this.decisionNumber = 17;</span>
<span class="nc" id="L13547">			this.eot = DFA17_eot;</span>
<span class="nc" id="L13548">			this.eof = DFA17_eof;</span>
<span class="nc" id="L13549">			this.min = DFA17_min;</span>
<span class="nc" id="L13550">			this.max = DFA17_max;</span>
<span class="nc" id="L13551">			this.accept = DFA17_accept;</span>
<span class="nc" id="L13552">			this.special = DFA17_special;</span>
<span class="nc" id="L13553">			this.transition = DFA17_transition;</span>
<span class="nc" id="L13554">		}</span>
		@Override
		public String getDescription() {
<span class="nc" id="L13557">			return &quot;165:28: ( completeness_clause_block )?&quot;;</span>
		}
		@Override
		public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
<span class="nc" id="L13561">			TokenStream input = (TokenStream)_input;</span>
<span class="nc" id="L13562">			int _s = s;</span>
<span class="nc bnc" id="L13563" title="All 7 branches missed.">			switch ( s ) {</span>
					case 0 : 
<span class="nc" id="L13565">						int LA17_18 = input.LA(1);</span>
						 
<span class="nc" id="L13567">						int index17_18 = input.index();</span>
<span class="nc" id="L13568">						input.rewind();</span>
<span class="nc" id="L13569">						s = -1;</span>
<span class="nc bnc" id="L13570" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13571">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13573">						input.seek(index17_18);</span>
<span class="nc bnc" id="L13574" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 1 : 
<span class="nc" id="L13578">						int LA17_17 = input.LA(1);</span>
						 
<span class="nc" id="L13580">						int index17_17 = input.index();</span>
<span class="nc" id="L13581">						input.rewind();</span>
<span class="nc" id="L13582">						s = -1;</span>
<span class="nc bnc" id="L13583" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13584">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13586">						input.seek(index17_17);</span>
<span class="nc bnc" id="L13587" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 2 : 
<span class="nc" id="L13591">						int LA17_14 = input.LA(1);</span>
						 
<span class="nc" id="L13593">						int index17_14 = input.index();</span>
<span class="nc" id="L13594">						input.rewind();</span>
<span class="nc" id="L13595">						s = -1;</span>
<span class="nc bnc" id="L13596" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13597">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13599">						input.seek(index17_14);</span>
<span class="nc bnc" id="L13600" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 3 : 
<span class="nc" id="L13604">						int LA17_12 = input.LA(1);</span>
						 
<span class="nc" id="L13606">						int index17_12 = input.index();</span>
<span class="nc" id="L13607">						input.rewind();</span>
<span class="nc" id="L13608">						s = -1;</span>
<span class="nc bnc" id="L13609" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13610">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13612">						input.seek(index17_12);</span>
<span class="nc bnc" id="L13613" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 4 : 
<span class="nc" id="L13617">						int LA17_6 = input.LA(1);</span>
						 
<span class="nc" id="L13619">						int index17_6 = input.index();</span>
<span class="nc" id="L13620">						input.rewind();</span>
<span class="nc" id="L13621">						s = -1;</span>
<span class="nc bnc" id="L13622" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13623">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13625">						input.seek(index17_6);</span>
<span class="nc bnc" id="L13626" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;

					case 5 : 
<span class="nc" id="L13630">						int LA17_8 = input.LA(1);</span>
						 
<span class="nc" id="L13632">						int index17_8 = input.index();</span>
<span class="nc" id="L13633">						input.rewind();</span>
<span class="nc" id="L13634">						s = -1;</span>
<span class="nc bnc" id="L13635" title="All 2 branches missed.">						if ( (synpred19_AcslParser()) ) {s = 10;}</span>
<span class="nc" id="L13636">						else if ( (true) ) {s = 3;}</span>
						 
<span class="nc" id="L13638">						input.seek(index17_8);</span>
<span class="nc bnc" id="L13639" title="All 2 branches missed.">						if ( s&gt;=0 ) return s;</span>
						break;
			}
<span class="nc bnc" id="L13642" title="All 2 branches missed.">			if (state.backtracking&gt;0) {state.failed=true; return -1;}</span>
<span class="nc" id="L13643">			NoViableAltException nvae =</span>
				new NoViableAltException(getDescription(), 17, _s, input);
<span class="nc" id="L13645">			error(nvae);</span>
<span class="nc" id="L13646">			throw nvae;</span>
		}
	}

<span class="nc" id="L13650">	public static final BitSet FOLLOW_function_contract_in_contract391 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13651">	public static final BitSet FOLLOW_loop_contract_in_contract415 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13652">	public static final BitSet FOLLOW_LCOMMENT_in_loop_contract448 = new BitSet(new long[]{0x0000800000000000L,0x0000800000001000L});</span>
<span class="nc" id="L13653">	public static final BitSet FOLLOW_loop_contract_block_in_loop_contract450 = new BitSet(new long[]{0x0000000000000000L,0x0000800000000000L});</span>
<span class="nc" id="L13654">	public static final BitSet FOLLOW_RCOMMENT_in_loop_contract452 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13655">	public static final BitSet FOLLOW_loop_clause_in_loop_contract_block486 = new BitSet(new long[]{0x0000800000000002L,0x0000000000001000L});</span>
<span class="nc" id="L13656">	public static final BitSet FOLLOW_loop_behavior_in_loop_contract_block491 = new BitSet(new long[]{0x0000800000000002L,0x0000000000001000L});</span>
<span class="nc" id="L13657">	public static final BitSet FOLLOW_loop_variant_in_loop_contract_block496 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13658">	public static final BitSet FOLLOW_loop_invariant_in_loop_clause539 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13659">	public static final BitSet FOLLOW_SEMICOL_in_loop_clause541 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13660">	public static final BitSet FOLLOW_loop_assigns_in_loop_clause564 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13661">	public static final BitSet FOLLOW_SEMICOL_in_loop_clause566 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13662">	public static final BitSet FOLLOW_loop_allocation_in_loop_clause589 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13663">	public static final BitSet FOLLOW_SEMICOL_in_loop_clause591 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13664">	public static final BitSet FOLLOW_LOOP_in_loop_invariant623 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000010L});</span>
<span class="nc" id="L13665">	public static final BitSet FOLLOW_INVARIANT_in_loop_invariant625 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13666">	public static final BitSet FOLLOW_term_in_loop_invariant627 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13667">	public static final BitSet FOLLOW_LOOP_in_loop_assigns659 = new BitSet(new long[]{0x0000000000000200L});</span>
<span class="nc" id="L13668">	public static final BitSet FOLLOW_ASSIGNS_in_loop_assigns661 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13669">	public static final BitSet FOLLOW_argumentExpressionList_in_loop_assigns663 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13670">	public static final BitSet FOLLOW_LOOP_in_loop_allocation695 = new BitSet(new long[]{0x0000000000000010L});</span>
<span class="nc" id="L13671">	public static final BitSet FOLLOW_ALLOC_in_loop_allocation697 = new BitSet(new long[]{0x4001521001800020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13672">	public static final BitSet FOLLOW_argumentExpressionList_in_loop_allocation699 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13673">	public static final BitSet FOLLOW_COMMA_in_loop_allocation702 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13674">	public static final BitSet FOLLOW_term_in_loop_allocation704 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13675">	public static final BitSet FOLLOW_LOOP_in_loop_allocation732 = new BitSet(new long[]{0x0002000000000000L});</span>
<span class="nc" id="L13676">	public static final BitSet FOLLOW_FREES_in_loop_allocation734 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13677">	public static final BitSet FOLLOW_argumentExpressionList_in_loop_allocation736 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13678">	public static final BitSet FOLLOW_FOR_in_loop_behavior768 = new BitSet(new long[]{0x4000000000400000L});</span>
<span class="nc" id="L13679">	public static final BitSet FOLLOW_id_list_in_loop_behavior772 = new BitSet(new long[]{0x0000000000400000L});</span>
<span class="nc" id="L13680">	public static final BitSet FOLLOW_COLON_in_loop_behavior774 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});</span>
<span class="nc" id="L13681">	public static final BitSet FOLLOW_loop_clause_in_loop_behavior778 = new BitSet(new long[]{0x0000000000000002L,0x0000000000001000L});</span>
<span class="nc" id="L13682">	public static final BitSet FOLLOW_LOOP_in_loop_variant816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});</span>
<span class="nc" id="L13683">	public static final BitSet FOLLOW_VARIANT_in_loop_variant818 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13684">	public static final BitSet FOLLOW_term_in_loop_variant820 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13685">	public static final BitSet FOLLOW_LOOP_in_loop_variant843 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});</span>
<span class="nc" id="L13686">	public static final BitSet FOLLOW_VARIANT_in_loop_variant845 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13687">	public static final BitSet FOLLOW_term_in_loop_variant847 = new BitSet(new long[]{0x0000800000000000L});</span>
<span class="nc" id="L13688">	public static final BitSet FOLLOW_FOR_in_loop_variant849 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13689">	public static final BitSet FOLLOW_ID_in_loop_variant851 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13690">	public static final BitSet FOLLOW_LCOMMENT_in_function_contract887 = new BitSet(new long[]{0x004200401A002210L,0x0048A00000400000L,0x2000000000000000L});</span>
<span class="nc" id="L13691">	public static final BitSet FOLLOW_pure_function_in_function_contract889 = new BitSet(new long[]{0x004200401A002210L,0x0048800000400000L,0x2000000000000000L});</span>
<span class="nc" id="L13692">	public static final BitSet FOLLOW_full_contract_block_in_function_contract892 = new BitSet(new long[]{0x0000000000000000L,0x0000800000000000L});</span>
<span class="nc" id="L13693">	public static final BitSet FOLLOW_RCOMMENT_in_function_contract894 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13694">	public static final BitSet FOLLOW_PURE_in_pure_function928 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13695">	public static final BitSet FOLLOW_SEMICOL_in_pure_function930 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13696">	public static final BitSet FOLLOW_function_clause_in_full_contract_block963 = new BitSet(new long[]{0x004200401A002212L,0x0048000000400000L,0x2000000000000000L});</span>
<span class="nc" id="L13697">	public static final BitSet FOLLOW_contract_block_in_full_contract_block970 = new BitSet(new long[]{0x0000000012002002L,0x0000000000400000L});</span>
<span class="nc" id="L13698">	public static final BitSet FOLLOW_completeness_clause_block_in_full_contract_block985 = new BitSet(new long[]{0x0000000012000002L});</span>
<span class="nc" id="L13699">	public static final BitSet FOLLOW_function_clause_in_partial_contract_block1037 = new BitSet(new long[]{0x004200401A002212L,0x0048000000000000L,0x2000000000000000L});</span>
<span class="nc" id="L13700">	public static final BitSet FOLLOW_named_behavior_block_in_partial_contract_block1044 = new BitSet(new long[]{0x0000000012002002L});</span>
<span class="nc" id="L13701">	public static final BitSet FOLLOW_completeness_clause_block_in_partial_contract_block1060 = new BitSet(new long[]{0x0000000012000002L});</span>
<span class="nc" id="L13702">	public static final BitSet FOLLOW_mpi_collective_block_in_contract_block1109 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13703">	public static final BitSet FOLLOW_named_behavior_block_in_contract_block1117 = new BitSet(new long[]{0x0000000012000002L});</span>
<span class="nc" id="L13704">	public static final BitSet FOLLOW_completeness_clause_block_in_contract_block1119 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13705">	public static final BitSet FOLLOW_requires_clause_in_function_clause1137 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13706">	public static final BitSet FOLLOW_SEMICOL_in_function_clause1139 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13707">	public static final BitSet FOLLOW_terminates_clause_in_function_clause1154 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13708">	public static final BitSet FOLLOW_SEMICOL_in_function_clause1156 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13709">	public static final BitSet FOLLOW_simple_clause_in_function_clause1171 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13710">	public static final BitSet FOLLOW_SEMICOL_in_function_clause1173 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13711">	public static final BitSet FOLLOW_named_behavior_in_named_behavior_block1198 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13712">	public static final BitSet FOLLOW_completeness_clause_in_completeness_clause_block1223 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13713">	public static final BitSet FOLLOW_SEMICOL_in_completeness_clause_block1225 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13714">	public static final BitSet FOLLOW_REQUIRES_in_requires_clause1250 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13715">	public static final BitSet FOLLOW_term_in_requires_clause1252 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13716">	public static final BitSet FOLLOW_TEMINATES_in_terminates_clause1277 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13717">	public static final BitSet FOLLOW_term_in_terminates_clause1279 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13718">	public static final BitSet FOLLOW_binder_in_binders1341 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13719">	public static final BitSet FOLLOW_COMMA_in_binders1344 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L13720">	public static final BitSet FOLLOW_binder_in_binders1346 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13721">	public static final BitSet FOLLOW_type_expr_in_binder1381 = new BitSet(new long[]{0x4000000000000000L,0x0000000000004000L,0x0000000000000002L});</span>
<span class="nc" id="L13722">	public static final BitSet FOLLOW_variable_ident_in_binder1383 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13723">	public static final BitSet FOLLOW_COMMA_in_binder1386 = new BitSet(new long[]{0x4000000000000000L,0x0000000000004000L,0x0000000000000002L});</span>
<span class="nc" id="L13724">	public static final BitSet FOLLOW_variable_ident_in_binder1388 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13725">	public static final BitSet FOLLOW_logic_type_expr_in_type_expr1425 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13726">	public static final BitSet FOLLOW_c_type_in_type_expr1440 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13727">	public static final BitSet FOLLOW_built_in_logic_type_in_logic_type_expr1464 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13728">	public static final BitSet FOLLOW_ID_in_logic_type_expr1479 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13729">	public static final BitSet FOLLOW_STAR_in_variable_ident1569 = new BitSet(new long[]{0x4000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13730">	public static final BitSet FOLLOW_variable_ident_base_in_variable_ident1571 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13731">	public static final BitSet FOLLOW_variable_ident_base_in_variable_ident1594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});</span>
<span class="nc" id="L13732">	public static final BitSet FOLLOW_LSQUARE_in_variable_ident1596 = new BitSet(new long[]{0x0000000000000000L,0x0200000000000000L});</span>
<span class="nc" id="L13733">	public static final BitSet FOLLOW_RSQUARE_in_variable_ident1598 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13734">	public static final BitSet FOLLOW_variable_ident_base_in_variable_ident1621 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13735">	public static final BitSet FOLLOW_ID_in_variable_ident_base1653 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13736">	public static final BitSet FOLLOW_LPAREN_in_variable_ident_base1672 = new BitSet(new long[]{0x4000000000000000L,0x0000000000004000L,0x0000000000000002L});</span>
<span class="nc" id="L13737">	public static final BitSet FOLLOW_variable_ident_in_variable_ident_base1674 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13738">	public static final BitSet FOLLOW_RPAREN_in_variable_ident_base1676 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13739">	public static final BitSet FOLLOW_GUARDS_in_guards_clause1706 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13740">	public static final BitSet FOLLOW_term_in_guards_clause1708 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13741">	public static final BitSet FOLLOW_assigns_clause_in_simple_clause1732 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13742">	public static final BitSet FOLLOW_ensures_clause_in_simple_clause1740 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13743">	public static final BitSet FOLLOW_allocation_clause_in_simple_clause1749 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13744">	public static final BitSet FOLLOW_reads_clause_in_simple_clause1757 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13745">	public static final BitSet FOLLOW_depends_clause_in_simple_clause1765 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13746">	public static final BitSet FOLLOW_guards_clause_in_simple_clause1773 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13747">	public static final BitSet FOLLOW_ASSIGNS_in_assigns_clause1790 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13748">	public static final BitSet FOLLOW_argumentExpressionList_in_assigns_clause1792 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13749">	public static final BitSet FOLLOW_ENSURES_in_ensures_clause1816 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13750">	public static final BitSet FOLLOW_term_in_ensures_clause1818 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13751">	public static final BitSet FOLLOW_ALLOC_in_allocation_clause1842 = new BitSet(new long[]{0x4001521001800020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13752">	public static final BitSet FOLLOW_argumentExpressionList_in_allocation_clause1844 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13753">	public static final BitSet FOLLOW_COMMA_in_allocation_clause1847 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13754">	public static final BitSet FOLLOW_term_in_allocation_clause1849 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13755">	public static final BitSet FOLLOW_FREES_in_allocation_clause1869 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13756">	public static final BitSet FOLLOW_argumentExpressionList_in_allocation_clause1871 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13757">	public static final BitSet FOLLOW_READS_in_reads_clause1895 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13758">	public static final BitSet FOLLOW_argumentExpressionList_in_reads_clause1897 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13759">	public static final BitSet FOLLOW_DEPENDS_in_depends_clause1922 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13760">	public static final BitSet FOLLOW_event_list_in_depends_clause1924 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13761">	public static final BitSet FOLLOW_event_in_event_list1948 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13762">	public static final BitSet FOLLOW_COMMA_in_event_list1951 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13763">	public static final BitSet FOLLOW_event_in_event_list1953 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13764">	public static final BitSet FOLLOW_event_base_in_event1981 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});</span>
<span class="nc" id="L13765">	public static final BitSet FOLLOW_PLUS_in_event1983 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13766">	public static final BitSet FOLLOW_event_base_in_event1985 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13767">	public static final BitSet FOLLOW_event_base_in_event2011 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});</span>
<span class="nc" id="L13768">	public static final BitSet FOLLOW_SUB_in_event2013 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13769">	public static final BitSet FOLLOW_event_base_in_event2015 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13770">	public static final BitSet FOLLOW_event_base_in_event2041 = new BitSet(new long[]{0x0000000000000020L});</span>
<span class="nc" id="L13771">	public static final BitSet FOLLOW_AMPERSAND_in_event2043 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13772">	public static final BitSet FOLLOW_event_base_in_event2045 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13773">	public static final BitSet FOLLOW_event_base_in_event2071 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13774">	public static final BitSet FOLLOW_READ_in_event_base2104 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13775">	public static final BitSet FOLLOW_LPAREN_in_event_base2106 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13776">	public static final BitSet FOLLOW_argumentExpressionList_in_event_base2108 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13777">	public static final BitSet FOLLOW_RPAREN_in_event_base2110 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13778">	public static final BitSet FOLLOW_WRITE_in_event_base2134 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13779">	public static final BitSet FOLLOW_LPAREN_in_event_base2136 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13780">	public static final BitSet FOLLOW_argumentExpressionList_in_event_base2138 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13781">	public static final BitSet FOLLOW_RPAREN_in_event_base2140 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13782">	public static final BitSet FOLLOW_REACH_in_event_base2164 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13783">	public static final BitSet FOLLOW_LPAREN_in_event_base2166 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13784">	public static final BitSet FOLLOW_argumentExpressionList_in_event_base2168 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13785">	public static final BitSet FOLLOW_RPAREN_in_event_base2170 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13786">	public static final BitSet FOLLOW_CALL_in_event_base2194 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13787">	public static final BitSet FOLLOW_LPAREN_in_event_base2196 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13788">	public static final BitSet FOLLOW_ID_in_event_base2198 = new BitSet(new long[]{0x0000000000800000L,0x0100000000000000L});</span>
<span class="nc" id="L13789">	public static final BitSet FOLLOW_COMMA_in_event_base2201 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13790">	public static final BitSet FOLLOW_argumentExpressionList_in_event_base2203 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13791">	public static final BitSet FOLLOW_RPAREN_in_event_base2207 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13792">	public static final BitSet FOLLOW_NOACT_in_event_base2234 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13793">	public static final BitSet FOLLOW_ANYACT_in_event_base2256 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13794">	public static final BitSet FOLLOW_LPAREN_in_event_base2278 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L13795">	public static final BitSet FOLLOW_event_in_event_base2280 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13796">	public static final BitSet FOLLOW_RPAREN_in_event_base2282 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13797">	public static final BitSet FOLLOW_MPI_COLLECTIVE_in_mpi_collective_block2317 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13798">	public static final BitSet FOLLOW_LPAREN_in_mpi_collective_block2319 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13799">	public static final BitSet FOLLOW_ID_in_mpi_collective_block2321 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13800">	public static final BitSet FOLLOW_COMMA_in_mpi_collective_block2323 = new BitSet(new long[]{0x0000000000220000L,0x0000040000000000L});</span>
<span class="nc" id="L13801">	public static final BitSet FOLLOW_mpi_collective_kind_in_mpi_collective_block2327 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13802">	public static final BitSet FOLLOW_RPAREN_in_mpi_collective_block2330 = new BitSet(new long[]{0x0000000000400000L});</span>
<span class="nc" id="L13803">	public static final BitSet FOLLOW_COLON_in_mpi_collective_block2332 = new BitSet(new long[]{0x004200401A002210L,0x0048000000000000L,0x2000000000000000L});</span>
<span class="nc" id="L13804">	public static final BitSet FOLLOW_partial_contract_block_in_mpi_collective_block2342 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13805">	public static final BitSet FOLLOW_BEHAVIOR_in_named_behavior2377 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13806">	public static final BitSet FOLLOW_ID_in_named_behavior2379 = new BitSet(new long[]{0x0000000000400000L});</span>
<span class="nc" id="L13807">	public static final BitSet FOLLOW_COLON_in_named_behavior2381 = new BitSet(new long[]{0x0042004008000610L,0x0048000000000000L});</span>
<span class="nc" id="L13808">	public static final BitSet FOLLOW_behavior_body_in_named_behavior2383 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13809">	public static final BitSet FOLLOW_behavior_clause_in_behavior_body2412 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13810">	public static final BitSet FOLLOW_SEMICOL_in_behavior_body2414 = new BitSet(new long[]{0x0042004008000612L,0x0048000000000000L});</span>
<span class="nc" id="L13811">	public static final BitSet FOLLOW_assumes_clause_in_behavior_clause2443 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13812">	public static final BitSet FOLLOW_requires_clause_in_behavior_clause2452 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13813">	public static final BitSet FOLLOW_simple_clause_in_behavior_clause2460 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13814">	public static final BitSet FOLLOW_ASSUMES_in_assumes_clause2477 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13815">	public static final BitSet FOLLOW_term_in_assumes_clause2479 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13816">	public static final BitSet FOLLOW_COMPLETE_in_completeness_clause2503 = new BitSet(new long[]{0x0000000000004000L});</span>
<span class="nc" id="L13817">	public static final BitSet FOLLOW_BEHAVIORS_in_completeness_clause2505 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13818">	public static final BitSet FOLLOW_id_list_in_completeness_clause2507 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13819">	public static final BitSet FOLLOW_DISJOINT_in_completeness_clause2522 = new BitSet(new long[]{0x0000000000004000L});</span>
<span class="nc" id="L13820">	public static final BitSet FOLLOW_BEHAVIORS_in_completeness_clause2524 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13821">	public static final BitSet FOLLOW_id_list_in_completeness_clause2526 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13822">	public static final BitSet FOLLOW_ID_in_id_list2556 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13823">	public static final BitSet FOLLOW_COMMA_in_id_list2559 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13824">	public static final BitSet FOLLOW_ID_in_id_list2561 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13825">	public static final BitSet FOLLOW_constant_in_primaryExpression2587 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13826">	public static final BitSet FOLLOW_ID_in_primaryExpression2595 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13827">	public static final BitSet FOLLOW_STRING_LITERAL_in_primaryExpression2600 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13828">	public static final BitSet FOLLOW_LCURLY_in_primaryExpression2608 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13829">	public static final BitSet FOLLOW_term_in_primaryExpression2610 = new BitSet(new long[]{0x0000000000001000L});</span>
<span class="nc" id="L13830">	public static final BitSet FOLLOW_BAR_in_primaryExpression2612 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L13831">	public static final BitSet FOLLOW_binders_in_primaryExpression2614 = new BitSet(new long[]{0x0000000000000000L,0x1001000000000000L});</span>
<span class="nc" id="L13832">	public static final BitSet FOLLOW_SEMICOL_in_primaryExpression2617 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13833">	public static final BitSet FOLLOW_term_in_primaryExpression2619 = new BitSet(new long[]{0x0000000000000000L,0x0001000000000000L});</span>
<span class="nc" id="L13834">	public static final BitSet FOLLOW_RCURLY_in_primaryExpression2623 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13835">	public static final BitSet FOLLOW_LCURLY_in_primaryExpression2651 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13836">	public static final BitSet FOLLOW_term_in_primaryExpression2653 = new BitSet(new long[]{0x0000000000000000L,0x0001000000000000L});</span>
<span class="nc" id="L13837">	public static final BitSet FOLLOW_RCURLY_in_primaryExpression2655 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13838">	public static final BitSet FOLLOW_LPAREN_in_primaryExpression2675 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13839">	public static final BitSet FOLLOW_term_in_primaryExpression2677 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13840">	public static final BitSet FOLLOW_RPAREN_in_primaryExpression2679 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13841">	public static final BitSet FOLLOW_mpi_expression_in_primaryExpression2699 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13842">	public static final BitSet FOLLOW_REMOTE_ACCESS_in_primaryExpression2715 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13843">	public static final BitSet FOLLOW_LPAREN_in_primaryExpression2717 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13844">	public static final BitSet FOLLOW_ID_in_primaryExpression2721 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13845">	public static final BitSet FOLLOW_COMMA_in_primaryExpression2723 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13846">	public static final BitSet FOLLOW_primaryExpression_in_primaryExpression2727 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13847">	public static final BitSet FOLLOW_RPAREN_in_primaryExpression2729 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13848">	public static final BitSet FOLLOW_primaryExpression_in_postfixExpression2761 = new BitSet(new long[]{0x0000000040000082L,0x000000000000C000L});</span>
<span class="nc" id="L13849">	public static final BitSet FOLLOW_LSQUARE_in_postfixExpression2778 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13850">	public static final BitSet FOLLOW_term_in_postfixExpression2780 = new BitSet(new long[]{0x0000000000000000L,0x0200000000000000L});</span>
<span class="nc" id="L13851">	public static final BitSet FOLLOW_RSQUARE_in_postfixExpression2782 = new BitSet(new long[]{0x0000000040000082L,0x000000000000C000L});</span>
<span class="nc" id="L13852">	public static final BitSet FOLLOW_LPAREN_in_postfixExpression2856 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13853">	public static final BitSet FOLLOW_argumentExpressionList_in_postfixExpression2858 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13854">	public static final BitSet FOLLOW_RPAREN_in_postfixExpression2860 = new BitSet(new long[]{0x0000000040000082L,0x000000000000C000L});</span>
<span class="nc" id="L13855">	public static final BitSet FOLLOW_DOT_in_postfixExpression2891 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13856">	public static final BitSet FOLLOW_ID_in_postfixExpression2893 = new BitSet(new long[]{0x0000000040000082L,0x000000000000C000L});</span>
<span class="nc" id="L13857">	public static final BitSet FOLLOW_ARROW_in_postfixExpression2916 = new BitSet(new long[]{0x4000000000000000L});</span>
<span class="nc" id="L13858">	public static final BitSet FOLLOW_ID_in_postfixExpression2918 = new BitSet(new long[]{0x0000000040000082L,0x000000000000C000L});</span>
<span class="nc" id="L13859">	public static final BitSet FOLLOW_assignmentExpression_in_argumentExpressionList2962 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13860">	public static final BitSet FOLLOW_COMMA_in_argumentExpressionList2965 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13861">	public static final BitSet FOLLOW_assignmentExpression_in_argumentExpressionList2967 = new BitSet(new long[]{0x0000000000800002L});</span>
<span class="nc" id="L13862">	public static final BitSet FOLLOW_postfixExpression_in_unaryExpression2994 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13863">	public static final BitSet FOLLOW_unary_op_in_unaryExpression2999 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13864">	public static final BitSet FOLLOW_castExpression_in_unaryExpression3001 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13865">	public static final BitSet FOLLOW_SIZEOF_in_unaryExpression3032 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13866">	public static final BitSet FOLLOW_LPAREN_in_unaryExpression3034 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L13867">	public static final BitSet FOLLOW_type_expr_in_unaryExpression3036 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13868">	public static final BitSet FOLLOW_RPAREN_in_unaryExpression3038 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13869">	public static final BitSet FOLLOW_SIZEOF_in_unaryExpression3054 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13870">	public static final BitSet FOLLOW_unaryExpression_in_unaryExpression3056 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13871">	public static final BitSet FOLLOW_UNION_in_unaryExpression3077 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13872">	public static final BitSet FOLLOW_LPAREN_in_unaryExpression3079 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13873">	public static final BitSet FOLLOW_argumentExpressionList_in_unaryExpression3081 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13874">	public static final BitSet FOLLOW_RPAREN_in_unaryExpression3083 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13875">	public static final BitSet FOLLOW_INTER_in_unaryExpression3107 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13876">	public static final BitSet FOLLOW_LPAREN_in_unaryExpression3109 = new BitSet(new long[]{0x4001521001000020L,0x09A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13877">	public static final BitSet FOLLOW_argumentExpressionList_in_unaryExpression3111 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13878">	public static final BitSet FOLLOW_RPAREN_in_unaryExpression3113 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13879">	public static final BitSet FOLLOW_VALID_in_unaryExpression3137 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13880">	public static final BitSet FOLLOW_LPAREN_in_unaryExpression3139 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13881">	public static final BitSet FOLLOW_term_in_unaryExpression3141 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13882">	public static final BitSet FOLLOW_RPAREN_in_unaryExpression3143 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13883">	public static final BitSet FOLLOW_LPAREN_in_castExpression3213 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L13884">	public static final BitSet FOLLOW_type_expr_in_castExpression3215 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13885">	public static final BitSet FOLLOW_RPAREN_in_castExpression3217 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13886">	public static final BitSet FOLLOW_castExpression_in_castExpression3219 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13887">	public static final BitSet FOLLOW_unaryExpression_in_castExpression3237 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13888">	public static final BitSet FOLLOW_castExpression_in_remoteExpression3248 = new BitSet(new long[]{0x0080000000000002L});</span>
<span class="nc" id="L13889">	public static final BitSet FOLLOW_HASH_in_remoteExpression3258 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13890">	public static final BitSet FOLLOW_castExpression_in_remoteExpression3262 = new BitSet(new long[]{0x0080000000000002L});</span>
<span class="nc" id="L13891">	public static final BitSet FOLLOW_remoteExpression_in_multiplicativeExpression3304 = new BitSet(new long[]{0x0000000020000002L,0x0000000000100000L,0x0000000000000002L});</span>
<span class="nc" id="L13892">	public static final BitSet FOLLOW_STAR_in_multiplicativeExpression3314 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13893">	public static final BitSet FOLLOW_remoteExpression_in_multiplicativeExpression3318 = new BitSet(new long[]{0x0000000020000002L,0x0000000000100000L,0x0000000000000002L});</span>
<span class="nc" id="L13894">	public static final BitSet FOLLOW_DIVIDE_in_multiplicativeExpression3344 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13895">	public static final BitSet FOLLOW_remoteExpression_in_multiplicativeExpression3348 = new BitSet(new long[]{0x0000000020000002L,0x0000000000100000L,0x0000000000000002L});</span>
<span class="nc" id="L13896">	public static final BitSet FOLLOW_MOD_in_multiplicativeExpression3377 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13897">	public static final BitSet FOLLOW_remoteExpression_in_multiplicativeExpression3381 = new BitSet(new long[]{0x0000000020000002L,0x0000000000100000L,0x0000000000000002L});</span>
<span class="nc" id="L13898">	public static final BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3423 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L,0x0000000000000008L});</span>
<span class="nc" id="L13899">	public static final BitSet FOLLOW_PLUS_in_additiveExpression3440 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13900">	public static final BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3444 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L,0x0000000000000008L});</span>
<span class="nc" id="L13901">	public static final BitSet FOLLOW_SUB_in_additiveExpression3484 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13902">	public static final BitSet FOLLOW_multiplicativeExpression_in_additiveExpression3488 = new BitSet(new long[]{0x0000000000000002L,0x0000080000000000L,0x0000000000000008L});</span>
<span class="nc" id="L13903">	public static final BitSet FOLLOW_additiveExpression_in_rangeExpression3542 = new BitSet(new long[]{0x0000000080000002L});</span>
<span class="nc" id="L13904">	public static final BitSet FOLLOW_DOTDOT_in_rangeExpression3557 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13905">	public static final BitSet FOLLOW_additiveExpression_in_rangeExpression3561 = new BitSet(new long[]{0x0080000000000002L});</span>
<span class="nc" id="L13906">	public static final BitSet FOLLOW_HASH_in_rangeExpression3595 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13907">	public static final BitSet FOLLOW_additiveExpression_in_rangeExpression3599 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13908">	public static final BitSet FOLLOW_rangeExpression_in_shiftExpression3660 = new BitSet(new long[]{0x0000000000000002L,0x6000000000000000L});</span>
<span class="nc" id="L13909">	public static final BitSet FOLLOW_SHIFTLEFT_in_shiftExpression3677 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13910">	public static final BitSet FOLLOW_rangeExpression_in_shiftExpression3681 = new BitSet(new long[]{0x0000000000000002L,0x6000000000000000L});</span>
<span class="nc" id="L13911">	public static final BitSet FOLLOW_SHIFTRIGHT_in_shiftExpression3721 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13912">	public static final BitSet FOLLOW_rangeExpression_in_shiftExpression3725 = new BitSet(new long[]{0x0000000000000002L,0x6000000000000000L});</span>
<span class="nc" id="L13913">	public static final BitSet FOLLOW_shiftExpression_in_relationalExpression3779 = new BitSet(new long[]{0x0030000000000002L,0x0000000000030000L});</span>
<span class="nc" id="L13914">	public static final BitSet FOLLOW_relationalOperator_in_relationalExpression3792 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13915">	public static final BitSet FOLLOW_shiftExpression_in_relationalExpression3796 = new BitSet(new long[]{0x0030000000000002L,0x0000000000030000L});</span>
<span class="nc" id="L13916">	public static final BitSet FOLLOW_relationalExpression_in_equalityExpression3864 = new BitSet(new long[]{0x0000008000000002L,0x0000000020000000L});</span>
<span class="nc" id="L13917">	public static final BitSet FOLLOW_equalityOperator_in_equalityExpression3877 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13918">	public static final BitSet FOLLOW_relationalExpression_in_equalityExpression3881 = new BitSet(new long[]{0x0000008000000002L,0x0000000020000000L});</span>
<span class="nc" id="L13919">	public static final BitSet FOLLOW_equalityExpression_in_andExpression3940 = new BitSet(new long[]{0x0000000000000022L});</span>
<span class="nc" id="L13920">	public static final BitSet FOLLOW_AMPERSAND_in_andExpression3953 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13921">	public static final BitSet FOLLOW_equalityExpression_in_andExpression3957 = new BitSet(new long[]{0x0000000000000022L});</span>
<span class="nc" id="L13922">	public static final BitSet FOLLOW_andExpression_in_exclusiveOrExpression4000 = new BitSet(new long[]{0x0000000000008002L});</span>
<span class="nc" id="L13923">	public static final BitSet FOLLOW_BITXOR_in_exclusiveOrExpression4013 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13924">	public static final BitSet FOLLOW_andExpression_in_exclusiveOrExpression4017 = new BitSet(new long[]{0x0000000000008002L});</span>
<span class="nc" id="L13925">	public static final BitSet FOLLOW_exclusiveOrExpression_in_inclusiveOrExpression4061 = new BitSet(new long[]{0x0000000000001002L});</span>
<span class="nc" id="L13926">	public static final BitSet FOLLOW_BAR_in_inclusiveOrExpression4074 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13927">	public static final BitSet FOLLOW_exclusiveOrExpression_in_inclusiveOrExpression4078 = new BitSet(new long[]{0x0000000000001002L});</span>
<span class="nc" id="L13928">	public static final BitSet FOLLOW_inclusiveOrExpression_in_logicalAndExpression4122 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L});</span>
<span class="nc" id="L13929">	public static final BitSet FOLLOW_LAND_in_logicalAndExpression4135 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13930">	public static final BitSet FOLLOW_inclusiveOrExpression_in_logicalAndExpression4139 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000080L});</span>
<span class="nc" id="L13931">	public static final BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression4183 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});</span>
<span class="nc" id="L13932">	public static final BitSet FOLLOW_LOR_in_logicalOrExpression4196 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13933">	public static final BitSet FOLLOW_logicalAndExpression_in_logicalOrExpression4200 = new BitSet(new long[]{0x0000000000000002L,0x0000000000002000L});</span>
<span class="nc" id="L13934">	public static final BitSet FOLLOW_logicalOrExpression_in_logicalImpliesExpression4245 = new BitSet(new long[]{0x8000000000000002L});</span>
<span class="nc" id="L13935">	public static final BitSet FOLLOW_IMPLY_in_logicalImpliesExpression4258 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13936">	public static final BitSet FOLLOW_logicalOrExpression_in_logicalImpliesExpression4262 = new BitSet(new long[]{0x8000000000000002L});</span>
<span class="nc" id="L13937">	public static final BitSet FOLLOW_logicalImpliesExpression_in_conditionalExpression4308 = new BitSet(new long[]{0x0000000000000002L,0x0000400000000000L});</span>
<span class="nc" id="L13938">	public static final BitSet FOLLOW_QUESTION_in_conditionalExpression4324 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13939">	public static final BitSet FOLLOW_term_in_conditionalExpression4326 = new BitSet(new long[]{0x0000000000400000L});</span>
<span class="nc" id="L13940">	public static final BitSet FOLLOW_COLON_in_conditionalExpression4328 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13941">	public static final BitSet FOLLOW_conditionalExpression_in_conditionalExpression4330 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13942">	public static final BitSet FOLLOW_quantifier_in_quantifierExpression4429 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L13943">	public static final BitSet FOLLOW_binders_in_quantifierExpression4431 = new BitSet(new long[]{0x0000000000000000L,0x1000000000000000L});</span>
<span class="nc" id="L13944">	public static final BitSet FOLLOW_SEMICOL_in_quantifierExpression4433 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13945">	public static final BitSet FOLLOW_assignmentExpression_in_quantifierExpression4435 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13946">	public static final BitSet FOLLOW_unaryExpression_in_assignmentExpression4507 = new BitSet(new long[]{0x0000000000000100L});</span>
<span class="nc" id="L13947">	public static final BitSet FOLLOW_ASSIGN_in_assignmentExpression4509 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13948">	public static final BitSet FOLLOW_assignmentExpression_in_assignmentExpression4511 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13949">	public static final BitSet FOLLOW_conditionalExpression_in_assignmentExpression4543 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13950">	public static final BitSet FOLLOW_quantifierExpression_in_assignmentExpression4548 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13951">	public static final BitSet FOLLOW_assignmentExpression_in_term4561 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13952">	public static final BitSet FOLLOW_conditionalExpression_in_constantExpression4580 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13953">	public static final BitSet FOLLOW_INTEGER_CONSTANT_in_constant4592 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13954">	public static final BitSet FOLLOW_FLOATING_CONSTANT_in_constant4597 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13955">	public static final BitSet FOLLOW_CHARACTER_CONSTANT_in_constant4602 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13956">	public static final BitSet FOLLOW_TRUE_in_constant4607 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13957">	public static final BitSet FOLLOW_FALSE_in_constant4611 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13958">	public static final BitSet FOLLOW_RESULT_in_constant4615 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13959">	public static final BitSet FOLLOW_NOTHING_in_constant4619 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13960">	public static final BitSet FOLLOW_ELLIPSIS_in_constant4623 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13961">	public static final BitSet FOLLOW_SELF_in_constant4631 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13962">	public static final BitSet FOLLOW_NULL_in_constant4635 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13963">	public static final BitSet FOLLOW_mpi_constant_in_constant4643 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13964">	public static final BitSet FOLLOW_MPI_EMPTY_IN_in_mpi_expression4667 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13965">	public static final BitSet FOLLOW_LPAREN_in_mpi_expression4669 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13966">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4671 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13967">	public static final BitSet FOLLOW_RPAREN_in_mpi_expression4673 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13968">	public static final BitSet FOLLOW_MPI_EMPTY_OUT_in_mpi_expression4695 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13969">	public static final BitSet FOLLOW_LPAREN_in_mpi_expression4697 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13970">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4699 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13971">	public static final BitSet FOLLOW_RPAREN_in_mpi_expression4701 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13972">	public static final BitSet FOLLOW_MPI_AGREE_in_mpi_expression4723 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13973">	public static final BitSet FOLLOW_LPAREN_in_mpi_expression4725 = new BitSet(new long[]{0x4000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13974">	public static final BitSet FOLLOW_variable_ident_base_in_mpi_expression4729 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13975">	public static final BitSet FOLLOW_RPAREN_in_mpi_expression4731 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13976">	public static final BitSet FOLLOW_MPI_REGION_in_mpi_expression4757 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13977">	public static final BitSet FOLLOW_LPAREN_in_mpi_expression4759 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13978">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4763 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13979">	public static final BitSet FOLLOW_COMMA_in_mpi_expression4765 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13980">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4769 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13981">	public static final BitSet FOLLOW_COMMA_in_mpi_expression4771 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13982">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4775 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13983">	public static final BitSet FOLLOW_RPAREN_in_mpi_expression4777 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13984">	public static final BitSet FOLLOW_MPI_EQUALS_in_mpi_expression4806 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L13985">	public static final BitSet FOLLOW_LPAREN_in_mpi_expression4808 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13986">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4812 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13987">	public static final BitSet FOLLOW_COMMA_in_mpi_expression4814 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13988">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4818 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13989">	public static final BitSet FOLLOW_COMMA_in_mpi_expression4820 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13990">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4824 = new BitSet(new long[]{0x0000000000800000L});</span>
<span class="nc" id="L13991">	public static final BitSet FOLLOW_COMMA_in_mpi_expression4826 = new BitSet(new long[]{0x4000501000000000L,0x08A000061FA04204L,0x0000000001000024L});</span>
<span class="nc" id="L13992">	public static final BitSet FOLLOW_primaryExpression_in_mpi_expression4830 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L13993">	public static final BitSet FOLLOW_RPAREN_in_mpi_expression4832 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13994">	public static final BitSet FOLLOW_function_contract_in_synpred1_AcslParser391 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13995">	public static final BitSet FOLLOW_LOOP_in_synpred10_AcslParser816 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000400L});</span>
<span class="nc" id="L13996">	public static final BitSet FOLLOW_VARIANT_in_synpred10_AcslParser818 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L13997">	public static final BitSet FOLLOW_term_in_synpred10_AcslParser820 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13998">	public static final BitSet FOLLOW_named_behavior_block_in_synpred16_AcslParser1044 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L13999">	public static final BitSet FOLLOW_completeness_clause_block_in_synpred17_AcslParser1060 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14000">	public static final BitSet FOLLOW_completeness_clause_block_in_synpred19_AcslParser1119 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14001">	public static final BitSet FOLLOW_variable_ident_base_in_synpred40_AcslParser1594 = new BitSet(new long[]{0x0000000000000000L,0x0000000000008000L});</span>
<span class="nc" id="L14002">	public static final BitSet FOLLOW_LSQUARE_in_synpred40_AcslParser1596 = new BitSet(new long[]{0x0000000000000000L,0x0200000000000000L});</span>
<span class="nc" id="L14003">	public static final BitSet FOLLOW_RSQUARE_in_synpred40_AcslParser1598 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14004">	public static final BitSet FOLLOW_event_base_in_synpred50_AcslParser1981 = new BitSet(new long[]{0x0000000000000000L,0x0000080000000000L});</span>
<span class="nc" id="L14005">	public static final BitSet FOLLOW_PLUS_in_synpred50_AcslParser1983 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L14006">	public static final BitSet FOLLOW_event_base_in_synpred50_AcslParser1985 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14007">	public static final BitSet FOLLOW_event_base_in_synpred51_AcslParser2011 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000008L});</span>
<span class="nc" id="L14008">	public static final BitSet FOLLOW_SUB_in_synpred51_AcslParser2013 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L14009">	public static final BitSet FOLLOW_event_base_in_synpred51_AcslParser2015 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14010">	public static final BitSet FOLLOW_event_base_in_synpred52_AcslParser2041 = new BitSet(new long[]{0x0000000000000020L});</span>
<span class="nc" id="L14011">	public static final BitSet FOLLOW_AMPERSAND_in_synpred52_AcslParser2043 = new BitSet(new long[]{0x0000000000080040L,0x0006000080004000L,0x0000000000002000L});</span>
<span class="nc" id="L14012">	public static final BitSet FOLLOW_event_base_in_synpred52_AcslParser2045 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14013">	public static final BitSet FOLLOW_LCURLY_in_synpred70_AcslParser2608 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14014">	public static final BitSet FOLLOW_term_in_synpred70_AcslParser2610 = new BitSet(new long[]{0x0000000000001000L});</span>
<span class="nc" id="L14015">	public static final BitSet FOLLOW_BAR_in_synpred70_AcslParser2612 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L14016">	public static final BitSet FOLLOW_binders_in_synpred70_AcslParser2614 = new BitSet(new long[]{0x0000000000000000L,0x1001000000000000L});</span>
<span class="nc" id="L14017">	public static final BitSet FOLLOW_SEMICOL_in_synpred70_AcslParser2617 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14018">	public static final BitSet FOLLOW_term_in_synpred70_AcslParser2619 = new BitSet(new long[]{0x0000000000000000L,0x0001000000000000L});</span>
<span class="nc" id="L14019">	public static final BitSet FOLLOW_RCURLY_in_synpred70_AcslParser2623 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14020">	public static final BitSet FOLLOW_LCURLY_in_synpred71_AcslParser2651 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14021">	public static final BitSet FOLLOW_term_in_synpred71_AcslParser2653 = new BitSet(new long[]{0x0000000000000000L,0x0001000000000000L});</span>
<span class="nc" id="L14022">	public static final BitSet FOLLOW_RCURLY_in_synpred71_AcslParser2655 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14023">	public static final BitSet FOLLOW_COMMA_in_synpred79_AcslParser2965 = new BitSet(new long[]{0x4001521001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14024">	public static final BitSet FOLLOW_assignmentExpression_in_synpred79_AcslParser2967 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14025">	public static final BitSet FOLLOW_SIZEOF_in_synpred82_AcslParser3024 = new BitSet(new long[]{0x0000000000000000L,0x0000000000004000L});</span>
<span class="nc" id="L14026">	public static final BitSet FOLLOW_LPAREN_in_synpred82_AcslParser3026 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L14027">	public static final BitSet FOLLOW_type_expr_in_synpred82_AcslParser3028 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14028">	public static final BitSet FOLLOW_SIZEOF_in_synpred83_AcslParser3054 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14029">	public static final BitSet FOLLOW_unaryExpression_in_synpred83_AcslParser3056 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14030">	public static final BitSet FOLLOW_LPAREN_in_synpred86_AcslParser3203 = new BitSet(new long[]{0x4000200100110000L,0x8010000000000803L,0x0000000000000800L});</span>
<span class="nc" id="L14031">	public static final BitSet FOLLOW_type_expr_in_synpred86_AcslParser3205 = new BitSet(new long[]{0x0000000000000000L,0x0100000000000000L});</span>
<span class="nc" id="L14032">	public static final BitSet FOLLOW_RPAREN_in_synpred86_AcslParser3207 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14033">	public static final BitSet FOLLOW_HASH_in_synpred87_AcslParser3258 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14034">	public static final BitSet FOLLOW_castExpression_in_synpred87_AcslParser3262 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14035">	public static final BitSet FOLLOW_BAR_in_synpred105_AcslParser4074 = new BitSet(new long[]{0x4000501001000020L,0x08A008071FA0420CL,0x0010000001000267L});</span>
<span class="nc" id="L14036">	public static final BitSet FOLLOW_exclusiveOrExpression_in_synpred105_AcslParser4078 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14037">	public static final BitSet FOLLOW_unaryExpression_in_synpred111_AcslParser4498 = new BitSet(new long[]{0x0000000000000100L});</span>
<span class="nc" id="L14038">	public static final BitSet FOLLOW_ASSIGN_in_synpred111_AcslParser4500 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L14039">	public static final BitSet FOLLOW_conditionalExpression_in_synpred112_AcslParser4543 = new BitSet(new long[]{0x0000000000000002L});</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>