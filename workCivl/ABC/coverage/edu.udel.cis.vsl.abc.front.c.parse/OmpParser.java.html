<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OmpParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test Coverage Report for ABC ${revision}</a> &gt; <a href="index.source.html" class="el_package">edu.udel.cis.vsl.abc.front.c.parse</a> &gt; <span class="el_source">OmpParser.java</span></div><h1>OmpParser.java</h1><pre class="source lang-java linenums">package edu.udel.cis.vsl.abc.front.c.parse;
import edu.udel.cis.vsl.abc.front.IF.RuntimeParseException;
import edu.udel.cis.vsl.abc.front.c.preproc.*;

// $ANTLR 3.5.2 OmpParser.g 2016-04-11 02:06:30

import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

import org.antlr.runtime.tree.*;


@SuppressWarnings(&quot;all&quot;)
public class OmpParser extends Parser {
<span class="nc" id="L17">	public static final String[] tokenNames = new String[] {</span>
		&quot;&lt;invalid&gt;&quot;, &quot;&lt;EOR&gt;&quot;, &quot;&lt;DOWN&gt;&quot;, &quot;&lt;UP&gt;&quot;, &quot;ABSTRACT&quot;, &quot;ALIGNAS&quot;, &quot;ALIGNOF&quot;, 
		&quot;AMPERSAND&quot;, &quot;AND&quot;, &quot;ARROW&quot;, &quot;ASSIGN&quot;, &quot;ASSIGNS&quot;, &quot;AT&quot;, &quot;ATOMIC&quot;, &quot;AUTO&quot;, 
		&quot;BIG_O&quot;, &quot;BITANDEQ&quot;, &quot;BITOR&quot;, &quot;BITOREQ&quot;, &quot;BITXOR&quot;, &quot;BITXOREQ&quot;, &quot;BOOL&quot;, 
		&quot;BREAK&quot;, &quot;BinaryExponentPart&quot;, &quot;CALLS&quot;, &quot;CASE&quot;, &quot;CChar&quot;, &quot;CHAR&quot;, &quot;CHARACTER_CONSTANT&quot;, 
		&quot;CHOOSE&quot;, &quot;CIVLATOM&quot;, &quot;CIVLATOMIC&quot;, &quot;CIVLFOR&quot;, &quot;COLLECTIVE&quot;, &quot;COLON&quot;, 
		&quot;COMMA&quot;, &quot;COMMENT&quot;, &quot;COMPLEX&quot;, &quot;CONST&quot;, &quot;CONTIN&quot;, &quot;CONTINUE&quot;, &quot;DEFAULT&quot;, 
		&quot;DEFINED&quot;, &quot;DEPENDS&quot;, &quot;DERIV&quot;, &quot;DEVICE&quot;, &quot;DIV&quot;, &quot;DIVEQ&quot;, &quot;DO&quot;, &quot;DOMAIN&quot;, 
		&quot;DOT&quot;, &quot;DOTDOT&quot;, &quot;DOUBLE&quot;, &quot;DecimalConstant&quot;, &quot;DecimalFloatingConstant&quot;, 
		&quot;Digit&quot;, &quot;ELLIPSIS&quot;, &quot;ELSE&quot;, &quot;ENSURES&quot;, &quot;ENUM&quot;, &quot;EQUALS&quot;, &quot;EXISTS&quot;, &quot;EXTERN&quot;, 
		&quot;EscapeSequence&quot;, &quot;ExponentPart&quot;, &quot;FALSE&quot;, &quot;FATOMIC&quot;, &quot;FLOAT&quot;, &quot;FLOATING_CONSTANT&quot;, 
		&quot;FOR&quot;, &quot;FORALL&quot;, &quot;FloatingSuffix&quot;, &quot;FractionalConstant&quot;, &quot;GENERIC&quot;, &quot;GLOBAL&quot;, 
		&quot;GOTO&quot;, &quot;GT&quot;, &quot;GTE&quot;, &quot;GUARD&quot;, &quot;HASH&quot;, &quot;HASHHASH&quot;, &quot;HEADER_NAME&quot;, &quot;HERE&quot;, 
		&quot;HexEscape&quot;, &quot;HexFractionalConstant&quot;, &quot;HexPrefix&quot;, &quot;HexQuad&quot;, &quot;HexadecimalConstant&quot;, 
		&quot;HexadecimalDigit&quot;, &quot;HexadecimalFloatingConstant&quot;, &quot;IDENTIFIER&quot;, &quot;IF&quot;, 
		&quot;IMAGINARY&quot;, &quot;IMPLIES&quot;, &quot;INLINE&quot;, &quot;INPUT&quot;, &quot;INT&quot;, &quot;INTEGER_CONSTANT&quot;, 
		&quot;INVARIANT&quot;, &quot;IdentifierNonDigit&quot;, &quot;IntegerSuffix&quot;, &quot;LCURLY&quot;, &quot;LEXCON&quot;, 
		&quot;LONG&quot;, &quot;LPAREN&quot;, &quot;LSLIST&quot;, &quot;LSQUARE&quot;, &quot;LT&quot;, &quot;LTE&quot;, &quot;LongLongSuffix&quot;, 
		&quot;LongSuffix&quot;, &quot;MINUSMINUS&quot;, &quot;MOD&quot;, &quot;MODEQ&quot;, &quot;NEQ&quot;, &quot;NEWLINE&quot;, &quot;NORETURN&quot;, 
		&quot;NOT&quot;, &quot;NewLine&quot;, &quot;NonDigit&quot;, &quot;NonZeroDigit&quot;, &quot;NotLineStart&quot;, &quot;OR&quot;, &quot;OTHER&quot;, 
		&quot;OUTPUT&quot;, &quot;OctalConstant&quot;, &quot;OctalDigit&quot;, &quot;OctalEscape&quot;, &quot;PARFOR&quot;, &quot;PDEFINE&quot;, 
		&quot;PELIF&quot;, &quot;PELSE&quot;, &quot;PENDIF&quot;, &quot;PERROR&quot;, &quot;PIF&quot;, &quot;PIFDEF&quot;, &quot;PIFNDEF&quot;, &quot;PINCLUDE&quot;, 
		&quot;PLINE&quot;, &quot;PLUS&quot;, &quot;PLUSEQ&quot;, &quot;PLUSPLUS&quot;, &quot;PP_NUMBER&quot;, &quot;PRAGMA&quot;, &quot;PROCNULL&quot;, 
		&quot;PUNDEF&quot;, &quot;PURE&quot;, &quot;QMARK&quot;, &quot;RANGE&quot;, &quot;RCURLY&quot;, &quot;READS&quot;, &quot;REAL&quot;, &quot;REGISTER&quot;, 
		&quot;REQUIRES&quot;, &quot;RESTRICT&quot;, &quot;RESULT&quot;, &quot;RETURN&quot;, &quot;REXCON&quot;, &quot;RPAREN&quot;, &quot;RSLIST&quot;, 
		&quot;RSQUARE&quot;, &quot;SCOPEOF&quot;, &quot;SChar&quot;, &quot;SELF&quot;, &quot;SEMI&quot;, &quot;SHARED&quot;, &quot;SHIFTLEFT&quot;, 
		&quot;SHIFTLEFTEQ&quot;, &quot;SHIFTRIGHT&quot;, &quot;SHIFTRIGHTEQ&quot;, &quot;SHORT&quot;, &quot;SIGNED&quot;, &quot;SIZEOF&quot;, 
		&quot;SPAWN&quot;, &quot;STAR&quot;, &quot;STAREQ&quot;, &quot;STATIC&quot;, &quot;STATICASSERT&quot;, &quot;STRING_LITERAL&quot;, 
		&quot;STRUCT&quot;, &quot;SUB&quot;, &quot;SUBEQ&quot;, &quot;SWITCH&quot;, &quot;SYSTEM&quot;, &quot;THREADLOCAL&quot;, &quot;TILDE&quot;, 
		&quot;TRUE&quot;, &quot;TYPEDEF&quot;, &quot;TYPEOF&quot;, &quot;UNIFORM&quot;, &quot;UNION&quot;, &quot;UNSIGNED&quot;, &quot;UniversalCharacterName&quot;, 
		&quot;UnsignedSuffix&quot;, &quot;VOID&quot;, &quot;VOLATILE&quot;, &quot;WHEN&quot;, &quot;WHILE&quot;, &quot;WS&quot;, &quot;Zero&quot;, &quot;BODY&quot;, 
		&quot;EXPR&quot;, &quot;FILE&quot;, &quot;PARAMLIST&quot;, &quot;ROOT&quot;, &quot;SEQUENCE&quot;, &quot;TEXT_BLOCK&quot;, &quot;ABSENT&quot;, 
		&quot;ABSTRACT_DECLARATOR&quot;, &quot;ARGUMENT_LIST&quot;, &quot;ARRAY_ELEMENT_DESIGNATOR&quot;, &quot;ARRAY_SUFFIX&quot;, 
		&quot;BLOCK_ITEM_LIST&quot;, &quot;CALL&quot;, &quot;CASE_LABELED_STATEMENT&quot;, &quot;CAST&quot;, &quot;COMPOUND_LITERAL&quot;, 
		&quot;COMPOUND_STATEMENT&quot;, &quot;CONTRACT&quot;, &quot;DECLARATION&quot;, &quot;DECLARATION_LIST&quot;, &quot;DECLARATION_SPECIFIERS&quot;, 
		&quot;DECLARATOR&quot;, &quot;DEFAULT_LABELED_STATEMENT&quot;, &quot;DERIVATIVE_EXPRESSION&quot;, &quot;DESIGNATED_INITIALIZER&quot;, 
		&quot;DESIGNATION&quot;, &quot;DIRECT_ABSTRACT_DECLARATOR&quot;, &quot;DIRECT_DECLARATOR&quot;, &quot;ENUMERATION_CONSTANT&quot;, 
		&quot;ENUMERATOR&quot;, &quot;ENUMERATOR_LIST&quot;, &quot;EXPRESSION_STATEMENT&quot;, &quot;FIELD_DESIGNATOR&quot;, 
		&quot;FUNCTION_DEFINITION&quot;, &quot;FUNCTION_SUFFIX&quot;, &quot;GENERIC_ASSOCIATION&quot;, &quot;GENERIC_ASSOC_LIST&quot;, 
		&quot;IDENTIFIER_LABELED_STATEMENT&quot;, &quot;IDENTIFIER_LIST&quot;, &quot;INDEX&quot;, &quot;INITIALIZER_LIST&quot;, 
		&quot;INIT_DECLARATOR&quot;, &quot;INIT_DECLARATOR_LIST&quot;, &quot;OPERATOR&quot;, &quot;PARAMETER_DECLARATION&quot;, 
		&quot;PARAMETER_LIST&quot;, &quot;PARAMETER_TYPE_LIST&quot;, &quot;PARENTHESIZED_EXPRESSION&quot;, &quot;PARTIAL&quot;, 
		&quot;PARTIAL_LIST&quot;, &quot;POINTER&quot;, &quot;POST_DECREMENT&quot;, &quot;POST_INCREMENT&quot;, &quot;PRE_DECREMENT&quot;, 
		&quot;PRE_INCREMENT&quot;, &quot;PROGRAM&quot;, &quot;SCALAR_INITIALIZER&quot;, &quot;SPECIFIER_QUALIFIER_LIST&quot;, 
		&quot;STATEMENT&quot;, &quot;STATEMENT_EXPRESSION&quot;, &quot;STRUCT_DECLARATION&quot;, &quot;STRUCT_DECLARATION_LIST&quot;, 
		&quot;STRUCT_DECLARATOR&quot;, &quot;STRUCT_DECLARATOR_LIST&quot;, &quot;TOKEN_LIST&quot;, &quot;TRANSLATION_UNIT&quot;, 
		&quot;TYPE&quot;, &quot;TYPEDEF_NAME&quot;, &quot;TYPEOF_EXPRESSION&quot;, &quot;TYPEOF_TYPE&quot;, &quot;TYPE_NAME&quot;, 
		&quot;TYPE_QUALIFIER_LIST&quot;, &quot;BARRIER&quot;, &quot;CAPTURE&quot;, &quot;COLLAPSE&quot;, &quot;COPYIN&quot;, &quot;COPYPRIVATE&quot;, 
		&quot;CRITICAL&quot;, &quot;DYNAMIC&quot;, &quot;FLUSH&quot;, &quot;FST_PRIVATE&quot;, &quot;GUIDED&quot;, &quot;LST_PRIVATE&quot;, 
		&quot;MASTER&quot;, &quot;NONE&quot;, &quot;NOWAIT&quot;, &quot;NUM_THREADS&quot;, &quot;OMPATOMIC&quot;, &quot;ORDERED&quot;, &quot;PARALLEL&quot;, 
		&quot;PRIVATE&quot;, &quot;READ&quot;, &quot;REDUCTION&quot;, &quot;RUNTIME&quot;, &quot;SCHEDULE&quot;, &quot;SECTION&quot;, &quot;SECTIONS&quot;, 
		&quot;SEQ_CST&quot;, &quot;SINGLE&quot;, &quot;THD_PRIVATE&quot;, &quot;UPDATE&quot;, &quot;WRITE&quot;, &quot;DATA_CLAUSE&quot;, 
		&quot;FOR_CLAUSE&quot;, &quot;PARALLEL_FOR&quot;, &quot;PARALLEL_SECTIONS&quot;, &quot;UNIQUE_FOR&quot;, &quot;UNIQUE_PARALLEL&quot;, 
		&quot;516&quot;, &quot;517&quot;, &quot;518&quot;, &quot;519&quot;, &quot;520&quot;
	};
	public static final int EOF=-1;
	public static final int ABSTRACT=4;
	public static final int ALIGNAS=5;
	public static final int ALIGNOF=6;
	public static final int AMPERSAND=7;
	public static final int AND=8;
	public static final int ARROW=9;
	public static final int ASSIGN=10;
	public static final int ASSIGNS=11;
	public static final int AT=12;
	public static final int ATOMIC=13;
	public static final int AUTO=14;
	public static final int BIG_O=15;
	public static final int BITANDEQ=16;
	public static final int BITOR=17;
	public static final int BITOREQ=18;
	public static final int BITXOR=19;
	public static final int BITXOREQ=20;
	public static final int BOOL=21;
	public static final int BREAK=22;
	public static final int BinaryExponentPart=23;
	public static final int CALLS=24;
	public static final int CASE=25;
	public static final int CChar=26;
	public static final int CHAR=27;
	public static final int CHARACTER_CONSTANT=28;
	public static final int CHOOSE=29;
	public static final int CIVLATOM=30;
	public static final int CIVLATOMIC=31;
	public static final int CIVLFOR=32;
	public static final int COLLECTIVE=33;
	public static final int COLON=34;
	public static final int COMMA=35;
	public static final int COMMENT=36;
	public static final int COMPLEX=37;
	public static final int CONST=38;
	public static final int CONTIN=39;
	public static final int CONTINUE=40;
	public static final int DEFAULT=41;
	public static final int DEFINED=42;
	public static final int DEPENDS=43;
	public static final int DERIV=44;
	public static final int DEVICE=45;
	public static final int DIV=46;
	public static final int DIVEQ=47;
	public static final int DO=48;
	public static final int DOMAIN=49;
	public static final int DOT=50;
	public static final int DOTDOT=51;
	public static final int DOUBLE=52;
	public static final int DecimalConstant=53;
	public static final int DecimalFloatingConstant=54;
	public static final int Digit=55;
	public static final int ELLIPSIS=56;
	public static final int ELSE=57;
	public static final int ENSURES=58;
	public static final int ENUM=59;
	public static final int EQUALS=60;
	public static final int EXISTS=61;
	public static final int EXTERN=62;
	public static final int EscapeSequence=63;
	public static final int ExponentPart=64;
	public static final int FALSE=65;
	public static final int FATOMIC=66;
	public static final int FLOAT=67;
	public static final int FLOATING_CONSTANT=68;
	public static final int FOR=69;
	public static final int FORALL=70;
	public static final int FloatingSuffix=71;
	public static final int FractionalConstant=72;
	public static final int GENERIC=73;
	public static final int GLOBAL=74;
	public static final int GOTO=75;
	public static final int GT=76;
	public static final int GTE=77;
	public static final int GUARD=78;
	public static final int HASH=79;
	public static final int HASHHASH=80;
	public static final int HEADER_NAME=81;
	public static final int HERE=82;
	public static final int HexEscape=83;
	public static final int HexFractionalConstant=84;
	public static final int HexPrefix=85;
	public static final int HexQuad=86;
	public static final int HexadecimalConstant=87;
	public static final int HexadecimalDigit=88;
	public static final int HexadecimalFloatingConstant=89;
	public static final int IDENTIFIER=90;
	public static final int IF=91;
	public static final int IMAGINARY=92;
	public static final int IMPLIES=93;
	public static final int INLINE=94;
	public static final int INPUT=95;
	public static final int INT=96;
	public static final int INTEGER_CONSTANT=97;
	public static final int INVARIANT=98;
	public static final int IdentifierNonDigit=99;
	public static final int IntegerSuffix=100;
	public static final int LCURLY=101;
	public static final int LEXCON=102;
	public static final int LONG=103;
	public static final int LPAREN=104;
	public static final int LSLIST=105;
	public static final int LSQUARE=106;
	public static final int LT=107;
	public static final int LTE=108;
	public static final int LongLongSuffix=109;
	public static final int LongSuffix=110;
	public static final int MINUSMINUS=111;
	public static final int MOD=112;
	public static final int MODEQ=113;
	public static final int NEQ=114;
	public static final int NEWLINE=115;
	public static final int NORETURN=116;
	public static final int NOT=117;
	public static final int NewLine=118;
	public static final int NonDigit=119;
	public static final int NonZeroDigit=120;
	public static final int NotLineStart=121;
	public static final int OR=122;
	public static final int OTHER=123;
	public static final int OUTPUT=124;
	public static final int OctalConstant=125;
	public static final int OctalDigit=126;
	public static final int OctalEscape=127;
	public static final int PARFOR=128;
	public static final int PDEFINE=129;
	public static final int PELIF=130;
	public static final int PELSE=131;
	public static final int PENDIF=132;
	public static final int PERROR=133;
	public static final int PIF=134;
	public static final int PIFDEF=135;
	public static final int PIFNDEF=136;
	public static final int PINCLUDE=137;
	public static final int PLINE=138;
	public static final int PLUS=139;
	public static final int PLUSEQ=140;
	public static final int PLUSPLUS=141;
	public static final int PP_NUMBER=142;
	public static final int PRAGMA=143;
	public static final int PROCNULL=144;
	public static final int PUNDEF=145;
	public static final int PURE=146;
	public static final int QMARK=147;
	public static final int RANGE=148;
	public static final int RCURLY=149;
	public static final int READS=150;
	public static final int REAL=151;
	public static final int REGISTER=152;
	public static final int REQUIRES=153;
	public static final int RESTRICT=154;
	public static final int RESULT=155;
	public static final int RETURN=156;
	public static final int REXCON=157;
	public static final int RPAREN=158;
	public static final int RSLIST=159;
	public static final int RSQUARE=160;
	public static final int SCOPEOF=161;
	public static final int SChar=162;
	public static final int SELF=163;
	public static final int SEMI=164;
	public static final int SHARED=165;
	public static final int SHIFTLEFT=166;
	public static final int SHIFTLEFTEQ=167;
	public static final int SHIFTRIGHT=168;
	public static final int SHIFTRIGHTEQ=169;
	public static final int SHORT=170;
	public static final int SIGNED=171;
	public static final int SIZEOF=172;
	public static final int SPAWN=173;
	public static final int STAR=174;
	public static final int STAREQ=175;
	public static final int STATIC=176;
	public static final int STATICASSERT=177;
	public static final int STRING_LITERAL=178;
	public static final int STRUCT=179;
	public static final int SUB=180;
	public static final int SUBEQ=181;
	public static final int SWITCH=182;
	public static final int SYSTEM=183;
	public static final int THREADLOCAL=184;
	public static final int TILDE=185;
	public static final int TRUE=186;
	public static final int TYPEDEF=187;
	public static final int TYPEOF=188;
	public static final int UNIFORM=189;
	public static final int UNION=190;
	public static final int UNSIGNED=191;
	public static final int UniversalCharacterName=192;
	public static final int UnsignedSuffix=193;
	public static final int VOID=194;
	public static final int VOLATILE=195;
	public static final int WHEN=196;
	public static final int WHILE=197;
	public static final int WS=198;
	public static final int Zero=199;
	public static final int BODY=200;
	public static final int EXPR=201;
	public static final int FILE=202;
	public static final int PARAMLIST=203;
	public static final int ROOT=204;
	public static final int SEQUENCE=205;
	public static final int TEXT_BLOCK=206;
	public static final int ABSENT=207;
	public static final int ABSTRACT_DECLARATOR=208;
	public static final int ARGUMENT_LIST=209;
	public static final int ARRAY_ELEMENT_DESIGNATOR=210;
	public static final int ARRAY_SUFFIX=211;
	public static final int BLOCK_ITEM_LIST=212;
	public static final int CALL=213;
	public static final int CASE_LABELED_STATEMENT=214;
	public static final int CAST=215;
	public static final int COMPOUND_LITERAL=216;
	public static final int COMPOUND_STATEMENT=217;
	public static final int CONTRACT=218;
	public static final int DECLARATION=219;
	public static final int DECLARATION_LIST=220;
	public static final int DECLARATION_SPECIFIERS=221;
	public static final int DECLARATOR=222;
	public static final int DEFAULT_LABELED_STATEMENT=223;
	public static final int DERIVATIVE_EXPRESSION=224;
	public static final int DESIGNATED_INITIALIZER=225;
	public static final int DESIGNATION=226;
	public static final int DIRECT_ABSTRACT_DECLARATOR=227;
	public static final int DIRECT_DECLARATOR=228;
	public static final int ENUMERATION_CONSTANT=229;
	public static final int ENUMERATOR=230;
	public static final int ENUMERATOR_LIST=231;
	public static final int EXPRESSION_STATEMENT=232;
	public static final int FIELD_DESIGNATOR=233;
	public static final int FUNCTION_DEFINITION=234;
	public static final int FUNCTION_SUFFIX=235;
	public static final int GENERIC_ASSOCIATION=236;
	public static final int GENERIC_ASSOC_LIST=237;
	public static final int IDENTIFIER_LABELED_STATEMENT=238;
	public static final int IDENTIFIER_LIST=239;
	public static final int INDEX=240;
	public static final int INITIALIZER_LIST=241;
	public static final int INIT_DECLARATOR=242;
	public static final int INIT_DECLARATOR_LIST=243;
	public static final int OPERATOR=244;
	public static final int PARAMETER_DECLARATION=245;
	public static final int PARAMETER_LIST=246;
	public static final int PARAMETER_TYPE_LIST=247;
	public static final int PARENTHESIZED_EXPRESSION=248;
	public static final int PARTIAL=249;
	public static final int PARTIAL_LIST=250;
	public static final int POINTER=251;
	public static final int POST_DECREMENT=252;
	public static final int POST_INCREMENT=253;
	public static final int PRE_DECREMENT=254;
	public static final int PRE_INCREMENT=255;
	public static final int PROGRAM=256;
	public static final int SCALAR_INITIALIZER=257;
	public static final int SPECIFIER_QUALIFIER_LIST=258;
	public static final int STATEMENT=259;
	public static final int STATEMENT_EXPRESSION=260;
	public static final int STRUCT_DECLARATION=261;
	public static final int STRUCT_DECLARATION_LIST=262;
	public static final int STRUCT_DECLARATOR=263;
	public static final int STRUCT_DECLARATOR_LIST=264;
	public static final int TOKEN_LIST=265;
	public static final int TRANSLATION_UNIT=266;
	public static final int TYPE=267;
	public static final int TYPEDEF_NAME=268;
	public static final int TYPEOF_EXPRESSION=269;
	public static final int TYPEOF_TYPE=270;
	public static final int TYPE_NAME=271;
	public static final int TYPE_QUALIFIER_LIST=272;
	public static final int BARRIER=273;
	public static final int CAPTURE=274;
	public static final int COLLAPSE=275;
	public static final int COPYIN=276;
	public static final int COPYPRIVATE=277;
	public static final int CRITICAL=278;
	public static final int DYNAMIC=279;
	public static final int FLUSH=280;
	public static final int FST_PRIVATE=281;
	public static final int GUIDED=282;
	public static final int LST_PRIVATE=283;
	public static final int MASTER=284;
	public static final int NONE=285;
	public static final int NOWAIT=286;
	public static final int NUM_THREADS=287;
	public static final int OMPATOMIC=288;
	public static final int ORDERED=289;
	public static final int PARALLEL=290;
	public static final int PRIVATE=291;
	public static final int READ=292;
	public static final int REDUCTION=293;
	public static final int RUNTIME=294;
	public static final int SCHEDULE=295;
	public static final int SECTION=296;
	public static final int SECTIONS=297;
	public static final int SEQ_CST=298;
	public static final int SINGLE=299;
	public static final int THD_PRIVATE=300;
	public static final int UPDATE=301;
	public static final int WRITE=302;
	public static final int DATA_CLAUSE=349;
	public static final int FOR_CLAUSE=390;
	public static final int PARALLEL_FOR=434;
	public static final int PARALLEL_SECTIONS=435;
	public static final int UNIQUE_FOR=514;
	public static final int UNIQUE_PARALLEL=515;

	// delegates
	public OmpParser_CivlCParser gCivlCParser;
	public Parser[] getDelegates() {
<span class="nc" id="L382">		return new Parser[] {gCivlCParser};</span>
	}

	// delegators


	public OmpParser(TokenStream input) {
<span class="nc" id="L389">		this(input, new RecognizerSharedState());</span>
<span class="nc" id="L390">	}</span>
	public OmpParser(TokenStream input, RecognizerSharedState state) {
<span class="nc" id="L392">		super(input, state);</span>
<span class="nc" id="L393">		gCivlCParser = new OmpParser_CivlCParser(input, state, this);</span>
<span class="nc" id="L394">	}</span>

<span class="nc" id="L396">	protected TreeAdaptor adaptor = new CommonTreeAdaptor();</span>

	public void setTreeAdaptor(TreeAdaptor adaptor) {
<span class="nc" id="L399">		this.adaptor = adaptor;</span>
<span class="nc" id="L400">		gCivlCParser.setTreeAdaptor(this.adaptor);</span>
<span class="nc" id="L401">	}</span>
	public TreeAdaptor getTreeAdaptor() {
<span class="nc" id="L403">		return adaptor;</span>
	}
<span class="nc" id="L405">	@Override public String[] getTokenNames() { return OmpParser.tokenNames; }</span>
<span class="nc" id="L406">	@Override public String getGrammarFileName() { return &quot;OmpParser.g&quot;; }</span>


		@Override
		public void displayRecognitionError(String[] tokenNames, RecognitionException e) {
<span class="nc" id="L411">			String hdr = getErrorHeader(e);</span>
<span class="nc" id="L412">			String msg = getErrorMessage(e, tokenNames);</span>
			
<span class="nc" id="L414">			throw new RuntimeParseException(hdr+&quot; &quot;+msg, e.token);</span>
		}

		@Override
		public void emitErrorMessage(String msg) { // don't try to recover!
<span class="nc" id="L419">		    throw new RuntimeParseException(msg);</span>
		}


<span class="nc" id="L423">	public static class openmp_construct_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L426">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;openmp_construct&quot;
	// OmpParser.g:49:1: openmp_construct : ( parallel_for_directive | parallel_sections_directive | parallel_directive | for_directive | sections_directive | single_directive | master_directive | critical_directive | ordered_directive | section_directive | ompatomic_directive | barrier_directive | flush_directive | threadprivate_directive );
	public final OmpParser.openmp_construct_return openmp_construct() throws RecognitionException {
<span class="nc" id="L433">		OmpParser.openmp_construct_return retval = new OmpParser.openmp_construct_return();</span>
<span class="nc" id="L434">		retval.start = input.LT(1);</span>

<span class="nc" id="L436">		Object root_0 = null;</span>

<span class="nc" id="L438">		ParserRuleReturnScope parallel_for_directive1 =null;</span>
<span class="nc" id="L439">		ParserRuleReturnScope parallel_sections_directive2 =null;</span>
<span class="nc" id="L440">		ParserRuleReturnScope parallel_directive3 =null;</span>
<span class="nc" id="L441">		ParserRuleReturnScope for_directive4 =null;</span>
<span class="nc" id="L442">		ParserRuleReturnScope sections_directive5 =null;</span>
<span class="nc" id="L443">		ParserRuleReturnScope single_directive6 =null;</span>
<span class="nc" id="L444">		ParserRuleReturnScope master_directive7 =null;</span>
<span class="nc" id="L445">		ParserRuleReturnScope critical_directive8 =null;</span>
<span class="nc" id="L446">		ParserRuleReturnScope ordered_directive9 =null;</span>
<span class="nc" id="L447">		ParserRuleReturnScope section_directive10 =null;</span>
<span class="nc" id="L448">		ParserRuleReturnScope ompatomic_directive11 =null;</span>
<span class="nc" id="L449">		ParserRuleReturnScope barrier_directive12 =null;</span>
<span class="nc" id="L450">		ParserRuleReturnScope flush_directive13 =null;</span>
<span class="nc" id="L451">		ParserRuleReturnScope threadprivate_directive14 =null;</span>


		try {
			// OmpParser.g:50:3: ( parallel_for_directive | parallel_sections_directive | parallel_directive | for_directive | sections_directive | single_directive | master_directive | critical_directive | ordered_directive | section_directive | ompatomic_directive | barrier_directive | flush_directive | threadprivate_directive )
<span class="nc" id="L456">			int alt1=14;</span>
<span class="nc bnc" id="L457" title="All 13 branches missed.">			switch ( input.LA(1) ) {</span>
			case PARALLEL:
				{
<span class="nc bnc" id="L460" title="All 4 branches missed.">				switch ( input.LA(2) ) {</span>
				case FOR:
					{
<span class="nc" id="L463">					alt1=1;</span>
					}
<span class="nc" id="L465">					break;</span>
				case SECTIONS:
					{
<span class="nc" id="L468">					alt1=2;</span>
					}
<span class="nc" id="L470">					break;</span>
				case EOF:
				case DEFAULT:
				case IF:
				case SHARED:
				case COPYIN:
				case COPYPRIVATE:
				case FST_PRIVATE:
				case LST_PRIVATE:
				case NUM_THREADS:
				case PRIVATE:
				case REDUCTION:
					{
<span class="nc" id="L483">					alt1=3;</span>
					}
<span class="nc" id="L485">					break;</span>
				default:
<span class="nc" id="L487">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L489">						input.consume();</span>
<span class="nc" id="L490">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 1, 1, input);
<span class="nc" id="L492">						throw nvae;</span>
					} finally {
<span class="nc" id="L494">						input.rewind(nvaeMark);</span>
					}
				}
				}
<span class="nc" id="L498">				break;</span>
			case FOR:
				{
<span class="nc" id="L501">				alt1=4;</span>
				}
<span class="nc" id="L503">				break;</span>
			case SECTIONS:
				{
<span class="nc" id="L506">				alt1=5;</span>
				}
<span class="nc" id="L508">				break;</span>
			case SINGLE:
				{
<span class="nc" id="L511">				alt1=6;</span>
				}
<span class="nc" id="L513">				break;</span>
			case MASTER:
				{
<span class="nc" id="L516">				alt1=7;</span>
				}
<span class="nc" id="L518">				break;</span>
			case CRITICAL:
				{
<span class="nc" id="L521">				alt1=8;</span>
				}
<span class="nc" id="L523">				break;</span>
			case ORDERED:
				{
<span class="nc" id="L526">				alt1=9;</span>
				}
<span class="nc" id="L528">				break;</span>
			case SECTION:
				{
<span class="nc" id="L531">				alt1=10;</span>
				}
<span class="nc" id="L533">				break;</span>
			case OMPATOMIC:
				{
<span class="nc" id="L536">				alt1=11;</span>
				}
<span class="nc" id="L538">				break;</span>
			case BARRIER:
				{
<span class="nc" id="L541">				alt1=12;</span>
				}
<span class="nc" id="L543">				break;</span>
			case FLUSH:
				{
<span class="nc" id="L546">				alt1=13;</span>
				}
<span class="nc" id="L548">				break;</span>
			case THD_PRIVATE:
				{
<span class="nc" id="L551">				alt1=14;</span>
				}
<span class="nc" id="L553">				break;</span>
			default:
<span class="nc" id="L555">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 1, 0, input);
<span class="nc" id="L557">				throw nvae;</span>
			}
<span class="nc bnc" id="L559" title="All 15 branches missed.">			switch (alt1) {</span>
				case 1 :
					// OmpParser.g:51:5: parallel_for_directive
					{
<span class="nc" id="L563">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L566">					pushFollow(FOLLOW_parallel_for_directive_in_openmp_construct96);</span>
<span class="nc" id="L567">					parallel_for_directive1=parallel_for_directive();</span>
<span class="nc" id="L568">					state._fsp--;</span>

<span class="nc" id="L570">					adaptor.addChild(root_0, parallel_for_directive1.getTree());</span>

					}
<span class="nc" id="L573">					break;</span>
				case 2 :
					// OmpParser.g:52:5: parallel_sections_directive
					{
<span class="nc" id="L577">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L580">					pushFollow(FOLLOW_parallel_sections_directive_in_openmp_construct102);</span>
<span class="nc" id="L581">					parallel_sections_directive2=parallel_sections_directive();</span>
<span class="nc" id="L582">					state._fsp--;</span>

<span class="nc" id="L584">					adaptor.addChild(root_0, parallel_sections_directive2.getTree());</span>

					}
<span class="nc" id="L587">					break;</span>
				case 3 :
					// OmpParser.g:53:5: parallel_directive
					{
<span class="nc" id="L591">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L594">					pushFollow(FOLLOW_parallel_directive_in_openmp_construct108);</span>
<span class="nc" id="L595">					parallel_directive3=parallel_directive();</span>
<span class="nc" id="L596">					state._fsp--;</span>

<span class="nc" id="L598">					adaptor.addChild(root_0, parallel_directive3.getTree());</span>

					}
<span class="nc" id="L601">					break;</span>
				case 4 :
					// OmpParser.g:54:5: for_directive
					{
<span class="nc" id="L605">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L608">					pushFollow(FOLLOW_for_directive_in_openmp_construct114);</span>
<span class="nc" id="L609">					for_directive4=for_directive();</span>
<span class="nc" id="L610">					state._fsp--;</span>

<span class="nc" id="L612">					adaptor.addChild(root_0, for_directive4.getTree());</span>

					}
<span class="nc" id="L615">					break;</span>
				case 5 :
					// OmpParser.g:55:5: sections_directive
					{
<span class="nc" id="L619">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L622">					pushFollow(FOLLOW_sections_directive_in_openmp_construct120);</span>
<span class="nc" id="L623">					sections_directive5=sections_directive();</span>
<span class="nc" id="L624">					state._fsp--;</span>

<span class="nc" id="L626">					adaptor.addChild(root_0, sections_directive5.getTree());</span>

					}
<span class="nc" id="L629">					break;</span>
				case 6 :
					// OmpParser.g:56:5: single_directive
					{
<span class="nc" id="L633">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L636">					pushFollow(FOLLOW_single_directive_in_openmp_construct126);</span>
<span class="nc" id="L637">					single_directive6=single_directive();</span>
<span class="nc" id="L638">					state._fsp--;</span>

<span class="nc" id="L640">					adaptor.addChild(root_0, single_directive6.getTree());</span>

					}
<span class="nc" id="L643">					break;</span>
				case 7 :
					// OmpParser.g:57:5: master_directive
					{
<span class="nc" id="L647">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L650">					pushFollow(FOLLOW_master_directive_in_openmp_construct132);</span>
<span class="nc" id="L651">					master_directive7=master_directive();</span>
<span class="nc" id="L652">					state._fsp--;</span>

<span class="nc" id="L654">					adaptor.addChild(root_0, master_directive7.getTree());</span>

					}
<span class="nc" id="L657">					break;</span>
				case 8 :
					// OmpParser.g:58:5: critical_directive
					{
<span class="nc" id="L661">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L664">					pushFollow(FOLLOW_critical_directive_in_openmp_construct138);</span>
<span class="nc" id="L665">					critical_directive8=critical_directive();</span>
<span class="nc" id="L666">					state._fsp--;</span>

<span class="nc" id="L668">					adaptor.addChild(root_0, critical_directive8.getTree());</span>

					}
<span class="nc" id="L671">					break;</span>
				case 9 :
					// OmpParser.g:59:5: ordered_directive
					{
<span class="nc" id="L675">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L678">					pushFollow(FOLLOW_ordered_directive_in_openmp_construct144);</span>
<span class="nc" id="L679">					ordered_directive9=ordered_directive();</span>
<span class="nc" id="L680">					state._fsp--;</span>

<span class="nc" id="L682">					adaptor.addChild(root_0, ordered_directive9.getTree());</span>

					}
<span class="nc" id="L685">					break;</span>
				case 10 :
					// OmpParser.g:60:5: section_directive
					{
<span class="nc" id="L689">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L692">					pushFollow(FOLLOW_section_directive_in_openmp_construct150);</span>
<span class="nc" id="L693">					section_directive10=section_directive();</span>
<span class="nc" id="L694">					state._fsp--;</span>

<span class="nc" id="L696">					adaptor.addChild(root_0, section_directive10.getTree());</span>

					}
<span class="nc" id="L699">					break;</span>
				case 11 :
					// OmpParser.g:61:5: ompatomic_directive
					{
<span class="nc" id="L703">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L706">					pushFollow(FOLLOW_ompatomic_directive_in_openmp_construct156);</span>
<span class="nc" id="L707">					ompatomic_directive11=ompatomic_directive();</span>
<span class="nc" id="L708">					state._fsp--;</span>

<span class="nc" id="L710">					adaptor.addChild(root_0, ompatomic_directive11.getTree());</span>

					}
<span class="nc" id="L713">					break;</span>
				case 12 :
					// OmpParser.g:62:5: barrier_directive
					{
<span class="nc" id="L717">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L720">					pushFollow(FOLLOW_barrier_directive_in_openmp_construct162);</span>
<span class="nc" id="L721">					barrier_directive12=barrier_directive();</span>
<span class="nc" id="L722">					state._fsp--;</span>

<span class="nc" id="L724">					adaptor.addChild(root_0, barrier_directive12.getTree());</span>

					}
<span class="nc" id="L727">					break;</span>
				case 13 :
					// OmpParser.g:63:5: flush_directive
					{
<span class="nc" id="L731">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L734">					pushFollow(FOLLOW_flush_directive_in_openmp_construct168);</span>
<span class="nc" id="L735">					flush_directive13=flush_directive();</span>
<span class="nc" id="L736">					state._fsp--;</span>

<span class="nc" id="L738">					adaptor.addChild(root_0, flush_directive13.getTree());</span>

					}
<span class="nc" id="L741">					break;</span>
				case 14 :
					// OmpParser.g:64:5: threadprivate_directive
					{
<span class="nc" id="L745">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L748">					pushFollow(FOLLOW_threadprivate_directive_in_openmp_construct174);</span>
<span class="nc" id="L749">					threadprivate_directive14=threadprivate_directive();</span>
<span class="nc" id="L750">					state._fsp--;</span>

<span class="nc" id="L752">					adaptor.addChild(root_0, threadprivate_directive14.getTree());</span>

					}
					break;

			}
<span class="nc" id="L758">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L760">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L761">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L764">		catch (RecognitionException re) {</span>
<span class="nc" id="L765">			reportError(re);</span>
<span class="nc" id="L766">			recover(input,re);</span>
<span class="nc" id="L767">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L769">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L771">		}</span>
<span class="nc" id="L772">		return retval;</span>
	}
	// $ANTLR end &quot;openmp_construct&quot;


<span class="nc" id="L777">	public static class parallel_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L780">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_directive&quot;
	// OmpParser.g:67:1: parallel_directive : PARALLEL (p+= parallel_clause )* -&gt; ^( PARALLEL ( $p)* ) ;
	public final OmpParser.parallel_directive_return parallel_directive() throws RecognitionException {
<span class="nc" id="L787">		OmpParser.parallel_directive_return retval = new OmpParser.parallel_directive_return();</span>
<span class="nc" id="L788">		retval.start = input.LT(1);</span>

<span class="nc" id="L790">		Object root_0 = null;</span>

<span class="nc" id="L792">		Token PARALLEL15=null;</span>
<span class="nc" id="L793">		List&lt;Object&gt; list_p=null;</span>
<span class="nc" id="L794">		RuleReturnScope p = null;</span>
<span class="nc" id="L795">		Object PARALLEL15_tree=null;</span>
<span class="nc" id="L796">		RewriteRuleTokenStream stream_PARALLEL=new RewriteRuleTokenStream(adaptor,&quot;token PARALLEL&quot;);</span>
<span class="nc" id="L797">		RewriteRuleSubtreeStream stream_parallel_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule parallel_clause&quot;);</span>

		try {
			// OmpParser.g:68:3: ( PARALLEL (p+= parallel_clause )* -&gt; ^( PARALLEL ( $p)* ) )
			// OmpParser.g:68:5: PARALLEL (p+= parallel_clause )*
			{
<span class="nc" id="L803">			PARALLEL15=(Token)match(input,PARALLEL,FOLLOW_PARALLEL_in_parallel_directive187);  </span>
<span class="nc" id="L804">			stream_PARALLEL.add(PARALLEL15);</span>

			// OmpParser.g:68:15: (p+= parallel_clause )*
			loop2:
			while (true) {
<span class="nc" id="L809">				int alt2=2;</span>
<span class="nc" id="L810">				int LA2_0 = input.LA(1);</span>
<span class="nc bnc" id="L811" title="All 20 branches missed.">				if ( (LA2_0==DEFAULT||LA2_0==IF||LA2_0==SHARED||(LA2_0 &gt;= COPYIN &amp;&amp; LA2_0 &lt;= COPYPRIVATE)||LA2_0==FST_PRIVATE||LA2_0==LST_PRIVATE||LA2_0==NUM_THREADS||LA2_0==PRIVATE||LA2_0==REDUCTION) ) {</span>
<span class="nc" id="L812">					alt2=1;</span>
				}

<span class="nc bnc" id="L815" title="All 2 branches missed.">				switch (alt2) {</span>
				case 1 :
					// OmpParser.g:68:16: p+= parallel_clause
					{
<span class="nc" id="L819">					pushFollow(FOLLOW_parallel_clause_in_parallel_directive193);</span>
<span class="nc" id="L820">					p=parallel_clause();</span>
<span class="nc" id="L821">					state._fsp--;</span>

<span class="nc" id="L823">					stream_parallel_clause.add(p.getTree());</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">					if (list_p==null) list_p=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L825">					list_p.add(p.getTree());</span>
					}
<span class="nc" id="L827">					break;</span>

				default :
<span class="nc" id="L830">					break loop2;</span>
				}
<span class="nc" id="L832">			}</span>

			// AST REWRITE
			// elements: PARALLEL, p
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
<span class="nc" id="L841">			retval.tree = root_0;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L843">			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,&quot;token p&quot;,list_p);</span>
<span class="nc" id="L844">			root_0 = (Object)adaptor.nil();</span>
			// 69:3: -&gt; ^( PARALLEL ( $p)* )
			{
				// OmpParser.g:69:6: ^( PARALLEL ( $p)* )
				{
<span class="nc" id="L849">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L850">				root_1 = (Object)adaptor.becomeRoot(stream_PARALLEL.nextNode(), root_1);</span>
				// OmpParser.g:69:18: ( $p)*
<span class="nc bnc" id="L852" title="All 2 branches missed.">				while ( stream_p.hasNext() ) {</span>
<span class="nc" id="L853">					adaptor.addChild(root_1, stream_p.nextTree());</span>
				}
<span class="nc" id="L855">				stream_p.reset();</span>

<span class="nc" id="L857">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L863">			retval.tree = root_0;</span>

			}

<span class="nc" id="L867">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L869">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L870">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L873">		catch (RecognitionException re) {</span>
<span class="nc" id="L874">			reportError(re);</span>
<span class="nc" id="L875">			recover(input,re);</span>
<span class="nc" id="L876">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L878">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L880">		}</span>
<span class="nc" id="L881">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_directive&quot;


<span class="nc" id="L886">	public static class parallel_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L889">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_clause&quot;
	// OmpParser.g:72:1: parallel_clause : ( unique_parallel_clause | data_clause );
	public final OmpParser.parallel_clause_return parallel_clause() throws RecognitionException {
<span class="nc" id="L896">		OmpParser.parallel_clause_return retval = new OmpParser.parallel_clause_return();</span>
<span class="nc" id="L897">		retval.start = input.LT(1);</span>

<span class="nc" id="L899">		Object root_0 = null;</span>

<span class="nc" id="L901">		ParserRuleReturnScope unique_parallel_clause16 =null;</span>
<span class="nc" id="L902">		ParserRuleReturnScope data_clause17 =null;</span>


		try {
			// OmpParser.g:73:3: ( unique_parallel_clause | data_clause )
<span class="nc" id="L907">			int alt3=2;</span>
<span class="nc" id="L908">			int LA3_0 = input.LA(1);</span>
<span class="nc bnc" id="L909" title="All 4 branches missed.">			if ( (LA3_0==IF||LA3_0==NUM_THREADS) ) {</span>
<span class="nc" id="L910">				alt3=1;</span>
			}
<span class="nc bnc" id="L912" title="All 16 branches missed.">			else if ( (LA3_0==DEFAULT||LA3_0==SHARED||(LA3_0 &gt;= COPYIN &amp;&amp; LA3_0 &lt;= COPYPRIVATE)||LA3_0==FST_PRIVATE||LA3_0==LST_PRIVATE||LA3_0==PRIVATE||LA3_0==REDUCTION) ) {</span>
<span class="nc" id="L913">				alt3=2;</span>
			}

			else {
<span class="nc" id="L917">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 3, 0, input);
<span class="nc" id="L919">				throw nvae;</span>
			}

<span class="nc bnc" id="L922" title="All 3 branches missed.">			switch (alt3) {</span>
				case 1 :
					// OmpParser.g:73:5: unique_parallel_clause
					{
<span class="nc" id="L926">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L929">					pushFollow(FOLLOW_unique_parallel_clause_in_parallel_clause220);</span>
<span class="nc" id="L930">					unique_parallel_clause16=unique_parallel_clause();</span>
<span class="nc" id="L931">					state._fsp--;</span>

<span class="nc" id="L933">					adaptor.addChild(root_0, unique_parallel_clause16.getTree());</span>

					}
<span class="nc" id="L936">					break;</span>
				case 2 :
					// OmpParser.g:74:5: data_clause
					{
<span class="nc" id="L940">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L943">					pushFollow(FOLLOW_data_clause_in_parallel_clause226);</span>
<span class="nc" id="L944">					data_clause17=data_clause();</span>
<span class="nc" id="L945">					state._fsp--;</span>

<span class="nc" id="L947">					adaptor.addChild(root_0, data_clause17.getTree());</span>

					}
					break;

			}
<span class="nc" id="L953">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L955">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L956">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L959">		catch (RecognitionException re) {</span>
<span class="nc" id="L960">			reportError(re);</span>
<span class="nc" id="L961">			recover(input,re);</span>
<span class="nc" id="L962">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L964">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L966">		}</span>
<span class="nc" id="L967">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_clause&quot;


<span class="nc" id="L972">	public static class master_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L975">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;master_directive&quot;
	// OmpParser.g:77:1: master_directive : MASTER -&gt; ^( MASTER ) ;
	public final OmpParser.master_directive_return master_directive() throws RecognitionException {
<span class="nc" id="L982">		OmpParser.master_directive_return retval = new OmpParser.master_directive_return();</span>
<span class="nc" id="L983">		retval.start = input.LT(1);</span>

<span class="nc" id="L985">		Object root_0 = null;</span>

<span class="nc" id="L987">		Token MASTER18=null;</span>

<span class="nc" id="L989">		Object MASTER18_tree=null;</span>
<span class="nc" id="L990">		RewriteRuleTokenStream stream_MASTER=new RewriteRuleTokenStream(adaptor,&quot;token MASTER&quot;);</span>

		try {
			// OmpParser.g:78:3: ( MASTER -&gt; ^( MASTER ) )
			// OmpParser.g:78:5: MASTER
			{
<span class="nc" id="L996">			MASTER18=(Token)match(input,MASTER,FOLLOW_MASTER_in_master_directive241);  </span>
<span class="nc" id="L997">			stream_MASTER.add(MASTER18);</span>

			// AST REWRITE
			// elements: MASTER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L1006">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1009">			root_0 = (Object)adaptor.nil();</span>
			// 78:12: -&gt; ^( MASTER )
			{
				// OmpParser.g:78:15: ^( MASTER )
				{
<span class="nc" id="L1014">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1015">				root_1 = (Object)adaptor.becomeRoot(stream_MASTER.nextNode(), root_1);</span>
<span class="nc" id="L1016">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1022">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1026">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1028">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1029">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1032">		catch (RecognitionException re) {</span>
<span class="nc" id="L1033">			reportError(re);</span>
<span class="nc" id="L1034">			recover(input,re);</span>
<span class="nc" id="L1035">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1037">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1039">		}</span>
<span class="nc" id="L1040">		return retval;</span>
	}
	// $ANTLR end &quot;master_directive&quot;


<span class="nc" id="L1045">	public static class critical_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1048">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;critical_directive&quot;
	// OmpParser.g:81:1: critical_directive : CRITICAL ( LPAREN id= IDENTIFIER RPAREN )? -&gt; ^( CRITICAL ( $id)? ) ;
	public final OmpParser.critical_directive_return critical_directive() throws RecognitionException {
<span class="nc" id="L1055">		OmpParser.critical_directive_return retval = new OmpParser.critical_directive_return();</span>
<span class="nc" id="L1056">		retval.start = input.LT(1);</span>

<span class="nc" id="L1058">		Object root_0 = null;</span>

<span class="nc" id="L1060">		Token id=null;</span>
<span class="nc" id="L1061">		Token CRITICAL19=null;</span>
<span class="nc" id="L1062">		Token LPAREN20=null;</span>
<span class="nc" id="L1063">		Token RPAREN21=null;</span>

<span class="nc" id="L1065">		Object id_tree=null;</span>
<span class="nc" id="L1066">		Object CRITICAL19_tree=null;</span>
<span class="nc" id="L1067">		Object LPAREN20_tree=null;</span>
<span class="nc" id="L1068">		Object RPAREN21_tree=null;</span>
<span class="nc" id="L1069">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L1070">		RewriteRuleTokenStream stream_CRITICAL=new RewriteRuleTokenStream(adaptor,&quot;token CRITICAL&quot;);</span>
<span class="nc" id="L1071">		RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,&quot;token IDENTIFIER&quot;);</span>
<span class="nc" id="L1072">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>

		try {
			// OmpParser.g:82:3: ( CRITICAL ( LPAREN id= IDENTIFIER RPAREN )? -&gt; ^( CRITICAL ( $id)? ) )
			// OmpParser.g:82:5: CRITICAL ( LPAREN id= IDENTIFIER RPAREN )?
			{
<span class="nc" id="L1078">			CRITICAL19=(Token)match(input,CRITICAL,FOLLOW_CRITICAL_in_critical_directive260);  </span>
<span class="nc" id="L1079">			stream_CRITICAL.add(CRITICAL19);</span>

			// OmpParser.g:82:15: ( LPAREN id= IDENTIFIER RPAREN )?
<span class="nc" id="L1082">			int alt4=2;</span>
<span class="nc" id="L1083">			int LA4_0 = input.LA(1);</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">			if ( (LA4_0==LPAREN) ) {</span>
<span class="nc" id="L1085">				alt4=1;</span>
			}
<span class="nc bnc" id="L1087" title="All 2 branches missed.">			switch (alt4) {</span>
				case 1 :
					// OmpParser.g:82:16: LPAREN id= IDENTIFIER RPAREN
					{
<span class="nc" id="L1091">					LPAREN20=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_critical_directive264);  </span>
<span class="nc" id="L1092">					stream_LPAREN.add(LPAREN20);</span>

<span class="nc" id="L1094">					id=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_critical_directive269);  </span>
<span class="nc" id="L1095">					stream_IDENTIFIER.add(id);</span>

<span class="nc" id="L1097">					RPAREN21=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_critical_directive272);  </span>
<span class="nc" id="L1098">					stream_RPAREN.add(RPAREN21);</span>

					}
					break;

			}

			// AST REWRITE
			// elements: id, CRITICAL
			// token labels: id
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L1112">			retval.tree = root_0;</span>
<span class="nc" id="L1113">			RewriteRuleTokenStream stream_id=new RewriteRuleTokenStream(adaptor,&quot;token id&quot;,id);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1116">			root_0 = (Object)adaptor.nil();</span>
			// 83:3: -&gt; ^( CRITICAL ( $id)? )
			{
				// OmpParser.g:83:6: ^( CRITICAL ( $id)? )
				{
<span class="nc" id="L1121">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1122">				root_1 = (Object)adaptor.becomeRoot(stream_CRITICAL.nextNode(), root_1);</span>
				// OmpParser.g:83:18: ( $id)?
<span class="nc bnc" id="L1124" title="All 2 branches missed.">				if ( stream_id.hasNext() ) {</span>
<span class="nc" id="L1125">					adaptor.addChild(root_1, stream_id.nextNode());</span>
				}
<span class="nc" id="L1127">				stream_id.reset();</span>

<span class="nc" id="L1129">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1135">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1139">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1141">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1142">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1145">		catch (RecognitionException re) {</span>
<span class="nc" id="L1146">			reportError(re);</span>
<span class="nc" id="L1147">			recover(input,re);</span>
<span class="nc" id="L1148">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1150">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1152">		}</span>
<span class="nc" id="L1153">		return retval;</span>
	}
	// $ANTLR end &quot;critical_directive&quot;


<span class="nc" id="L1158">	public static class sections_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1161">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;sections_directive&quot;
	// OmpParser.g:86:1: sections_directive : SECTIONS (s+= sections_clause )* -&gt; ^( SECTIONS ( $s)* ) ;
	public final OmpParser.sections_directive_return sections_directive() throws RecognitionException {
<span class="nc" id="L1168">		OmpParser.sections_directive_return retval = new OmpParser.sections_directive_return();</span>
<span class="nc" id="L1169">		retval.start = input.LT(1);</span>

<span class="nc" id="L1171">		Object root_0 = null;</span>

<span class="nc" id="L1173">		Token SECTIONS22=null;</span>
<span class="nc" id="L1174">		List&lt;Object&gt; list_s=null;</span>
<span class="nc" id="L1175">		RuleReturnScope s = null;</span>
<span class="nc" id="L1176">		Object SECTIONS22_tree=null;</span>
<span class="nc" id="L1177">		RewriteRuleTokenStream stream_SECTIONS=new RewriteRuleTokenStream(adaptor,&quot;token SECTIONS&quot;);</span>
<span class="nc" id="L1178">		RewriteRuleSubtreeStream stream_sections_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule sections_clause&quot;);</span>

		try {
			// OmpParser.g:87:3: ( SECTIONS (s+= sections_clause )* -&gt; ^( SECTIONS ( $s)* ) )
			// OmpParser.g:87:5: SECTIONS (s+= sections_clause )*
			{
<span class="nc" id="L1184">			SECTIONS22=(Token)match(input,SECTIONS,FOLLOW_SECTIONS_in_sections_directive301);  </span>
<span class="nc" id="L1185">			stream_SECTIONS.add(SECTIONS22);</span>

			// OmpParser.g:87:15: (s+= sections_clause )*
			loop5:
			while (true) {
<span class="nc" id="L1190">				int alt5=2;</span>
<span class="nc" id="L1191">				int LA5_0 = input.LA(1);</span>
<span class="nc bnc" id="L1192" title="All 18 branches missed.">				if ( (LA5_0==DEFAULT||LA5_0==SHARED||(LA5_0 &gt;= COPYIN &amp;&amp; LA5_0 &lt;= COPYPRIVATE)||LA5_0==FST_PRIVATE||LA5_0==LST_PRIVATE||LA5_0==NOWAIT||LA5_0==PRIVATE||LA5_0==REDUCTION) ) {</span>
<span class="nc" id="L1193">					alt5=1;</span>
				}

<span class="nc bnc" id="L1196" title="All 2 branches missed.">				switch (alt5) {</span>
				case 1 :
					// OmpParser.g:87:16: s+= sections_clause
					{
<span class="nc" id="L1200">					pushFollow(FOLLOW_sections_clause_in_sections_directive307);</span>
<span class="nc" id="L1201">					s=sections_clause();</span>
<span class="nc" id="L1202">					state._fsp--;</span>

<span class="nc" id="L1204">					stream_sections_clause.add(s.getTree());</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">					if (list_s==null) list_s=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1206">					list_s.add(s.getTree());</span>
					}
<span class="nc" id="L1208">					break;</span>

				default :
<span class="nc" id="L1211">					break loop5;</span>
				}
<span class="nc" id="L1213">			}</span>

			// AST REWRITE
			// elements: SECTIONS, s
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: s
			// wildcard labels: 
<span class="nc" id="L1222">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L1224">			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,&quot;token s&quot;,list_s);</span>
<span class="nc" id="L1225">			root_0 = (Object)adaptor.nil();</span>
			// 88:3: -&gt; ^( SECTIONS ( $s)* )
			{
				// OmpParser.g:88:6: ^( SECTIONS ( $s)* )
				{
<span class="nc" id="L1230">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1231">				root_1 = (Object)adaptor.becomeRoot(stream_SECTIONS.nextNode(), root_1);</span>
				// OmpParser.g:88:18: ( $s)*
<span class="nc bnc" id="L1233" title="All 2 branches missed.">				while ( stream_s.hasNext() ) {</span>
<span class="nc" id="L1234">					adaptor.addChild(root_1, stream_s.nextTree());</span>
				}
<span class="nc" id="L1236">				stream_s.reset();</span>

<span class="nc" id="L1238">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1244">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1248">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1250">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1251">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1254">		catch (RecognitionException re) {</span>
<span class="nc" id="L1255">			reportError(re);</span>
<span class="nc" id="L1256">			recover(input,re);</span>
<span class="nc" id="L1257">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1259">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1261">		}</span>
<span class="nc" id="L1262">		return retval;</span>
	}
	// $ANTLR end &quot;sections_directive&quot;


<span class="nc" id="L1267">	public static class sections_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1270">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;sections_clause&quot;
	// OmpParser.g:91:1: sections_clause : ( data_clause | nowait_directive );
	public final OmpParser.sections_clause_return sections_clause() throws RecognitionException {
<span class="nc" id="L1277">		OmpParser.sections_clause_return retval = new OmpParser.sections_clause_return();</span>
<span class="nc" id="L1278">		retval.start = input.LT(1);</span>

<span class="nc" id="L1280">		Object root_0 = null;</span>

<span class="nc" id="L1282">		ParserRuleReturnScope data_clause23 =null;</span>
<span class="nc" id="L1283">		ParserRuleReturnScope nowait_directive24 =null;</span>


		try {
			// OmpParser.g:92:3: ( data_clause | nowait_directive )
<span class="nc" id="L1288">			int alt6=2;</span>
<span class="nc" id="L1289">			int LA6_0 = input.LA(1);</span>
<span class="nc bnc" id="L1290" title="All 16 branches missed.">			if ( (LA6_0==DEFAULT||LA6_0==SHARED||(LA6_0 &gt;= COPYIN &amp;&amp; LA6_0 &lt;= COPYPRIVATE)||LA6_0==FST_PRIVATE||LA6_0==LST_PRIVATE||LA6_0==PRIVATE||LA6_0==REDUCTION) ) {</span>
<span class="nc" id="L1291">				alt6=1;</span>
			}
<span class="nc bnc" id="L1293" title="All 2 branches missed.">			else if ( (LA6_0==NOWAIT) ) {</span>
<span class="nc" id="L1294">				alt6=2;</span>
			}

			else {
<span class="nc" id="L1298">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 6, 0, input);
<span class="nc" id="L1300">				throw nvae;</span>
			}

<span class="nc bnc" id="L1303" title="All 3 branches missed.">			switch (alt6) {</span>
				case 1 :
					// OmpParser.g:92:5: data_clause
					{
<span class="nc" id="L1307">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1310">					pushFollow(FOLLOW_data_clause_in_sections_clause334);</span>
<span class="nc" id="L1311">					data_clause23=data_clause();</span>
<span class="nc" id="L1312">					state._fsp--;</span>

<span class="nc" id="L1314">					adaptor.addChild(root_0, data_clause23.getTree());</span>

					}
<span class="nc" id="L1317">					break;</span>
				case 2 :
					// OmpParser.g:93:5: nowait_directive
					{
<span class="nc" id="L1321">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1324">					pushFollow(FOLLOW_nowait_directive_in_sections_clause340);</span>
<span class="nc" id="L1325">					nowait_directive24=nowait_directive();</span>
<span class="nc" id="L1326">					state._fsp--;</span>

<span class="nc" id="L1328">					adaptor.addChild(root_0, nowait_directive24.getTree());</span>

					}
					break;

			}
<span class="nc" id="L1334">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1336">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1337">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1340">		catch (RecognitionException re) {</span>
<span class="nc" id="L1341">			reportError(re);</span>
<span class="nc" id="L1342">			recover(input,re);</span>
<span class="nc" id="L1343">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1345">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1347">		}</span>
<span class="nc" id="L1348">		return retval;</span>
	}
	// $ANTLR end &quot;sections_clause&quot;


<span class="nc" id="L1353">	public static class section_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1356">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;section_directive&quot;
	// OmpParser.g:96:1: section_directive : SECTION -&gt; ^( SECTION ) ;
	public final OmpParser.section_directive_return section_directive() throws RecognitionException {
<span class="nc" id="L1363">		OmpParser.section_directive_return retval = new OmpParser.section_directive_return();</span>
<span class="nc" id="L1364">		retval.start = input.LT(1);</span>

<span class="nc" id="L1366">		Object root_0 = null;</span>

<span class="nc" id="L1368">		Token SECTION25=null;</span>

<span class="nc" id="L1370">		Object SECTION25_tree=null;</span>
<span class="nc" id="L1371">		RewriteRuleTokenStream stream_SECTION=new RewriteRuleTokenStream(adaptor,&quot;token SECTION&quot;);</span>

		try {
			// OmpParser.g:97:3: ( SECTION -&gt; ^( SECTION ) )
			// OmpParser.g:97:5: SECTION
			{
<span class="nc" id="L1377">			SECTION25=(Token)match(input,SECTION,FOLLOW_SECTION_in_section_directive353);  </span>
<span class="nc" id="L1378">			stream_SECTION.add(SECTION25);</span>

			// AST REWRITE
			// elements: SECTION
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L1387">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L1390">			root_0 = (Object)adaptor.nil();</span>
			// 97:13: -&gt; ^( SECTION )
			{
				// OmpParser.g:97:16: ^( SECTION )
				{
<span class="nc" id="L1395">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1396">				root_1 = (Object)adaptor.becomeRoot(stream_SECTION.nextNode(), root_1);</span>
<span class="nc" id="L1397">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1403">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1407">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1409">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1410">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1413">		catch (RecognitionException re) {</span>
<span class="nc" id="L1414">			reportError(re);</span>
<span class="nc" id="L1415">			recover(input,re);</span>
<span class="nc" id="L1416">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1418">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1420">		}</span>
<span class="nc" id="L1421">		return retval;</span>
	}
	// $ANTLR end &quot;section_directive&quot;


<span class="nc" id="L1426">	public static class parallel_for_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1429">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_for_directive&quot;
	// OmpParser.g:100:1: parallel_for_directive : PARALLEL FOR (p+= parallel_for_clause )* -&gt; ^( PARALLEL_FOR ( $p)* ) ;
	public final OmpParser.parallel_for_directive_return parallel_for_directive() throws RecognitionException {
<span class="nc" id="L1436">		OmpParser.parallel_for_directive_return retval = new OmpParser.parallel_for_directive_return();</span>
<span class="nc" id="L1437">		retval.start = input.LT(1);</span>

<span class="nc" id="L1439">		Object root_0 = null;</span>

<span class="nc" id="L1441">		Token PARALLEL26=null;</span>
<span class="nc" id="L1442">		Token FOR27=null;</span>
<span class="nc" id="L1443">		List&lt;Object&gt; list_p=null;</span>
<span class="nc" id="L1444">		RuleReturnScope p = null;</span>
<span class="nc" id="L1445">		Object PARALLEL26_tree=null;</span>
<span class="nc" id="L1446">		Object FOR27_tree=null;</span>
<span class="nc" id="L1447">		RewriteRuleTokenStream stream_PARALLEL=new RewriteRuleTokenStream(adaptor,&quot;token PARALLEL&quot;);</span>
<span class="nc" id="L1448">		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,&quot;token FOR&quot;);</span>
<span class="nc" id="L1449">		RewriteRuleSubtreeStream stream_parallel_for_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule parallel_for_clause&quot;);</span>

		try {
			// OmpParser.g:101:3: ( PARALLEL FOR (p+= parallel_for_clause )* -&gt; ^( PARALLEL_FOR ( $p)* ) )
			// OmpParser.g:101:5: PARALLEL FOR (p+= parallel_for_clause )*
			{
<span class="nc" id="L1455">			PARALLEL26=(Token)match(input,PARALLEL,FOLLOW_PARALLEL_in_parallel_for_directive374);  </span>
<span class="nc" id="L1456">			stream_PARALLEL.add(PARALLEL26);</span>

<span class="nc" id="L1458">			FOR27=(Token)match(input,FOR,FOLLOW_FOR_in_parallel_for_directive376);  </span>
<span class="nc" id="L1459">			stream_FOR.add(FOR27);</span>

			// OmpParser.g:101:19: (p+= parallel_for_clause )*
			loop7:
			while (true) {
<span class="nc" id="L1464">				int alt7=2;</span>
<span class="nc" id="L1465">				int LA7_0 = input.LA(1);</span>
<span class="nc bnc" id="L1466" title="All 24 branches missed.">				if ( (LA7_0==DEFAULT||LA7_0==IF||LA7_0==SHARED||(LA7_0 &gt;= COLLAPSE &amp;&amp; LA7_0 &lt;= COPYPRIVATE)||LA7_0==FST_PRIVATE||LA7_0==LST_PRIVATE||LA7_0==NUM_THREADS||LA7_0==ORDERED||LA7_0==PRIVATE||LA7_0==REDUCTION||LA7_0==SCHEDULE) ) {</span>
<span class="nc" id="L1467">					alt7=1;</span>
				}

<span class="nc bnc" id="L1470" title="All 2 branches missed.">				switch (alt7) {</span>
				case 1 :
					// OmpParser.g:101:19: p+= parallel_for_clause
					{
<span class="nc" id="L1474">					pushFollow(FOLLOW_parallel_for_clause_in_parallel_for_directive380);</span>
<span class="nc" id="L1475">					p=parallel_for_clause();</span>
<span class="nc" id="L1476">					state._fsp--;</span>

<span class="nc" id="L1478">					stream_parallel_for_clause.add(p.getTree());</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">					if (list_p==null) list_p=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1480">					list_p.add(p.getTree());</span>
					}
<span class="nc" id="L1482">					break;</span>

				default :
<span class="nc" id="L1485">					break loop7;</span>
				}
<span class="nc" id="L1487">			}</span>

			// AST REWRITE
			// elements: p
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
<span class="nc" id="L1496">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L1498">			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,&quot;token p&quot;,list_p);</span>
<span class="nc" id="L1499">			root_0 = (Object)adaptor.nil();</span>
			// 102:5: -&gt; ^( PARALLEL_FOR ( $p)* )
			{
				// OmpParser.g:102:8: ^( PARALLEL_FOR ( $p)* )
				{
<span class="nc" id="L1504">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1505">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARALLEL_FOR, &quot;PARALLEL_FOR&quot;), root_1);</span>
				// OmpParser.g:102:24: ( $p)*
<span class="nc bnc" id="L1507" title="All 2 branches missed.">				while ( stream_p.hasNext() ) {</span>
<span class="nc" id="L1508">					adaptor.addChild(root_1, stream_p.nextTree());</span>
				}
<span class="nc" id="L1510">				stream_p.reset();</span>

<span class="nc" id="L1512">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1518">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1522">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1524">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1525">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1528">		catch (RecognitionException re) {</span>
<span class="nc" id="L1529">			reportError(re);</span>
<span class="nc" id="L1530">			recover(input,re);</span>
<span class="nc" id="L1531">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1533">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1535">		}</span>
<span class="nc" id="L1536">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_for_directive&quot;


<span class="nc" id="L1541">	public static class parallel_for_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1544">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_for_clause&quot;
	// OmpParser.g:105:1: parallel_for_clause : ( unique_parallel_clause | unique_for_clause | data_clause );
	public final OmpParser.parallel_for_clause_return parallel_for_clause() throws RecognitionException {
<span class="nc" id="L1551">		OmpParser.parallel_for_clause_return retval = new OmpParser.parallel_for_clause_return();</span>
<span class="nc" id="L1552">		retval.start = input.LT(1);</span>

<span class="nc" id="L1554">		Object root_0 = null;</span>

<span class="nc" id="L1556">		ParserRuleReturnScope unique_parallel_clause28 =null;</span>
<span class="nc" id="L1557">		ParserRuleReturnScope unique_for_clause29 =null;</span>
<span class="nc" id="L1558">		ParserRuleReturnScope data_clause30 =null;</span>


		try {
			// OmpParser.g:106:3: ( unique_parallel_clause | unique_for_clause | data_clause )
<span class="nc" id="L1563">			int alt8=3;</span>
<span class="nc bnc" id="L1564" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case IF:
			case NUM_THREADS:
				{
<span class="nc" id="L1568">				alt8=1;</span>
				}
<span class="nc" id="L1570">				break;</span>
			case COLLAPSE:
			case ORDERED:
			case SCHEDULE:
				{
<span class="nc" id="L1575">				alt8=2;</span>
				}
<span class="nc" id="L1577">				break;</span>
			case DEFAULT:
			case SHARED:
			case COPYIN:
			case COPYPRIVATE:
			case FST_PRIVATE:
			case LST_PRIVATE:
			case PRIVATE:
			case REDUCTION:
				{
<span class="nc" id="L1587">				alt8=3;</span>
				}
<span class="nc" id="L1589">				break;</span>
			default:
<span class="nc" id="L1591">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 8, 0, input);
<span class="nc" id="L1593">				throw nvae;</span>
			}
<span class="nc bnc" id="L1595" title="All 4 branches missed.">			switch (alt8) {</span>
				case 1 :
					// OmpParser.g:106:5: unique_parallel_clause
					{
<span class="nc" id="L1599">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1602">					pushFollow(FOLLOW_unique_parallel_clause_in_parallel_for_clause408);</span>
<span class="nc" id="L1603">					unique_parallel_clause28=unique_parallel_clause();</span>
<span class="nc" id="L1604">					state._fsp--;</span>

<span class="nc" id="L1606">					adaptor.addChild(root_0, unique_parallel_clause28.getTree());</span>

					}
<span class="nc" id="L1609">					break;</span>
				case 2 :
					// OmpParser.g:107:5: unique_for_clause
					{
<span class="nc" id="L1613">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1616">					pushFollow(FOLLOW_unique_for_clause_in_parallel_for_clause414);</span>
<span class="nc" id="L1617">					unique_for_clause29=unique_for_clause();</span>
<span class="nc" id="L1618">					state._fsp--;</span>

<span class="nc" id="L1620">					adaptor.addChild(root_0, unique_for_clause29.getTree());</span>

					}
<span class="nc" id="L1623">					break;</span>
				case 3 :
					// OmpParser.g:108:5: data_clause
					{
<span class="nc" id="L1627">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1630">					pushFollow(FOLLOW_data_clause_in_parallel_for_clause420);</span>
<span class="nc" id="L1631">					data_clause30=data_clause();</span>
<span class="nc" id="L1632">					state._fsp--;</span>

<span class="nc" id="L1634">					adaptor.addChild(root_0, data_clause30.getTree());</span>

					}
					break;

			}
<span class="nc" id="L1640">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1642">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1643">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1646">		catch (RecognitionException re) {</span>
<span class="nc" id="L1647">			reportError(re);</span>
<span class="nc" id="L1648">			recover(input,re);</span>
<span class="nc" id="L1649">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1651">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1653">		}</span>
<span class="nc" id="L1654">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_for_clause&quot;


<span class="nc" id="L1659">	public static class parallel_sections_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1662">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_sections_directive&quot;
	// OmpParser.g:111:1: parallel_sections_directive : PARALLEL SECTIONS (p+= parallel_sections_clause )* -&gt; ^( PARALLEL_SECTIONS ( $p)* ) ;
	public final OmpParser.parallel_sections_directive_return parallel_sections_directive() throws RecognitionException {
<span class="nc" id="L1669">		OmpParser.parallel_sections_directive_return retval = new OmpParser.parallel_sections_directive_return();</span>
<span class="nc" id="L1670">		retval.start = input.LT(1);</span>

<span class="nc" id="L1672">		Object root_0 = null;</span>

<span class="nc" id="L1674">		Token PARALLEL31=null;</span>
<span class="nc" id="L1675">		Token SECTIONS32=null;</span>
<span class="nc" id="L1676">		List&lt;Object&gt; list_p=null;</span>
<span class="nc" id="L1677">		RuleReturnScope p = null;</span>
<span class="nc" id="L1678">		Object PARALLEL31_tree=null;</span>
<span class="nc" id="L1679">		Object SECTIONS32_tree=null;</span>
<span class="nc" id="L1680">		RewriteRuleTokenStream stream_PARALLEL=new RewriteRuleTokenStream(adaptor,&quot;token PARALLEL&quot;);</span>
<span class="nc" id="L1681">		RewriteRuleTokenStream stream_SECTIONS=new RewriteRuleTokenStream(adaptor,&quot;token SECTIONS&quot;);</span>
<span class="nc" id="L1682">		RewriteRuleSubtreeStream stream_parallel_sections_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule parallel_sections_clause&quot;);</span>

		try {
			// OmpParser.g:112:3: ( PARALLEL SECTIONS (p+= parallel_sections_clause )* -&gt; ^( PARALLEL_SECTIONS ( $p)* ) )
			// OmpParser.g:112:5: PARALLEL SECTIONS (p+= parallel_sections_clause )*
			{
<span class="nc" id="L1688">			PARALLEL31=(Token)match(input,PARALLEL,FOLLOW_PARALLEL_in_parallel_sections_directive433);  </span>
<span class="nc" id="L1689">			stream_PARALLEL.add(PARALLEL31);</span>

<span class="nc" id="L1691">			SECTIONS32=(Token)match(input,SECTIONS,FOLLOW_SECTIONS_in_parallel_sections_directive436);  </span>
<span class="nc" id="L1692">			stream_SECTIONS.add(SECTIONS32);</span>

			// OmpParser.g:112:26: (p+= parallel_sections_clause )*
			loop9:
			while (true) {
<span class="nc" id="L1697">				int alt9=2;</span>
<span class="nc" id="L1698">				int LA9_0 = input.LA(1);</span>
<span class="nc bnc" id="L1699" title="All 20 branches missed.">				if ( (LA9_0==DEFAULT||LA9_0==IF||LA9_0==SHARED||(LA9_0 &gt;= COPYIN &amp;&amp; LA9_0 &lt;= COPYPRIVATE)||LA9_0==FST_PRIVATE||LA9_0==LST_PRIVATE||LA9_0==NUM_THREADS||LA9_0==PRIVATE||LA9_0==REDUCTION) ) {</span>
<span class="nc" id="L1700">					alt9=1;</span>
				}

<span class="nc bnc" id="L1703" title="All 2 branches missed.">				switch (alt9) {</span>
				case 1 :
					// OmpParser.g:112:26: p+= parallel_sections_clause
					{
<span class="nc" id="L1707">					pushFollow(FOLLOW_parallel_sections_clause_in_parallel_sections_directive441);</span>
<span class="nc" id="L1708">					p=parallel_sections_clause();</span>
<span class="nc" id="L1709">					state._fsp--;</span>

<span class="nc" id="L1711">					stream_parallel_sections_clause.add(p.getTree());</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">					if (list_p==null) list_p=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1713">					list_p.add(p.getTree());</span>
					}
<span class="nc" id="L1715">					break;</span>

				default :
<span class="nc" id="L1718">					break loop9;</span>
				}
<span class="nc" id="L1720">			}</span>

			// AST REWRITE
			// elements: p
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: p
			// wildcard labels: 
<span class="nc" id="L1729">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L1731">			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,&quot;token p&quot;,list_p);</span>
<span class="nc" id="L1732">			root_0 = (Object)adaptor.nil();</span>
			// 113:5: -&gt; ^( PARALLEL_SECTIONS ( $p)* )
			{
				// OmpParser.g:113:8: ^( PARALLEL_SECTIONS ( $p)* )
				{
<span class="nc" id="L1737">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1738">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(PARALLEL_SECTIONS, &quot;PARALLEL_SECTIONS&quot;), root_1);</span>
				// OmpParser.g:113:29: ( $p)*
<span class="nc bnc" id="L1740" title="All 2 branches missed.">				while ( stream_p.hasNext() ) {</span>
<span class="nc" id="L1741">					adaptor.addChild(root_1, stream_p.nextTree());</span>
				}
<span class="nc" id="L1743">				stream_p.reset();</span>

<span class="nc" id="L1745">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1751">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1755">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1757">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1758">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1761">		catch (RecognitionException re) {</span>
<span class="nc" id="L1762">			reportError(re);</span>
<span class="nc" id="L1763">			recover(input,re);</span>
<span class="nc" id="L1764">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1766">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1768">		}</span>
<span class="nc" id="L1769">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_sections_directive&quot;


<span class="nc" id="L1774">	public static class parallel_sections_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1777">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;parallel_sections_clause&quot;
	// OmpParser.g:116:1: parallel_sections_clause : ( unique_parallel_clause | data_clause );
	public final OmpParser.parallel_sections_clause_return parallel_sections_clause() throws RecognitionException {
<span class="nc" id="L1784">		OmpParser.parallel_sections_clause_return retval = new OmpParser.parallel_sections_clause_return();</span>
<span class="nc" id="L1785">		retval.start = input.LT(1);</span>

<span class="nc" id="L1787">		Object root_0 = null;</span>

<span class="nc" id="L1789">		ParserRuleReturnScope unique_parallel_clause33 =null;</span>
<span class="nc" id="L1790">		ParserRuleReturnScope data_clause34 =null;</span>


		try {
			// OmpParser.g:117:3: ( unique_parallel_clause | data_clause )
<span class="nc" id="L1795">			int alt10=2;</span>
<span class="nc" id="L1796">			int LA10_0 = input.LA(1);</span>
<span class="nc bnc" id="L1797" title="All 4 branches missed.">			if ( (LA10_0==IF||LA10_0==NUM_THREADS) ) {</span>
<span class="nc" id="L1798">				alt10=1;</span>
			}
<span class="nc bnc" id="L1800" title="All 16 branches missed.">			else if ( (LA10_0==DEFAULT||LA10_0==SHARED||(LA10_0 &gt;= COPYIN &amp;&amp; LA10_0 &lt;= COPYPRIVATE)||LA10_0==FST_PRIVATE||LA10_0==LST_PRIVATE||LA10_0==PRIVATE||LA10_0==REDUCTION) ) {</span>
<span class="nc" id="L1801">				alt10=2;</span>
			}

			else {
<span class="nc" id="L1805">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 10, 0, input);
<span class="nc" id="L1807">				throw nvae;</span>
			}

<span class="nc bnc" id="L1810" title="All 3 branches missed.">			switch (alt10) {</span>
				case 1 :
					// OmpParser.g:117:5: unique_parallel_clause
					{
<span class="nc" id="L1814">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1817">					pushFollow(FOLLOW_unique_parallel_clause_in_parallel_sections_clause469);</span>
<span class="nc" id="L1818">					unique_parallel_clause33=unique_parallel_clause();</span>
<span class="nc" id="L1819">					state._fsp--;</span>

<span class="nc" id="L1821">					adaptor.addChild(root_0, unique_parallel_clause33.getTree());</span>

					}
<span class="nc" id="L1824">					break;</span>
				case 2 :
					// OmpParser.g:118:5: data_clause
					{
<span class="nc" id="L1828">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L1831">					pushFollow(FOLLOW_data_clause_in_parallel_sections_clause475);</span>
<span class="nc" id="L1832">					data_clause34=data_clause();</span>
<span class="nc" id="L1833">					state._fsp--;</span>

<span class="nc" id="L1835">					adaptor.addChild(root_0, data_clause34.getTree());</span>

					}
					break;

			}
<span class="nc" id="L1841">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1843">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1844">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1847">		catch (RecognitionException re) {</span>
<span class="nc" id="L1848">			reportError(re);</span>
<span class="nc" id="L1849">			recover(input,re);</span>
<span class="nc" id="L1850">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1852">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1854">		}</span>
<span class="nc" id="L1855">		return retval;</span>
	}
	// $ANTLR end &quot;parallel_sections_clause&quot;


<span class="nc" id="L1860">	public static class single_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1863">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;single_directive&quot;
	// OmpParser.g:121:1: single_directive : SINGLE (s+= single_clause )* -&gt; ^( SINGLE ( $s)* ) ;
	public final OmpParser.single_directive_return single_directive() throws RecognitionException {
<span class="nc" id="L1870">		OmpParser.single_directive_return retval = new OmpParser.single_directive_return();</span>
<span class="nc" id="L1871">		retval.start = input.LT(1);</span>

<span class="nc" id="L1873">		Object root_0 = null;</span>

<span class="nc" id="L1875">		Token SINGLE35=null;</span>
<span class="nc" id="L1876">		List&lt;Object&gt; list_s=null;</span>
<span class="nc" id="L1877">		RuleReturnScope s = null;</span>
<span class="nc" id="L1878">		Object SINGLE35_tree=null;</span>
<span class="nc" id="L1879">		RewriteRuleTokenStream stream_SINGLE=new RewriteRuleTokenStream(adaptor,&quot;token SINGLE&quot;);</span>
<span class="nc" id="L1880">		RewriteRuleSubtreeStream stream_single_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule single_clause&quot;);</span>

		try {
			// OmpParser.g:122:3: ( SINGLE (s+= single_clause )* -&gt; ^( SINGLE ( $s)* ) )
			// OmpParser.g:122:5: SINGLE (s+= single_clause )*
			{
<span class="nc" id="L1886">			SINGLE35=(Token)match(input,SINGLE,FOLLOW_SINGLE_in_single_directive488);  </span>
<span class="nc" id="L1887">			stream_SINGLE.add(SINGLE35);</span>

			// OmpParser.g:122:14: (s+= single_clause )*
			loop11:
			while (true) {
<span class="nc" id="L1892">				int alt11=2;</span>
<span class="nc" id="L1893">				int LA11_0 = input.LA(1);</span>
<span class="nc bnc" id="L1894" title="All 18 branches missed.">				if ( (LA11_0==DEFAULT||LA11_0==SHARED||(LA11_0 &gt;= COPYIN &amp;&amp; LA11_0 &lt;= COPYPRIVATE)||LA11_0==FST_PRIVATE||LA11_0==LST_PRIVATE||LA11_0==NOWAIT||LA11_0==PRIVATE||LA11_0==REDUCTION) ) {</span>
<span class="nc" id="L1895">					alt11=1;</span>
				}

<span class="nc bnc" id="L1898" title="All 2 branches missed.">				switch (alt11) {</span>
				case 1 :
					// OmpParser.g:122:14: s+= single_clause
					{
<span class="nc" id="L1902">					pushFollow(FOLLOW_single_clause_in_single_directive493);</span>
<span class="nc" id="L1903">					s=single_clause();</span>
<span class="nc" id="L1904">					state._fsp--;</span>

<span class="nc" id="L1906">					stream_single_clause.add(s.getTree());</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">					if (list_s==null) list_s=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L1908">					list_s.add(s.getTree());</span>
					}
<span class="nc" id="L1910">					break;</span>

				default :
<span class="nc" id="L1913">					break loop11;</span>
				}
<span class="nc" id="L1915">			}</span>

			// AST REWRITE
			// elements: s, SINGLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: s
			// wildcard labels: 
<span class="nc" id="L1924">			retval.tree = root_0;</span>
<span class="nc bnc" id="L1925" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L1926">			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,&quot;token s&quot;,list_s);</span>
<span class="nc" id="L1927">			root_0 = (Object)adaptor.nil();</span>
			// 123:5: -&gt; ^( SINGLE ( $s)* )
			{
				// OmpParser.g:123:8: ^( SINGLE ( $s)* )
				{
<span class="nc" id="L1932">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L1933">				root_1 = (Object)adaptor.becomeRoot(stream_SINGLE.nextNode(), root_1);</span>
				// OmpParser.g:123:18: ( $s)*
<span class="nc bnc" id="L1935" title="All 2 branches missed.">				while ( stream_s.hasNext() ) {</span>
<span class="nc" id="L1936">					adaptor.addChild(root_1, stream_s.nextTree());</span>
				}
<span class="nc" id="L1938">				stream_s.reset();</span>

<span class="nc" id="L1940">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L1946">			retval.tree = root_0;</span>

			}

<span class="nc" id="L1950">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L1952">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L1953">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L1956">		catch (RecognitionException re) {</span>
<span class="nc" id="L1957">			reportError(re);</span>
<span class="nc" id="L1958">			recover(input,re);</span>
<span class="nc" id="L1959">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L1961">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L1963">		}</span>
<span class="nc" id="L1964">		return retval;</span>
	}
	// $ANTLR end &quot;single_directive&quot;


<span class="nc" id="L1969">	public static class single_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L1972">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;single_clause&quot;
	// OmpParser.g:126:1: single_clause : ( data_clause | nowait_directive );
	public final OmpParser.single_clause_return single_clause() throws RecognitionException {
<span class="nc" id="L1979">		OmpParser.single_clause_return retval = new OmpParser.single_clause_return();</span>
<span class="nc" id="L1980">		retval.start = input.LT(1);</span>

<span class="nc" id="L1982">		Object root_0 = null;</span>

<span class="nc" id="L1984">		ParserRuleReturnScope data_clause36 =null;</span>
<span class="nc" id="L1985">		ParserRuleReturnScope nowait_directive37 =null;</span>


		try {
			// OmpParser.g:127:3: ( data_clause | nowait_directive )
<span class="nc" id="L1990">			int alt12=2;</span>
<span class="nc" id="L1991">			int LA12_0 = input.LA(1);</span>
<span class="nc bnc" id="L1992" title="All 16 branches missed.">			if ( (LA12_0==DEFAULT||LA12_0==SHARED||(LA12_0 &gt;= COPYIN &amp;&amp; LA12_0 &lt;= COPYPRIVATE)||LA12_0==FST_PRIVATE||LA12_0==LST_PRIVATE||LA12_0==PRIVATE||LA12_0==REDUCTION) ) {</span>
<span class="nc" id="L1993">				alt12=1;</span>
			}
<span class="nc bnc" id="L1995" title="All 2 branches missed.">			else if ( (LA12_0==NOWAIT) ) {</span>
<span class="nc" id="L1996">				alt12=2;</span>
			}

			else {
<span class="nc" id="L2000">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 12, 0, input);
<span class="nc" id="L2002">				throw nvae;</span>
			}

<span class="nc bnc" id="L2005" title="All 3 branches missed.">			switch (alt12) {</span>
				case 1 :
					// OmpParser.g:127:5: data_clause
					{
<span class="nc" id="L2009">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2012">					pushFollow(FOLLOW_data_clause_in_single_clause521);</span>
<span class="nc" id="L2013">					data_clause36=data_clause();</span>
<span class="nc" id="L2014">					state._fsp--;</span>

<span class="nc" id="L2016">					adaptor.addChild(root_0, data_clause36.getTree());</span>

					}
<span class="nc" id="L2019">					break;</span>
				case 2 :
					// OmpParser.g:128:5: nowait_directive
					{
<span class="nc" id="L2023">					root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2026">					pushFollow(FOLLOW_nowait_directive_in_single_clause527);</span>
<span class="nc" id="L2027">					nowait_directive37=nowait_directive();</span>
<span class="nc" id="L2028">					state._fsp--;</span>

<span class="nc" id="L2030">					adaptor.addChild(root_0, nowait_directive37.getTree());</span>

					}
					break;

			}
<span class="nc" id="L2036">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2038">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2039">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2042">		catch (RecognitionException re) {</span>
<span class="nc" id="L2043">			reportError(re);</span>
<span class="nc" id="L2044">			recover(input,re);</span>
<span class="nc" id="L2045">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2047">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2049">		}</span>
<span class="nc" id="L2050">		return retval;</span>
	}
	// $ANTLR end &quot;single_clause&quot;


<span class="nc" id="L2055">	public static class barrier_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2058">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;barrier_directive&quot;
	// OmpParser.g:131:1: barrier_directive : BARRIER -&gt; ^( BARRIER ) ;
	public final OmpParser.barrier_directive_return barrier_directive() throws RecognitionException {
<span class="nc" id="L2065">		OmpParser.barrier_directive_return retval = new OmpParser.barrier_directive_return();</span>
<span class="nc" id="L2066">		retval.start = input.LT(1);</span>

<span class="nc" id="L2068">		Object root_0 = null;</span>

<span class="nc" id="L2070">		Token BARRIER38=null;</span>

<span class="nc" id="L2072">		Object BARRIER38_tree=null;</span>
<span class="nc" id="L2073">		RewriteRuleTokenStream stream_BARRIER=new RewriteRuleTokenStream(adaptor,&quot;token BARRIER&quot;);</span>

		try {
			// OmpParser.g:132:3: ( BARRIER -&gt; ^( BARRIER ) )
			// OmpParser.g:132:5: BARRIER
			{
<span class="nc" id="L2079">			BARRIER38=(Token)match(input,BARRIER,FOLLOW_BARRIER_in_barrier_directive540);  </span>
<span class="nc" id="L2080">			stream_BARRIER.add(BARRIER38);</span>

			// AST REWRITE
			// elements: BARRIER
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2089">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2092">			root_0 = (Object)adaptor.nil();</span>
			// 132:13: -&gt; ^( BARRIER )
			{
				// OmpParser.g:132:16: ^( BARRIER )
				{
<span class="nc" id="L2097">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2098">				root_1 = (Object)adaptor.becomeRoot(stream_BARRIER.nextNode(), root_1);</span>
<span class="nc" id="L2099">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2105">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2109">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2111">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2112">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2115">		catch (RecognitionException re) {</span>
<span class="nc" id="L2116">			reportError(re);</span>
<span class="nc" id="L2117">			recover(input,re);</span>
<span class="nc" id="L2118">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2120">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2122">		}</span>
<span class="nc" id="L2123">		return retval;</span>
	}
	// $ANTLR end &quot;barrier_directive&quot;


<span class="nc" id="L2128">	public static class ompatomic_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2131">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;ompatomic_directive&quot;
	// OmpParser.g:135:1: ompatomic_directive : OMPATOMIC (c0= atomic_clasue )? (c1= seq_cst_clause )? -&gt; ^( OMPATOMIC ( $c0)? ( $c1)? ) ;
	public final OmpParser.ompatomic_directive_return ompatomic_directive() throws RecognitionException {
<span class="nc" id="L2138">		OmpParser.ompatomic_directive_return retval = new OmpParser.ompatomic_directive_return();</span>
<span class="nc" id="L2139">		retval.start = input.LT(1);</span>

<span class="nc" id="L2141">		Object root_0 = null;</span>

<span class="nc" id="L2143">		Token OMPATOMIC39=null;</span>
<span class="nc" id="L2144">		ParserRuleReturnScope c0 =null;</span>
<span class="nc" id="L2145">		ParserRuleReturnScope c1 =null;</span>

<span class="nc" id="L2147">		Object OMPATOMIC39_tree=null;</span>
<span class="nc" id="L2148">		RewriteRuleTokenStream stream_OMPATOMIC=new RewriteRuleTokenStream(adaptor,&quot;token OMPATOMIC&quot;);</span>
<span class="nc" id="L2149">		RewriteRuleSubtreeStream stream_atomic_clasue=new RewriteRuleSubtreeStream(adaptor,&quot;rule atomic_clasue&quot;);</span>
<span class="nc" id="L2150">		RewriteRuleSubtreeStream stream_seq_cst_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule seq_cst_clause&quot;);</span>

		try {
			// OmpParser.g:136:3: ( OMPATOMIC (c0= atomic_clasue )? (c1= seq_cst_clause )? -&gt; ^( OMPATOMIC ( $c0)? ( $c1)? ) )
			// OmpParser.g:136:5: OMPATOMIC (c0= atomic_clasue )? (c1= seq_cst_clause )?
			{
<span class="nc" id="L2156">			OMPATOMIC39=(Token)match(input,OMPATOMIC,FOLLOW_OMPATOMIC_in_ompatomic_directive561);  </span>
<span class="nc" id="L2157">			stream_OMPATOMIC.add(OMPATOMIC39);</span>

			// OmpParser.g:136:17: (c0= atomic_clasue )?
<span class="nc" id="L2160">			int alt13=2;</span>
<span class="nc" id="L2161">			int LA13_0 = input.LA(1);</span>
<span class="nc bnc" id="L2162" title="All 8 branches missed.">			if ( (LA13_0==CAPTURE||LA13_0==READ||(LA13_0 &gt;= UPDATE &amp;&amp; LA13_0 &lt;= WRITE)) ) {</span>
<span class="nc" id="L2163">				alt13=1;</span>
			}
<span class="nc bnc" id="L2165" title="All 2 branches missed.">			switch (alt13) {</span>
				case 1 :
					// OmpParser.g:136:17: c0= atomic_clasue
					{
<span class="nc" id="L2169">					pushFollow(FOLLOW_atomic_clasue_in_ompatomic_directive565);</span>
<span class="nc" id="L2170">					c0=atomic_clasue();</span>
<span class="nc" id="L2171">					state._fsp--;</span>

<span class="nc" id="L2173">					stream_atomic_clasue.add(c0.getTree());</span>
					}
					break;

			}

			// OmpParser.g:136:35: (c1= seq_cst_clause )?
<span class="nc" id="L2180">			int alt14=2;</span>
<span class="nc" id="L2181">			int LA14_0 = input.LA(1);</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">			if ( (LA14_0==SEQ_CST) ) {</span>
<span class="nc" id="L2183">				alt14=1;</span>
			}
<span class="nc bnc" id="L2185" title="All 2 branches missed.">			switch (alt14) {</span>
				case 1 :
					// OmpParser.g:136:35: c1= seq_cst_clause
					{
<span class="nc" id="L2189">					pushFollow(FOLLOW_seq_cst_clause_in_ompatomic_directive570);</span>
<span class="nc" id="L2190">					c1=seq_cst_clause();</span>
<span class="nc" id="L2191">					state._fsp--;</span>

<span class="nc" id="L2193">					stream_seq_cst_clause.add(c1.getTree());</span>
					}
					break;

			}

			// AST REWRITE
			// elements: c0, c1, OMPATOMIC
			// token labels: 
			// rule labels: retval, c1, c0
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2206">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_c1=new RewriteRuleSubtreeStream(adaptor,&quot;rule c1&quot;,c1!=null?c1.getTree():null);</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_c0=new RewriteRuleSubtreeStream(adaptor,&quot;rule c0&quot;,c0!=null?c0.getTree():null);</span>

<span class="nc" id="L2211">			root_0 = (Object)adaptor.nil();</span>
			// 137:5: -&gt; ^( OMPATOMIC ( $c0)? ( $c1)? )
			{
				// OmpParser.g:137:8: ^( OMPATOMIC ( $c0)? ( $c1)? )
				{
<span class="nc" id="L2216">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2217">				root_1 = (Object)adaptor.becomeRoot(stream_OMPATOMIC.nextNode(), root_1);</span>
				// OmpParser.g:137:21: ( $c0)?
<span class="nc bnc" id="L2219" title="All 2 branches missed.">				if ( stream_c0.hasNext() ) {</span>
<span class="nc" id="L2220">					adaptor.addChild(root_1, stream_c0.nextTree());</span>
				}
<span class="nc" id="L2222">				stream_c0.reset();</span>

				// OmpParser.g:137:26: ( $c1)?
<span class="nc bnc" id="L2225" title="All 2 branches missed.">				if ( stream_c1.hasNext() ) {</span>
<span class="nc" id="L2226">					adaptor.addChild(root_1, stream_c1.nextTree());</span>
				}
<span class="nc" id="L2228">				stream_c1.reset();</span>

<span class="nc" id="L2230">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2236">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2240">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2242">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2243">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2246">		catch (RecognitionException re) {</span>
<span class="nc" id="L2247">			reportError(re);</span>
<span class="nc" id="L2248">			recover(input,re);</span>
<span class="nc" id="L2249">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2251">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2253">		}</span>
<span class="nc" id="L2254">		return retval;</span>
	}
	// $ANTLR end &quot;ompatomic_directive&quot;


<span class="nc" id="L2259">	public static class atomic_clasue_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2262">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;atomic_clasue&quot;
	// OmpParser.g:140:1: atomic_clasue : ( READ | WRITE | UPDATE | CAPTURE );
	public final OmpParser.atomic_clasue_return atomic_clasue() throws RecognitionException {
<span class="nc" id="L2269">		OmpParser.atomic_clasue_return retval = new OmpParser.atomic_clasue_return();</span>
<span class="nc" id="L2270">		retval.start = input.LT(1);</span>

<span class="nc" id="L2272">		Object root_0 = null;</span>

<span class="nc" id="L2274">		Token set40=null;</span>

<span class="nc" id="L2276">		Object set40_tree=null;</span>

		try {
			// OmpParser.g:141:2: ( READ | WRITE | UPDATE | CAPTURE )
			// OmpParser.g:
			{
<span class="nc" id="L2282">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2285">			set40=input.LT(1);</span>
<span class="nc bnc" id="L2286" title="All 8 branches missed.">			if ( input.LA(1)==CAPTURE||input.LA(1)==READ||(input.LA(1) &gt;= UPDATE &amp;&amp; input.LA(1) &lt;= WRITE) ) {</span>
<span class="nc" id="L2287">				input.consume();</span>
<span class="nc" id="L2288">				adaptor.addChild(root_0, (Object)adaptor.create(set40));</span>
<span class="nc" id="L2289">				state.errorRecovery=false;</span>
			}
			else {
<span class="nc" id="L2292">				MismatchedSetException mse = new MismatchedSetException(null,input);</span>
<span class="nc" id="L2293">				throw mse;</span>
			}
			}

<span class="nc" id="L2297">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2299">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2300">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2303">		catch (RecognitionException re) {</span>
<span class="nc" id="L2304">			reportError(re);</span>
<span class="nc" id="L2305">			recover(input,re);</span>
<span class="nc" id="L2306">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2308">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2310">		}</span>
<span class="nc" id="L2311">		return retval;</span>
	}
	// $ANTLR end &quot;atomic_clasue&quot;


<span class="nc" id="L2316">	public static class seq_cst_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2319">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;seq_cst_clause&quot;
	// OmpParser.g:144:1: seq_cst_clause : SEQ_CST ;
	public final OmpParser.seq_cst_clause_return seq_cst_clause() throws RecognitionException {
<span class="nc" id="L2326">		OmpParser.seq_cst_clause_return retval = new OmpParser.seq_cst_clause_return();</span>
<span class="nc" id="L2327">		retval.start = input.LT(1);</span>

<span class="nc" id="L2329">		Object root_0 = null;</span>

<span class="nc" id="L2331">		Token SEQ_CST41=null;</span>

<span class="nc" id="L2333">		Object SEQ_CST41_tree=null;</span>

		try {
			// OmpParser.g:145:2: ( SEQ_CST )
			// OmpParser.g:145:4: SEQ_CST
			{
<span class="nc" id="L2339">			root_0 = (Object)adaptor.nil();</span>


<span class="nc" id="L2342">			SEQ_CST41=(Token)match(input,SEQ_CST,FOLLOW_SEQ_CST_in_seq_cst_clause629); </span>
<span class="nc" id="L2343">			SEQ_CST41_tree = (Object)adaptor.create(SEQ_CST41);</span>
<span class="nc" id="L2344">			adaptor.addChild(root_0, SEQ_CST41_tree);</span>

			}

<span class="nc" id="L2348">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2350">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2351">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2354">		catch (RecognitionException re) {</span>
<span class="nc" id="L2355">			reportError(re);</span>
<span class="nc" id="L2356">			recover(input,re);</span>
<span class="nc" id="L2357">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2359">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2361">		}</span>
<span class="nc" id="L2362">		return retval;</span>
	}
	// $ANTLR end &quot;seq_cst_clause&quot;


<span class="nc" id="L2367">	public static class flush_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2370">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;flush_directive&quot;
	// OmpParser.g:148:1: flush_directive : FLUSH (f= flush_vars )? -&gt; ^( FLUSH ( $f)? ) ;
	public final OmpParser.flush_directive_return flush_directive() throws RecognitionException {
<span class="nc" id="L2377">		OmpParser.flush_directive_return retval = new OmpParser.flush_directive_return();</span>
<span class="nc" id="L2378">		retval.start = input.LT(1);</span>

<span class="nc" id="L2380">		Object root_0 = null;</span>

<span class="nc" id="L2382">		Token FLUSH42=null;</span>
<span class="nc" id="L2383">		ParserRuleReturnScope f =null;</span>

<span class="nc" id="L2385">		Object FLUSH42_tree=null;</span>
<span class="nc" id="L2386">		RewriteRuleTokenStream stream_FLUSH=new RewriteRuleTokenStream(adaptor,&quot;token FLUSH&quot;);</span>
<span class="nc" id="L2387">		RewriteRuleSubtreeStream stream_flush_vars=new RewriteRuleSubtreeStream(adaptor,&quot;rule flush_vars&quot;);</span>

		try {
			// OmpParser.g:149:3: ( FLUSH (f= flush_vars )? -&gt; ^( FLUSH ( $f)? ) )
			// OmpParser.g:149:5: FLUSH (f= flush_vars )?
			{
<span class="nc" id="L2393">			FLUSH42=(Token)match(input,FLUSH,FOLLOW_FLUSH_in_flush_directive642);  </span>
<span class="nc" id="L2394">			stream_FLUSH.add(FLUSH42);</span>

			// OmpParser.g:149:13: (f= flush_vars )?
<span class="nc" id="L2397">			int alt15=2;</span>
<span class="nc" id="L2398">			int LA15_0 = input.LA(1);</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">			if ( (LA15_0==LPAREN) ) {</span>
<span class="nc" id="L2400">				alt15=1;</span>
			}
<span class="nc bnc" id="L2402" title="All 2 branches missed.">			switch (alt15) {</span>
				case 1 :
					// OmpParser.g:149:13: f= flush_vars
					{
<span class="nc" id="L2406">					pushFollow(FOLLOW_flush_vars_in_flush_directive647);</span>
<span class="nc" id="L2407">					f=flush_vars();</span>
<span class="nc" id="L2408">					state._fsp--;</span>

<span class="nc" id="L2410">					stream_flush_vars.add(f.getTree());</span>
					}
					break;

			}

			// AST REWRITE
			// elements: f, FLUSH
			// token labels: 
			// rule labels: f, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2423">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,&quot;rule f&quot;,f!=null?f.getTree():null);</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2427">			root_0 = (Object)adaptor.nil();</span>
			// 150:5: -&gt; ^( FLUSH ( $f)? )
			{
				// OmpParser.g:150:8: ^( FLUSH ( $f)? )
				{
<span class="nc" id="L2432">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2433">				root_1 = (Object)adaptor.becomeRoot(stream_FLUSH.nextNode(), root_1);</span>
				// OmpParser.g:150:17: ( $f)?
<span class="nc bnc" id="L2435" title="All 2 branches missed.">				if ( stream_f.hasNext() ) {</span>
<span class="nc" id="L2436">					adaptor.addChild(root_1, stream_f.nextTree());</span>
				}
<span class="nc" id="L2438">				stream_f.reset();</span>

<span class="nc" id="L2440">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2446">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2450">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2452">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2453">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2456">		catch (RecognitionException re) {</span>
<span class="nc" id="L2457">			reportError(re);</span>
<span class="nc" id="L2458">			recover(input,re);</span>
<span class="nc" id="L2459">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2461">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2463">		}</span>
<span class="nc" id="L2464">		return retval;</span>
	}
	// $ANTLR end &quot;flush_directive&quot;


<span class="nc" id="L2469">	public static class flush_vars_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2472">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;flush_vars&quot;
	// OmpParser.g:153:1: flush_vars : LPAREN i= identifier_list RPAREN -&gt; ^( IDENTIFIER_LIST $i) ;
	public final OmpParser.flush_vars_return flush_vars() throws RecognitionException {
<span class="nc" id="L2479">		OmpParser.flush_vars_return retval = new OmpParser.flush_vars_return();</span>
<span class="nc" id="L2480">		retval.start = input.LT(1);</span>

<span class="nc" id="L2482">		Object root_0 = null;</span>

<span class="nc" id="L2484">		Token LPAREN43=null;</span>
<span class="nc" id="L2485">		Token RPAREN44=null;</span>
<span class="nc" id="L2486">		ParserRuleReturnScope i =null;</span>

<span class="nc" id="L2488">		Object LPAREN43_tree=null;</span>
<span class="nc" id="L2489">		Object RPAREN44_tree=null;</span>
<span class="nc" id="L2490">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L2491">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L2492">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:154:3: ( LPAREN i= identifier_list RPAREN -&gt; ^( IDENTIFIER_LIST $i) )
			// OmpParser.g:154:5: LPAREN i= identifier_list RPAREN
			{
<span class="nc" id="L2498">			LPAREN43=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_flush_vars675);  </span>
<span class="nc" id="L2499">			stream_LPAREN.add(LPAREN43);</span>

<span class="nc" id="L2501">			pushFollow(FOLLOW_identifier_list_in_flush_vars681);</span>
<span class="nc" id="L2502">			i=identifier_list();</span>
<span class="nc" id="L2503">			state._fsp--;</span>

<span class="nc" id="L2505">			stream_identifier_list.add(i.getTree());</span>
<span class="nc" id="L2506">			RPAREN44=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_flush_vars684);  </span>
<span class="nc" id="L2507">			stream_RPAREN.add(RPAREN44);</span>

			// AST REWRITE
			// elements: i
			// token labels: 
			// rule labels: retval, i
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2516">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,&quot;rule i&quot;,i!=null?i.getTree():null);</span>

<span class="nc" id="L2520">			root_0 = (Object)adaptor.nil();</span>
			// 155:5: -&gt; ^( IDENTIFIER_LIST $i)
			{
				// OmpParser.g:155:8: ^( IDENTIFIER_LIST $i)
				{
<span class="nc" id="L2525">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2526">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IDENTIFIER_LIST, &quot;IDENTIFIER_LIST&quot;), root_1);</span>
<span class="nc" id="L2527">				adaptor.addChild(root_1, stream_i.nextTree());</span>
<span class="nc" id="L2528">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2534">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2538">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2540">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2541">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2544">		catch (RecognitionException re) {</span>
<span class="nc" id="L2545">			reportError(re);</span>
<span class="nc" id="L2546">			recover(input,re);</span>
<span class="nc" id="L2547">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2549">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2551">		}</span>
<span class="nc" id="L2552">		return retval;</span>
	}
	// $ANTLR end &quot;flush_vars&quot;


<span class="nc" id="L2557">	public static class ordered_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2560">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;ordered_directive&quot;
	// OmpParser.g:158:1: ordered_directive : ORDERED -&gt; ^( ORDERED ) ;
	public final OmpParser.ordered_directive_return ordered_directive() throws RecognitionException {
<span class="nc" id="L2567">		OmpParser.ordered_directive_return retval = new OmpParser.ordered_directive_return();</span>
<span class="nc" id="L2568">		retval.start = input.LT(1);</span>

<span class="nc" id="L2570">		Object root_0 = null;</span>

<span class="nc" id="L2572">		Token ORDERED45=null;</span>

<span class="nc" id="L2574">		Object ORDERED45_tree=null;</span>
<span class="nc" id="L2575">		RewriteRuleTokenStream stream_ORDERED=new RewriteRuleTokenStream(adaptor,&quot;token ORDERED&quot;);</span>

		try {
			// OmpParser.g:159:3: ( ORDERED -&gt; ^( ORDERED ) )
			// OmpParser.g:159:5: ORDERED
			{
<span class="nc" id="L2581">			ORDERED45=(Token)match(input,ORDERED,FOLLOW_ORDERED_in_ordered_directive710);  </span>
<span class="nc" id="L2582">			stream_ORDERED.add(ORDERED45);</span>

			// AST REWRITE
			// elements: ORDERED
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2591">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2594">			root_0 = (Object)adaptor.nil();</span>
			// 159:13: -&gt; ^( ORDERED )
			{
				// OmpParser.g:159:16: ^( ORDERED )
				{
<span class="nc" id="L2599">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2600">				root_1 = (Object)adaptor.becomeRoot(stream_ORDERED.nextNode(), root_1);</span>
<span class="nc" id="L2601">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2607">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2611">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2613">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2614">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2617">		catch (RecognitionException re) {</span>
<span class="nc" id="L2618">			reportError(re);</span>
<span class="nc" id="L2619">			recover(input,re);</span>
<span class="nc" id="L2620">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2622">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2624">		}</span>
<span class="nc" id="L2625">		return retval;</span>
	}
	// $ANTLR end &quot;ordered_directive&quot;


<span class="nc" id="L2630">	public static class nowait_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2633">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;nowait_directive&quot;
	// OmpParser.g:162:1: nowait_directive : NOWAIT -&gt; ^( NOWAIT ) ;
	public final OmpParser.nowait_directive_return nowait_directive() throws RecognitionException {
<span class="nc" id="L2640">		OmpParser.nowait_directive_return retval = new OmpParser.nowait_directive_return();</span>
<span class="nc" id="L2641">		retval.start = input.LT(1);</span>

<span class="nc" id="L2643">		Object root_0 = null;</span>

<span class="nc" id="L2645">		Token NOWAIT46=null;</span>

<span class="nc" id="L2647">		Object NOWAIT46_tree=null;</span>
<span class="nc" id="L2648">		RewriteRuleTokenStream stream_NOWAIT=new RewriteRuleTokenStream(adaptor,&quot;token NOWAIT&quot;);</span>

		try {
			// OmpParser.g:163:3: ( NOWAIT -&gt; ^( NOWAIT ) )
			// OmpParser.g:163:5: NOWAIT
			{
<span class="nc" id="L2654">			NOWAIT46=(Token)match(input,NOWAIT,FOLLOW_NOWAIT_in_nowait_directive731);  </span>
<span class="nc" id="L2655">			stream_NOWAIT.add(NOWAIT46);</span>

			// AST REWRITE
			// elements: NOWAIT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2664">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L2667">			root_0 = (Object)adaptor.nil();</span>
			// 163:12: -&gt; ^( NOWAIT )
			{
				// OmpParser.g:163:15: ^( NOWAIT )
				{
<span class="nc" id="L2672">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2673">				root_1 = (Object)adaptor.becomeRoot(stream_NOWAIT.nextNode(), root_1);</span>
<span class="nc" id="L2674">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2680">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2684">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2686">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2687">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2690">		catch (RecognitionException re) {</span>
<span class="nc" id="L2691">			reportError(re);</span>
<span class="nc" id="L2692">			recover(input,re);</span>
<span class="nc" id="L2693">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2695">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2697">		}</span>
<span class="nc" id="L2698">		return retval;</span>
	}
	// $ANTLR end &quot;nowait_directive&quot;


<span class="nc" id="L2703">	public static class threadprivate_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2706">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;threadprivate_directive&quot;
	// OmpParser.g:166:1: threadprivate_directive : THD_PRIVATE LPAREN i= identifier_list RPAREN -&gt; ^( THD_PRIVATE $i) ;
	public final OmpParser.threadprivate_directive_return threadprivate_directive() throws RecognitionException {
<span class="nc" id="L2713">		OmpParser.threadprivate_directive_return retval = new OmpParser.threadprivate_directive_return();</span>
<span class="nc" id="L2714">		retval.start = input.LT(1);</span>

<span class="nc" id="L2716">		Object root_0 = null;</span>

<span class="nc" id="L2718">		Token THD_PRIVATE47=null;</span>
<span class="nc" id="L2719">		Token LPAREN48=null;</span>
<span class="nc" id="L2720">		Token RPAREN49=null;</span>
<span class="nc" id="L2721">		ParserRuleReturnScope i =null;</span>

<span class="nc" id="L2723">		Object THD_PRIVATE47_tree=null;</span>
<span class="nc" id="L2724">		Object LPAREN48_tree=null;</span>
<span class="nc" id="L2725">		Object RPAREN49_tree=null;</span>
<span class="nc" id="L2726">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L2727">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L2728">		RewriteRuleTokenStream stream_THD_PRIVATE=new RewriteRuleTokenStream(adaptor,&quot;token THD_PRIVATE&quot;);</span>
<span class="nc" id="L2729">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:167:3: ( THD_PRIVATE LPAREN i= identifier_list RPAREN -&gt; ^( THD_PRIVATE $i) )
			// OmpParser.g:167:5: THD_PRIVATE LPAREN i= identifier_list RPAREN
			{
<span class="nc" id="L2735">			THD_PRIVATE47=(Token)match(input,THD_PRIVATE,FOLLOW_THD_PRIVATE_in_threadprivate_directive750);  </span>
<span class="nc" id="L2736">			stream_THD_PRIVATE.add(THD_PRIVATE47);</span>

<span class="nc" id="L2738">			LPAREN48=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_threadprivate_directive753);  </span>
<span class="nc" id="L2739">			stream_LPAREN.add(LPAREN48);</span>

<span class="nc" id="L2741">			pushFollow(FOLLOW_identifier_list_in_threadprivate_directive758);</span>
<span class="nc" id="L2742">			i=identifier_list();</span>
<span class="nc" id="L2743">			state._fsp--;</span>

<span class="nc" id="L2745">			stream_identifier_list.add(i.getTree());</span>
<span class="nc" id="L2746">			RPAREN49=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_threadprivate_directive761);  </span>
<span class="nc" id="L2747">			stream_RPAREN.add(RPAREN49);</span>

			// AST REWRITE
			// elements: THD_PRIVATE, i
			// token labels: 
			// rule labels: retval, i
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L2756">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,&quot;rule i&quot;,i!=null?i.getTree():null);</span>

<span class="nc" id="L2760">			root_0 = (Object)adaptor.nil();</span>
			// 168:5: -&gt; ^( THD_PRIVATE $i)
			{
				// OmpParser.g:168:8: ^( THD_PRIVATE $i)
				{
<span class="nc" id="L2765">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2766">				root_1 = (Object)adaptor.becomeRoot(stream_THD_PRIVATE.nextNode(), root_1);</span>
<span class="nc" id="L2767">				adaptor.addChild(root_1, stream_i.nextTree());</span>
<span class="nc" id="L2768">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2774">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2778">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2780">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2781">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2784">		catch (RecognitionException re) {</span>
<span class="nc" id="L2785">			reportError(re);</span>
<span class="nc" id="L2786">			recover(input,re);</span>
<span class="nc" id="L2787">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2789">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2791">		}</span>
<span class="nc" id="L2792">		return retval;</span>
	}
	// $ANTLR end &quot;threadprivate_directive&quot;


<span class="nc" id="L2797">	public static class for_directive_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2800">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;for_directive&quot;
	// OmpParser.g:171:1: for_directive : FOR (f+= for_clause )* -&gt; ^( FOR ( $f)* ) ;
	public final OmpParser.for_directive_return for_directive() throws RecognitionException {
<span class="nc" id="L2807">		OmpParser.for_directive_return retval = new OmpParser.for_directive_return();</span>
<span class="nc" id="L2808">		retval.start = input.LT(1);</span>

<span class="nc" id="L2810">		Object root_0 = null;</span>

<span class="nc" id="L2812">		Token FOR50=null;</span>
<span class="nc" id="L2813">		List&lt;Object&gt; list_f=null;</span>
<span class="nc" id="L2814">		RuleReturnScope f = null;</span>
<span class="nc" id="L2815">		Object FOR50_tree=null;</span>
<span class="nc" id="L2816">		RewriteRuleTokenStream stream_FOR=new RewriteRuleTokenStream(adaptor,&quot;token FOR&quot;);</span>
<span class="nc" id="L2817">		RewriteRuleSubtreeStream stream_for_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule for_clause&quot;);</span>

		try {
			// OmpParser.g:172:3: ( FOR (f+= for_clause )* -&gt; ^( FOR ( $f)* ) )
			// OmpParser.g:172:5: FOR (f+= for_clause )*
			{
<span class="nc" id="L2823">			FOR50=(Token)match(input,FOR,FOLLOW_FOR_in_for_directive787);  </span>
<span class="nc" id="L2824">			stream_FOR.add(FOR50);</span>

			// OmpParser.g:172:10: (f+= for_clause )*
			loop16:
			while (true) {
<span class="nc" id="L2829">				int alt16=2;</span>
<span class="nc" id="L2830">				int LA16_0 = input.LA(1);</span>
<span class="nc bnc" id="L2831" title="All 22 branches missed.">				if ( (LA16_0==DEFAULT||LA16_0==SHARED||(LA16_0 &gt;= COLLAPSE &amp;&amp; LA16_0 &lt;= COPYPRIVATE)||LA16_0==FST_PRIVATE||LA16_0==LST_PRIVATE||LA16_0==NOWAIT||LA16_0==ORDERED||LA16_0==PRIVATE||LA16_0==REDUCTION||LA16_0==SCHEDULE) ) {</span>
<span class="nc" id="L2832">					alt16=1;</span>
				}

<span class="nc bnc" id="L2835" title="All 2 branches missed.">				switch (alt16) {</span>
				case 1 :
					// OmpParser.g:172:11: f+= for_clause
					{
<span class="nc" id="L2839">					pushFollow(FOLLOW_for_clause_in_for_directive793);</span>
<span class="nc" id="L2840">					f=for_clause();</span>
<span class="nc" id="L2841">					state._fsp--;</span>

<span class="nc" id="L2843">					stream_for_clause.add(f.getTree());</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">					if (list_f==null) list_f=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L2845">					list_f.add(f.getTree());</span>
					}
<span class="nc" id="L2847">					break;</span>

				default :
<span class="nc" id="L2850">					break loop16;</span>
				}
<span class="nc" id="L2852">			}</span>

			// AST REWRITE
			// elements: FOR, f
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: f
			// wildcard labels: 
<span class="nc" id="L2861">			retval.tree = root_0;</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc" id="L2863">			RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,&quot;token f&quot;,list_f);</span>
<span class="nc" id="L2864">			root_0 = (Object)adaptor.nil();</span>
			// 173:5: -&gt; ^( FOR ( $f)* )
			{
				// OmpParser.g:173:8: ^( FOR ( $f)* )
				{
<span class="nc" id="L2869">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2870">				root_1 = (Object)adaptor.becomeRoot(stream_FOR.nextNode(), root_1);</span>
				// OmpParser.g:173:15: ( $f)*
<span class="nc bnc" id="L2872" title="All 2 branches missed.">				while ( stream_f.hasNext() ) {</span>
<span class="nc" id="L2873">					adaptor.addChild(root_1, stream_f.nextTree());</span>
				}
<span class="nc" id="L2875">				stream_f.reset();</span>

<span class="nc" id="L2877">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L2883">			retval.tree = root_0;</span>

			}

<span class="nc" id="L2887">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L2889">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L2890">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L2893">		catch (RecognitionException re) {</span>
<span class="nc" id="L2894">			reportError(re);</span>
<span class="nc" id="L2895">			recover(input,re);</span>
<span class="nc" id="L2896">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L2898">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L2900">		}</span>
<span class="nc" id="L2901">		return retval;</span>
	}
	// $ANTLR end &quot;for_directive&quot;


<span class="nc" id="L2906">	public static class for_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L2909">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;for_clause&quot;
	// OmpParser.g:176:1: for_clause : (u= unique_for_clause -&gt; ^( FOR_CLAUSE $u) |d= data_clause -&gt; ^( FOR_CLAUSE $d) |n= nowait_directive -&gt; ^( FOR_CLAUSE $n) );
	public final OmpParser.for_clause_return for_clause() throws RecognitionException {
<span class="nc" id="L2916">		OmpParser.for_clause_return retval = new OmpParser.for_clause_return();</span>
<span class="nc" id="L2917">		retval.start = input.LT(1);</span>

<span class="nc" id="L2919">		Object root_0 = null;</span>

<span class="nc" id="L2921">		ParserRuleReturnScope u =null;</span>
<span class="nc" id="L2922">		ParserRuleReturnScope d =null;</span>
<span class="nc" id="L2923">		ParserRuleReturnScope n =null;</span>

<span class="nc" id="L2925">		RewriteRuleSubtreeStream stream_data_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule data_clause&quot;);</span>
<span class="nc" id="L2926">		RewriteRuleSubtreeStream stream_unique_for_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule unique_for_clause&quot;);</span>
<span class="nc" id="L2927">		RewriteRuleSubtreeStream stream_nowait_directive=new RewriteRuleSubtreeStream(adaptor,&quot;rule nowait_directive&quot;);</span>

		try {
			// OmpParser.g:177:3: (u= unique_for_clause -&gt; ^( FOR_CLAUSE $u) |d= data_clause -&gt; ^( FOR_CLAUSE $d) |n= nowait_directive -&gt; ^( FOR_CLAUSE $n) )
<span class="nc" id="L2931">			int alt17=3;</span>
<span class="nc bnc" id="L2932" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case COLLAPSE:
			case ORDERED:
			case SCHEDULE:
				{
<span class="nc" id="L2937">				alt17=1;</span>
				}
<span class="nc" id="L2939">				break;</span>
			case DEFAULT:
			case SHARED:
			case COPYIN:
			case COPYPRIVATE:
			case FST_PRIVATE:
			case LST_PRIVATE:
			case PRIVATE:
			case REDUCTION:
				{
<span class="nc" id="L2949">				alt17=2;</span>
				}
<span class="nc" id="L2951">				break;</span>
			case NOWAIT:
				{
<span class="nc" id="L2954">				alt17=3;</span>
				}
<span class="nc" id="L2956">				break;</span>
			default:
<span class="nc" id="L2958">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 17, 0, input);
<span class="nc" id="L2960">				throw nvae;</span>
			}
<span class="nc bnc" id="L2962" title="All 4 branches missed.">			switch (alt17) {</span>
				case 1 :
					// OmpParser.g:177:5: u= unique_for_clause
					{
<span class="nc" id="L2966">					pushFollow(FOLLOW_unique_for_clause_in_for_clause824);</span>
<span class="nc" id="L2967">					u=unique_for_clause();</span>
<span class="nc" id="L2968">					state._fsp--;</span>

<span class="nc" id="L2970">					stream_unique_for_clause.add(u.getTree());</span>
					// AST REWRITE
					// elements: u
					// token labels: 
					// rule labels: retval, u
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L2978">					retval.tree = root_0;</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_u=new RewriteRuleSubtreeStream(adaptor,&quot;rule u&quot;,u!=null?u.getTree():null);</span>

<span class="nc" id="L2982">					root_0 = (Object)adaptor.nil();</span>
					// 177:25: -&gt; ^( FOR_CLAUSE $u)
					{
						// OmpParser.g:177:28: ^( FOR_CLAUSE $u)
						{
<span class="nc" id="L2987">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L2988">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_CLAUSE, &quot;FOR_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L2989">						adaptor.addChild(root_1, stream_u.nextTree());</span>
<span class="nc" id="L2990">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L2996">					retval.tree = root_0;</span>

					}
<span class="nc" id="L2999">					break;</span>
				case 2 :
					// OmpParser.g:178:5: d= data_clause
					{
<span class="nc" id="L3003">					pushFollow(FOLLOW_data_clause_in_for_clause841);</span>
<span class="nc" id="L3004">					d=data_clause();</span>
<span class="nc" id="L3005">					state._fsp--;</span>

<span class="nc" id="L3007">					stream_data_clause.add(d.getTree());</span>
					// AST REWRITE
					// elements: d
					// token labels: 
					// rule labels: retval, d
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3015">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d=new RewriteRuleSubtreeStream(adaptor,&quot;rule d&quot;,d!=null?d.getTree():null);</span>

<span class="nc" id="L3019">					root_0 = (Object)adaptor.nil();</span>
					// 178:19: -&gt; ^( FOR_CLAUSE $d)
					{
						// OmpParser.g:178:22: ^( FOR_CLAUSE $d)
						{
<span class="nc" id="L3024">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3025">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_CLAUSE, &quot;FOR_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L3026">						adaptor.addChild(root_1, stream_d.nextTree());</span>
<span class="nc" id="L3027">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3033">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3036">					break;</span>
				case 3 :
					// OmpParser.g:179:5: n= nowait_directive
					{
<span class="nc" id="L3040">					pushFollow(FOLLOW_nowait_directive_in_for_clause858);</span>
<span class="nc" id="L3041">					n=nowait_directive();</span>
<span class="nc" id="L3042">					state._fsp--;</span>

<span class="nc" id="L3044">					stream_nowait_directive.add(n.getTree());</span>
					// AST REWRITE
					// elements: n
					// token labels: 
					// rule labels: retval, n
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3052">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,&quot;rule n&quot;,n!=null?n.getTree():null);</span>

<span class="nc" id="L3056">					root_0 = (Object)adaptor.nil();</span>
					// 179:24: -&gt; ^( FOR_CLAUSE $n)
					{
						// OmpParser.g:179:27: ^( FOR_CLAUSE $n)
						{
<span class="nc" id="L3061">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3062">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(FOR_CLAUSE, &quot;FOR_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L3063">						adaptor.addChild(root_1, stream_n.nextTree());</span>
<span class="nc" id="L3064">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3070">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L3076">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L3078">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3079">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L3082">		catch (RecognitionException re) {</span>
<span class="nc" id="L3083">			reportError(re);</span>
<span class="nc" id="L3084">			recover(input,re);</span>
<span class="nc" id="L3085">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3087">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3089">		}</span>
<span class="nc" id="L3090">		return retval;</span>
	}
	// $ANTLR end &quot;for_clause&quot;


<span class="nc" id="L3095">	public static class unique_for_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3098">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;unique_for_clause&quot;
	// OmpParser.g:182:1: unique_for_clause : ( ORDERED -&gt; ^( UNIQUE_FOR ORDERED ) |s1= schedule_clause -&gt; ^( UNIQUE_FOR $s1) |c= collapse_clause -&gt; ^( UNIQUE_FOR $c) );
	public final OmpParser.unique_for_clause_return unique_for_clause() throws RecognitionException {
<span class="nc" id="L3105">		OmpParser.unique_for_clause_return retval = new OmpParser.unique_for_clause_return();</span>
<span class="nc" id="L3106">		retval.start = input.LT(1);</span>

<span class="nc" id="L3108">		Object root_0 = null;</span>

<span class="nc" id="L3110">		Token ORDERED51=null;</span>
<span class="nc" id="L3111">		ParserRuleReturnScope s1 =null;</span>
<span class="nc" id="L3112">		ParserRuleReturnScope c =null;</span>

<span class="nc" id="L3114">		Object ORDERED51_tree=null;</span>
<span class="nc" id="L3115">		RewriteRuleTokenStream stream_ORDERED=new RewriteRuleTokenStream(adaptor,&quot;token ORDERED&quot;);</span>
<span class="nc" id="L3116">		RewriteRuleSubtreeStream stream_collapse_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule collapse_clause&quot;);</span>
<span class="nc" id="L3117">		RewriteRuleSubtreeStream stream_schedule_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule schedule_clause&quot;);</span>

		try {
			// OmpParser.g:183:3: ( ORDERED -&gt; ^( UNIQUE_FOR ORDERED ) |s1= schedule_clause -&gt; ^( UNIQUE_FOR $s1) |c= collapse_clause -&gt; ^( UNIQUE_FOR $c) )
<span class="nc" id="L3121">			int alt18=3;</span>
<span class="nc bnc" id="L3122" title="All 4 branches missed.">			switch ( input.LA(1) ) {</span>
			case ORDERED:
				{
<span class="nc" id="L3125">				alt18=1;</span>
				}
<span class="nc" id="L3127">				break;</span>
			case SCHEDULE:
				{
<span class="nc" id="L3130">				alt18=2;</span>
				}
<span class="nc" id="L3132">				break;</span>
			case COLLAPSE:
				{
<span class="nc" id="L3135">				alt18=3;</span>
				}
<span class="nc" id="L3137">				break;</span>
			default:
<span class="nc" id="L3139">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 18, 0, input);
<span class="nc" id="L3141">				throw nvae;</span>
			}
<span class="nc bnc" id="L3143" title="All 4 branches missed.">			switch (alt18) {</span>
				case 1 :
					// OmpParser.g:183:5: ORDERED
					{
<span class="nc" id="L3147">					ORDERED51=(Token)match(input,ORDERED,FOLLOW_ORDERED_in_unique_for_clause880);  </span>
<span class="nc" id="L3148">					stream_ORDERED.add(ORDERED51);</span>

					// AST REWRITE
					// elements: ORDERED
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3157">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3160">					root_0 = (Object)adaptor.nil();</span>
					// 183:13: -&gt; ^( UNIQUE_FOR ORDERED )
					{
						// OmpParser.g:183:15: ^( UNIQUE_FOR ORDERED )
						{
<span class="nc" id="L3165">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3166">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNIQUE_FOR, &quot;UNIQUE_FOR&quot;), root_1);</span>
<span class="nc" id="L3167">						adaptor.addChild(root_1, stream_ORDERED.nextNode());</span>
<span class="nc" id="L3168">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3174">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3177">					break;</span>
				case 2 :
					// OmpParser.g:184:5: s1= schedule_clause
					{
<span class="nc" id="L3181">					pushFollow(FOLLOW_schedule_clause_in_unique_for_clause895);</span>
<span class="nc" id="L3182">					s1=schedule_clause();</span>
<span class="nc" id="L3183">					state._fsp--;</span>

<span class="nc" id="L3185">					stream_schedule_clause.add(s1.getTree());</span>
					// AST REWRITE
					// elements: s1
					// token labels: 
					// rule labels: retval, s1
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3193">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,&quot;rule s1&quot;,s1!=null?s1.getTree():null);</span>

<span class="nc" id="L3197">					root_0 = (Object)adaptor.nil();</span>
					// 184:24: -&gt; ^( UNIQUE_FOR $s1)
					{
						// OmpParser.g:184:27: ^( UNIQUE_FOR $s1)
						{
<span class="nc" id="L3202">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3203">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNIQUE_FOR, &quot;UNIQUE_FOR&quot;), root_1);</span>
<span class="nc" id="L3204">						adaptor.addChild(root_1, stream_s1.nextTree());</span>
<span class="nc" id="L3205">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3211">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3214">					break;</span>
				case 3 :
					// OmpParser.g:185:5: c= collapse_clause
					{
<span class="nc" id="L3218">					pushFollow(FOLLOW_collapse_clause_in_unique_for_clause912);</span>
<span class="nc" id="L3219">					c=collapse_clause();</span>
<span class="nc" id="L3220">					state._fsp--;</span>

<span class="nc" id="L3222">					stream_collapse_clause.add(c.getTree());</span>
					// AST REWRITE
					// elements: c
					// token labels: 
					// rule labels: retval, c
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3230">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3231" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3232" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_c=new RewriteRuleSubtreeStream(adaptor,&quot;rule c&quot;,c!=null?c.getTree():null);</span>

<span class="nc" id="L3234">					root_0 = (Object)adaptor.nil();</span>
					// 185:23: -&gt; ^( UNIQUE_FOR $c)
					{
						// OmpParser.g:185:26: ^( UNIQUE_FOR $c)
						{
<span class="nc" id="L3239">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3240">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNIQUE_FOR, &quot;UNIQUE_FOR&quot;), root_1);</span>
<span class="nc" id="L3241">						adaptor.addChild(root_1, stream_c.nextTree());</span>
<span class="nc" id="L3242">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3248">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L3254">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L3256">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3257">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L3260">		catch (RecognitionException re) {</span>
<span class="nc" id="L3261">			reportError(re);</span>
<span class="nc" id="L3262">			recover(input,re);</span>
<span class="nc" id="L3263">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3265">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3267">		}</span>
<span class="nc" id="L3268">		return retval;</span>
	}
	// $ANTLR end &quot;unique_for_clause&quot;


<span class="nc" id="L3273">	public static class schedule_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3276">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;schedule_clause&quot;
	// OmpParser.g:188:1: schedule_clause : ( SCHEDULE LPAREN s1= schedule_kind COMMA e= expression RPAREN -&gt; ^( SCHEDULE $s1 $e) | SCHEDULE LPAREN s= schedule_kind RPAREN -&gt; ^( SCHEDULE $s) );
	public final OmpParser.schedule_clause_return schedule_clause() throws RecognitionException {
<span class="nc" id="L3283">		OmpParser.schedule_clause_return retval = new OmpParser.schedule_clause_return();</span>
<span class="nc" id="L3284">		retval.start = input.LT(1);</span>

<span class="nc" id="L3286">		Object root_0 = null;</span>

<span class="nc" id="L3288">		Token SCHEDULE52=null;</span>
<span class="nc" id="L3289">		Token LPAREN53=null;</span>
<span class="nc" id="L3290">		Token COMMA54=null;</span>
<span class="nc" id="L3291">		Token RPAREN55=null;</span>
<span class="nc" id="L3292">		Token SCHEDULE56=null;</span>
<span class="nc" id="L3293">		Token LPAREN57=null;</span>
<span class="nc" id="L3294">		Token RPAREN58=null;</span>
<span class="nc" id="L3295">		ParserRuleReturnScope s1 =null;</span>
<span class="nc" id="L3296">		ParserRuleReturnScope e =null;</span>
<span class="nc" id="L3297">		ParserRuleReturnScope s =null;</span>

<span class="nc" id="L3299">		Object SCHEDULE52_tree=null;</span>
<span class="nc" id="L3300">		Object LPAREN53_tree=null;</span>
<span class="nc" id="L3301">		Object COMMA54_tree=null;</span>
<span class="nc" id="L3302">		Object RPAREN55_tree=null;</span>
<span class="nc" id="L3303">		Object SCHEDULE56_tree=null;</span>
<span class="nc" id="L3304">		Object LPAREN57_tree=null;</span>
<span class="nc" id="L3305">		Object RPAREN58_tree=null;</span>
<span class="nc" id="L3306">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L3307">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L3308">		RewriteRuleTokenStream stream_SCHEDULE=new RewriteRuleTokenStream(adaptor,&quot;token SCHEDULE&quot;);</span>
<span class="nc" id="L3309">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L3310">		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,&quot;rule expression&quot;);</span>
<span class="nc" id="L3311">		RewriteRuleSubtreeStream stream_schedule_kind=new RewriteRuleSubtreeStream(adaptor,&quot;rule schedule_kind&quot;);</span>

		try {
			// OmpParser.g:189:2: ( SCHEDULE LPAREN s1= schedule_kind COMMA e= expression RPAREN -&gt; ^( SCHEDULE $s1 $e) | SCHEDULE LPAREN s= schedule_kind RPAREN -&gt; ^( SCHEDULE $s) )
<span class="nc" id="L3315">			int alt19=2;</span>
<span class="nc" id="L3316">			int LA19_0 = input.LA(1);</span>
<span class="nc bnc" id="L3317" title="All 2 branches missed.">			if ( (LA19_0==SCHEDULE) ) {</span>
<span class="nc" id="L3318">				int LA19_1 = input.LA(2);</span>
<span class="nc bnc" id="L3319" title="All 2 branches missed.">				if ( (LA19_1==LPAREN) ) {</span>
<span class="nc bnc" id="L3320" title="All 5 branches missed.">					switch ( input.LA(3) ) {</span>
					case STATIC:
						{
<span class="nc" id="L3323">						int LA19_3 = input.LA(4);</span>
<span class="nc bnc" id="L3324" title="All 2 branches missed.">						if ( (LA19_3==COMMA) ) {</span>
<span class="nc" id="L3325">							alt19=1;</span>
						}
<span class="nc bnc" id="L3327" title="All 2 branches missed.">						else if ( (LA19_3==RPAREN) ) {</span>
<span class="nc" id="L3328">							alt19=2;</span>
						}

						else {
<span class="nc" id="L3332">							int nvaeMark = input.mark();</span>
							try {
<span class="nc bnc" id="L3334" title="All 2 branches missed.">								for (int nvaeConsume = 0; nvaeConsume &lt; 4 - 1; nvaeConsume++) {</span>
<span class="nc" id="L3335">									input.consume();</span>
								}
<span class="nc" id="L3337">								NoViableAltException nvae =</span>
									new NoViableAltException(&quot;&quot;, 19, 3, input);
<span class="nc" id="L3339">								throw nvae;</span>
							} finally {
<span class="nc" id="L3341">								input.rewind(nvaeMark);</span>
							}
						}

						}
<span class="nc" id="L3346">						break;</span>
					case DYNAMIC:
						{
<span class="nc" id="L3349">						int LA19_4 = input.LA(4);</span>
<span class="nc bnc" id="L3350" title="All 2 branches missed.">						if ( (LA19_4==COMMA) ) {</span>
<span class="nc" id="L3351">							alt19=1;</span>
						}
<span class="nc bnc" id="L3353" title="All 2 branches missed.">						else if ( (LA19_4==RPAREN) ) {</span>
<span class="nc" id="L3354">							alt19=2;</span>
						}

						else {
<span class="nc" id="L3358">							int nvaeMark = input.mark();</span>
							try {
<span class="nc bnc" id="L3360" title="All 2 branches missed.">								for (int nvaeConsume = 0; nvaeConsume &lt; 4 - 1; nvaeConsume++) {</span>
<span class="nc" id="L3361">									input.consume();</span>
								}
<span class="nc" id="L3363">								NoViableAltException nvae =</span>
									new NoViableAltException(&quot;&quot;, 19, 4, input);
<span class="nc" id="L3365">								throw nvae;</span>
							} finally {
<span class="nc" id="L3367">								input.rewind(nvaeMark);</span>
							}
						}

						}
<span class="nc" id="L3372">						break;</span>
					case GUIDED:
						{
<span class="nc" id="L3375">						int LA19_5 = input.LA(4);</span>
<span class="nc bnc" id="L3376" title="All 2 branches missed.">						if ( (LA19_5==COMMA) ) {</span>
<span class="nc" id="L3377">							alt19=1;</span>
						}
<span class="nc bnc" id="L3379" title="All 2 branches missed.">						else if ( (LA19_5==RPAREN) ) {</span>
<span class="nc" id="L3380">							alt19=2;</span>
						}

						else {
<span class="nc" id="L3384">							int nvaeMark = input.mark();</span>
							try {
<span class="nc bnc" id="L3386" title="All 2 branches missed.">								for (int nvaeConsume = 0; nvaeConsume &lt; 4 - 1; nvaeConsume++) {</span>
<span class="nc" id="L3387">									input.consume();</span>
								}
<span class="nc" id="L3389">								NoViableAltException nvae =</span>
									new NoViableAltException(&quot;&quot;, 19, 5, input);
<span class="nc" id="L3391">								throw nvae;</span>
							} finally {
<span class="nc" id="L3393">								input.rewind(nvaeMark);</span>
							}
						}

						}
<span class="nc" id="L3398">						break;</span>
					case RUNTIME:
						{
<span class="nc" id="L3401">						int LA19_6 = input.LA(4);</span>
<span class="nc bnc" id="L3402" title="All 2 branches missed.">						if ( (LA19_6==COMMA) ) {</span>
<span class="nc" id="L3403">							alt19=1;</span>
						}
<span class="nc bnc" id="L3405" title="All 2 branches missed.">						else if ( (LA19_6==RPAREN) ) {</span>
<span class="nc" id="L3406">							alt19=2;</span>
						}

						else {
<span class="nc" id="L3410">							int nvaeMark = input.mark();</span>
							try {
<span class="nc bnc" id="L3412" title="All 2 branches missed.">								for (int nvaeConsume = 0; nvaeConsume &lt; 4 - 1; nvaeConsume++) {</span>
<span class="nc" id="L3413">									input.consume();</span>
								}
<span class="nc" id="L3415">								NoViableAltException nvae =</span>
									new NoViableAltException(&quot;&quot;, 19, 6, input);
<span class="nc" id="L3417">								throw nvae;</span>
							} finally {
<span class="nc" id="L3419">								input.rewind(nvaeMark);</span>
							}
						}

						}
<span class="nc" id="L3424">						break;</span>
					default:
<span class="nc" id="L3426">						int nvaeMark = input.mark();</span>
						try {
<span class="nc bnc" id="L3428" title="All 2 branches missed.">							for (int nvaeConsume = 0; nvaeConsume &lt; 3 - 1; nvaeConsume++) {</span>
<span class="nc" id="L3429">								input.consume();</span>
							}
<span class="nc" id="L3431">							NoViableAltException nvae =</span>
								new NoViableAltException(&quot;&quot;, 19, 2, input);
<span class="nc" id="L3433">							throw nvae;</span>
						} finally {
<span class="nc" id="L3435">							input.rewind(nvaeMark);</span>
						}
					}
				}

				else {
<span class="nc" id="L3441">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L3443">						input.consume();</span>
<span class="nc" id="L3444">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 19, 1, input);
<span class="nc" id="L3446">						throw nvae;</span>
					} finally {
<span class="nc" id="L3448">						input.rewind(nvaeMark);</span>
					}
				}

<span class="nc" id="L3452">			}</span>

			else {
<span class="nc" id="L3455">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 19, 0, input);
<span class="nc" id="L3457">				throw nvae;</span>
			}

<span class="nc bnc" id="L3460" title="All 3 branches missed.">			switch (alt19) {</span>
				case 1 :
					// OmpParser.g:189:4: SCHEDULE LPAREN s1= schedule_kind COMMA e= expression RPAREN
					{
<span class="nc" id="L3464">					SCHEDULE52=(Token)match(input,SCHEDULE,FOLLOW_SCHEDULE_in_schedule_clause935);  </span>
<span class="nc" id="L3465">					stream_SCHEDULE.add(SCHEDULE52);</span>

<span class="nc" id="L3467">					LPAREN53=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_schedule_clause938);  </span>
<span class="nc" id="L3468">					stream_LPAREN.add(LPAREN53);</span>

<span class="nc" id="L3470">					pushFollow(FOLLOW_schedule_kind_in_schedule_clause943);</span>
<span class="nc" id="L3471">					s1=schedule_kind();</span>
<span class="nc" id="L3472">					state._fsp--;</span>

<span class="nc" id="L3474">					stream_schedule_kind.add(s1.getTree());</span>
<span class="nc" id="L3475">					COMMA54=(Token)match(input,COMMA,FOLLOW_COMMA_in_schedule_clause946);  </span>
<span class="nc" id="L3476">					stream_COMMA.add(COMMA54);</span>

<span class="nc" id="L3478">					pushFollow(FOLLOW_expression_in_schedule_clause951);</span>
<span class="nc" id="L3479">					e=expression();</span>
<span class="nc" id="L3480">					state._fsp--;</span>

<span class="nc" id="L3482">					stream_expression.add(e.getTree());</span>
<span class="nc" id="L3483">					RPAREN55=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_schedule_clause954);  </span>
<span class="nc" id="L3484">					stream_RPAREN.add(RPAREN55);</span>

					// AST REWRITE
					// elements: e, SCHEDULE, s1
					// token labels: 
					// rule labels: retval, s1, e
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3493">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3494" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_s1=new RewriteRuleSubtreeStream(adaptor,&quot;rule s1&quot;,s1!=null?s1.getTree():null);</span>
<span class="nc bnc" id="L3496" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,&quot;rule e&quot;,e!=null?e.getTree():null);</span>

<span class="nc" id="L3498">					root_0 = (Object)adaptor.nil();</span>
					// 190:7: -&gt; ^( SCHEDULE $s1 $e)
					{
						// OmpParser.g:190:10: ^( SCHEDULE $s1 $e)
						{
<span class="nc" id="L3503">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3504">						root_1 = (Object)adaptor.becomeRoot(stream_SCHEDULE.nextNode(), root_1);</span>
<span class="nc" id="L3505">						adaptor.addChild(root_1, stream_s1.nextTree());</span>
<span class="nc" id="L3506">						adaptor.addChild(root_1, stream_e.nextTree());</span>
<span class="nc" id="L3507">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3513">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3516">					break;</span>
				case 2 :
					// OmpParser.g:191:8: SCHEDULE LPAREN s= schedule_kind RPAREN
					{
<span class="nc" id="L3520">					SCHEDULE56=(Token)match(input,SCHEDULE,FOLLOW_SCHEDULE_in_schedule_clause981);  </span>
<span class="nc" id="L3521">					stream_SCHEDULE.add(SCHEDULE56);</span>

<span class="nc" id="L3523">					LPAREN57=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_schedule_clause984);  </span>
<span class="nc" id="L3524">					stream_LPAREN.add(LPAREN57);</span>

<span class="nc" id="L3526">					pushFollow(FOLLOW_schedule_kind_in_schedule_clause989);</span>
<span class="nc" id="L3527">					s=schedule_kind();</span>
<span class="nc" id="L3528">					state._fsp--;</span>

<span class="nc" id="L3530">					stream_schedule_kind.add(s.getTree());</span>
<span class="nc" id="L3531">					RPAREN58=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_schedule_clause992);  </span>
<span class="nc" id="L3532">					stream_RPAREN.add(RPAREN58);</span>

					// AST REWRITE
					// elements: SCHEDULE, s
					// token labels: 
					// rule labels: retval, s
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3541">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3543" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,&quot;rule s&quot;,s!=null?s.getTree():null);</span>

<span class="nc" id="L3545">					root_0 = (Object)adaptor.nil();</span>
					// 192:4: -&gt; ^( SCHEDULE $s)
					{
						// OmpParser.g:192:7: ^( SCHEDULE $s)
						{
<span class="nc" id="L3550">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3551">						root_1 = (Object)adaptor.becomeRoot(stream_SCHEDULE.nextNode(), root_1);</span>
<span class="nc" id="L3552">						adaptor.addChild(root_1, stream_s.nextTree());</span>
<span class="nc" id="L3553">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3559">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L3565">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L3567">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3568">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L3571">		catch (RecognitionException re) {</span>
<span class="nc" id="L3572">			reportError(re);</span>
<span class="nc" id="L3573">			recover(input,re);</span>
<span class="nc" id="L3574">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3576">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3578">		}</span>
<span class="nc" id="L3579">		return retval;</span>
	}
	// $ANTLR end &quot;schedule_clause&quot;


<span class="nc" id="L3584">	public static class collapse_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3587">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;collapse_clause&quot;
	// OmpParser.g:195:1: collapse_clause : COLLAPSE LPAREN i= INTEGER_CONSTANT RPAREN -&gt; ^( COLLAPSE $i) ;
	public final OmpParser.collapse_clause_return collapse_clause() throws RecognitionException {
<span class="nc" id="L3594">		OmpParser.collapse_clause_return retval = new OmpParser.collapse_clause_return();</span>
<span class="nc" id="L3595">		retval.start = input.LT(1);</span>

<span class="nc" id="L3597">		Object root_0 = null;</span>

<span class="nc" id="L3599">		Token i=null;</span>
<span class="nc" id="L3600">		Token COLLAPSE59=null;</span>
<span class="nc" id="L3601">		Token LPAREN60=null;</span>
<span class="nc" id="L3602">		Token RPAREN61=null;</span>

<span class="nc" id="L3604">		Object i_tree=null;</span>
<span class="nc" id="L3605">		Object COLLAPSE59_tree=null;</span>
<span class="nc" id="L3606">		Object LPAREN60_tree=null;</span>
<span class="nc" id="L3607">		Object RPAREN61_tree=null;</span>
<span class="nc" id="L3608">		RewriteRuleTokenStream stream_COLLAPSE=new RewriteRuleTokenStream(adaptor,&quot;token COLLAPSE&quot;);</span>
<span class="nc" id="L3609">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L3610">		RewriteRuleTokenStream stream_INTEGER_CONSTANT=new RewriteRuleTokenStream(adaptor,&quot;token INTEGER_CONSTANT&quot;);</span>
<span class="nc" id="L3611">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>

		try {
			// OmpParser.g:196:2: ( COLLAPSE LPAREN i= INTEGER_CONSTANT RPAREN -&gt; ^( COLLAPSE $i) )
			// OmpParser.g:197:2: COLLAPSE LPAREN i= INTEGER_CONSTANT RPAREN
			{
<span class="nc" id="L3617">			COLLAPSE59=(Token)match(input,COLLAPSE,FOLLOW_COLLAPSE_in_collapse_clause1017);  </span>
<span class="nc" id="L3618">			stream_COLLAPSE.add(COLLAPSE59);</span>

<span class="nc" id="L3620">			LPAREN60=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_collapse_clause1020);  </span>
<span class="nc" id="L3621">			stream_LPAREN.add(LPAREN60);</span>

<span class="nc" id="L3623">			i=(Token)match(input,INTEGER_CONSTANT,FOLLOW_INTEGER_CONSTANT_in_collapse_clause1025);  </span>
<span class="nc" id="L3624">			stream_INTEGER_CONSTANT.add(i);</span>

<span class="nc" id="L3626">			RPAREN61=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_collapse_clause1028);  </span>
<span class="nc" id="L3627">			stream_RPAREN.add(RPAREN61);</span>

			// AST REWRITE
			// elements: COLLAPSE, i
			// token labels: i
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L3636">			retval.tree = root_0;</span>
<span class="nc" id="L3637">			RewriteRuleTokenStream stream_i=new RewriteRuleTokenStream(adaptor,&quot;token i&quot;,i);</span>
<span class="nc bnc" id="L3638" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3640">			root_0 = (Object)adaptor.nil();</span>
			// 198:5: -&gt; ^( COLLAPSE $i)
			{
				// OmpParser.g:198:8: ^( COLLAPSE $i)
				{
<span class="nc" id="L3645">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3646">				root_1 = (Object)adaptor.becomeRoot(stream_COLLAPSE.nextNode(), root_1);</span>
<span class="nc" id="L3647">				adaptor.addChild(root_1, stream_i.nextNode());</span>
<span class="nc" id="L3648">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L3654">			retval.tree = root_0;</span>

			}

<span class="nc" id="L3658">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L3660">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3661">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L3664">		catch (RecognitionException re) {</span>
<span class="nc" id="L3665">			reportError(re);</span>
<span class="nc" id="L3666">			recover(input,re);</span>
<span class="nc" id="L3667">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3669">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3671">		}</span>
<span class="nc" id="L3672">		return retval;</span>
	}
	// $ANTLR end &quot;collapse_clause&quot;


<span class="nc" id="L3677">	public static class schedule_kind_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3680">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;schedule_kind&quot;
	// OmpParser.g:201:1: schedule_kind : ( STATIC -&gt; ^( STATIC ) | DYNAMIC -&gt; ^( DYNAMIC ) | GUIDED -&gt; ^( GUIDED ) | RUNTIME -&gt; ^( RUNTIME ) );
	public final OmpParser.schedule_kind_return schedule_kind() throws RecognitionException {
<span class="nc" id="L3687">		OmpParser.schedule_kind_return retval = new OmpParser.schedule_kind_return();</span>
<span class="nc" id="L3688">		retval.start = input.LT(1);</span>

<span class="nc" id="L3690">		Object root_0 = null;</span>

<span class="nc" id="L3692">		Token STATIC62=null;</span>
<span class="nc" id="L3693">		Token DYNAMIC63=null;</span>
<span class="nc" id="L3694">		Token GUIDED64=null;</span>
<span class="nc" id="L3695">		Token RUNTIME65=null;</span>

<span class="nc" id="L3697">		Object STATIC62_tree=null;</span>
<span class="nc" id="L3698">		Object DYNAMIC63_tree=null;</span>
<span class="nc" id="L3699">		Object GUIDED64_tree=null;</span>
<span class="nc" id="L3700">		Object RUNTIME65_tree=null;</span>
<span class="nc" id="L3701">		RewriteRuleTokenStream stream_STATIC=new RewriteRuleTokenStream(adaptor,&quot;token STATIC&quot;);</span>
<span class="nc" id="L3702">		RewriteRuleTokenStream stream_GUIDED=new RewriteRuleTokenStream(adaptor,&quot;token GUIDED&quot;);</span>
<span class="nc" id="L3703">		RewriteRuleTokenStream stream_DYNAMIC=new RewriteRuleTokenStream(adaptor,&quot;token DYNAMIC&quot;);</span>
<span class="nc" id="L3704">		RewriteRuleTokenStream stream_RUNTIME=new RewriteRuleTokenStream(adaptor,&quot;token RUNTIME&quot;);</span>

		try {
			// OmpParser.g:202:3: ( STATIC -&gt; ^( STATIC ) | DYNAMIC -&gt; ^( DYNAMIC ) | GUIDED -&gt; ^( GUIDED ) | RUNTIME -&gt; ^( RUNTIME ) )
<span class="nc" id="L3708">			int alt20=4;</span>
<span class="nc bnc" id="L3709" title="All 5 branches missed.">			switch ( input.LA(1) ) {</span>
			case STATIC:
				{
<span class="nc" id="L3712">				alt20=1;</span>
				}
<span class="nc" id="L3714">				break;</span>
			case DYNAMIC:
				{
<span class="nc" id="L3717">				alt20=2;</span>
				}
<span class="nc" id="L3719">				break;</span>
			case GUIDED:
				{
<span class="nc" id="L3722">				alt20=3;</span>
				}
<span class="nc" id="L3724">				break;</span>
			case RUNTIME:
				{
<span class="nc" id="L3727">				alt20=4;</span>
				}
<span class="nc" id="L3729">				break;</span>
			default:
<span class="nc" id="L3731">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 20, 0, input);
<span class="nc" id="L3733">				throw nvae;</span>
			}
<span class="nc bnc" id="L3735" title="All 5 branches missed.">			switch (alt20) {</span>
				case 1 :
					// OmpParser.g:202:5: STATIC
					{
<span class="nc" id="L3739">					STATIC62=(Token)match(input,STATIC,FOLLOW_STATIC_in_schedule_kind1053);  </span>
<span class="nc" id="L3740">					stream_STATIC.add(STATIC62);</span>

					// AST REWRITE
					// elements: STATIC
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3749">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3750" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3752">					root_0 = (Object)adaptor.nil();</span>
					// 202:12: -&gt; ^( STATIC )
					{
						// OmpParser.g:202:15: ^( STATIC )
						{
<span class="nc" id="L3757">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3758">						root_1 = (Object)adaptor.becomeRoot(stream_STATIC.nextNode(), root_1);</span>
<span class="nc" id="L3759">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3765">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3768">					break;</span>
				case 2 :
					// OmpParser.g:203:5: DYNAMIC
					{
<span class="nc" id="L3772">					DYNAMIC63=(Token)match(input,DYNAMIC,FOLLOW_DYNAMIC_in_schedule_kind1065);  </span>
<span class="nc" id="L3773">					stream_DYNAMIC.add(DYNAMIC63);</span>

					// AST REWRITE
					// elements: DYNAMIC
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3782">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3785">					root_0 = (Object)adaptor.nil();</span>
					// 203:13: -&gt; ^( DYNAMIC )
					{
						// OmpParser.g:203:16: ^( DYNAMIC )
						{
<span class="nc" id="L3790">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3791">						root_1 = (Object)adaptor.becomeRoot(stream_DYNAMIC.nextNode(), root_1);</span>
<span class="nc" id="L3792">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3798">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3801">					break;</span>
				case 3 :
					// OmpParser.g:204:5: GUIDED
					{
<span class="nc" id="L3805">					GUIDED64=(Token)match(input,GUIDED,FOLLOW_GUIDED_in_schedule_kind1077);  </span>
<span class="nc" id="L3806">					stream_GUIDED.add(GUIDED64);</span>

					// AST REWRITE
					// elements: GUIDED
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3815">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3818">					root_0 = (Object)adaptor.nil();</span>
					// 204:12: -&gt; ^( GUIDED )
					{
						// OmpParser.g:204:15: ^( GUIDED )
						{
<span class="nc" id="L3823">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3824">						root_1 = (Object)adaptor.becomeRoot(stream_GUIDED.nextNode(), root_1);</span>
<span class="nc" id="L3825">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3831">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3834">					break;</span>
				case 4 :
					// OmpParser.g:205:5: RUNTIME
					{
<span class="nc" id="L3838">					RUNTIME65=(Token)match(input,RUNTIME,FOLLOW_RUNTIME_in_schedule_kind1089);  </span>
<span class="nc" id="L3839">					stream_RUNTIME.add(RUNTIME65);</span>

					// AST REWRITE
					// elements: RUNTIME
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3848">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L3851">					root_0 = (Object)adaptor.nil();</span>
					// 205:13: -&gt; ^( RUNTIME )
					{
						// OmpParser.g:205:16: ^( RUNTIME )
						{
<span class="nc" id="L3856">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3857">						root_1 = (Object)adaptor.becomeRoot(stream_RUNTIME.nextNode(), root_1);</span>
<span class="nc" id="L3858">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3864">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L3870">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L3872">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L3873">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L3876">		catch (RecognitionException re) {</span>
<span class="nc" id="L3877">			reportError(re);</span>
<span class="nc" id="L3878">			recover(input,re);</span>
<span class="nc" id="L3879">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L3881">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L3883">		}</span>
<span class="nc" id="L3884">		return retval;</span>
	}
	// $ANTLR end &quot;schedule_kind&quot;


<span class="nc" id="L3889">	public static class unique_parallel_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L3892">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;unique_parallel_clause&quot;
	// OmpParser.g:208:1: unique_parallel_clause : (i= if_clause -&gt; ^( UNIQUE_PARALLEL $i) |n= num_threads_clause -&gt; ^( UNIQUE_PARALLEL $n) );
	public final OmpParser.unique_parallel_clause_return unique_parallel_clause() throws RecognitionException {
<span class="nc" id="L3899">		OmpParser.unique_parallel_clause_return retval = new OmpParser.unique_parallel_clause_return();</span>
<span class="nc" id="L3900">		retval.start = input.LT(1);</span>

<span class="nc" id="L3902">		Object root_0 = null;</span>

<span class="nc" id="L3904">		ParserRuleReturnScope i =null;</span>
<span class="nc" id="L3905">		ParserRuleReturnScope n =null;</span>

<span class="nc" id="L3907">		RewriteRuleSubtreeStream stream_if_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule if_clause&quot;);</span>
<span class="nc" id="L3908">		RewriteRuleSubtreeStream stream_num_threads_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule num_threads_clause&quot;);</span>

		try {
			// OmpParser.g:209:3: (i= if_clause -&gt; ^( UNIQUE_PARALLEL $i) |n= num_threads_clause -&gt; ^( UNIQUE_PARALLEL $n) )
<span class="nc" id="L3912">			int alt21=2;</span>
<span class="nc" id="L3913">			int LA21_0 = input.LA(1);</span>
<span class="nc bnc" id="L3914" title="All 2 branches missed.">			if ( (LA21_0==IF) ) {</span>
<span class="nc" id="L3915">				alt21=1;</span>
			}
<span class="nc bnc" id="L3917" title="All 2 branches missed.">			else if ( (LA21_0==NUM_THREADS) ) {</span>
<span class="nc" id="L3918">				alt21=2;</span>
			}

			else {
<span class="nc" id="L3922">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 21, 0, input);
<span class="nc" id="L3924">				throw nvae;</span>
			}

<span class="nc bnc" id="L3927" title="All 3 branches missed.">			switch (alt21) {</span>
				case 1 :
					// OmpParser.g:209:5: i= if_clause
					{
<span class="nc" id="L3931">					pushFollow(FOLLOW_if_clause_in_unique_parallel_clause1110);</span>
<span class="nc" id="L3932">					i=if_clause();</span>
<span class="nc" id="L3933">					state._fsp--;</span>

<span class="nc" id="L3935">					stream_if_clause.add(i.getTree());</span>
					// AST REWRITE
					// elements: i
					// token labels: 
					// rule labels: retval, i
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3943">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3944" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_i=new RewriteRuleSubtreeStream(adaptor,&quot;rule i&quot;,i!=null?i.getTree():null);</span>

<span class="nc" id="L3947">					root_0 = (Object)adaptor.nil();</span>
					// 210:5: -&gt; ^( UNIQUE_PARALLEL $i)
					{
						// OmpParser.g:210:8: ^( UNIQUE_PARALLEL $i)
						{
<span class="nc" id="L3952">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3953">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNIQUE_PARALLEL, &quot;UNIQUE_PARALLEL&quot;), root_1);</span>
<span class="nc" id="L3954">						adaptor.addChild(root_1, stream_i.nextTree());</span>
<span class="nc" id="L3955">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3961">					retval.tree = root_0;</span>

					}
<span class="nc" id="L3964">					break;</span>
				case 2 :
					// OmpParser.g:211:5: n= num_threads_clause
					{
<span class="nc" id="L3968">					pushFollow(FOLLOW_num_threads_clause_in_unique_parallel_clause1132);</span>
<span class="nc" id="L3969">					n=num_threads_clause();</span>
<span class="nc" id="L3970">					state._fsp--;</span>

<span class="nc" id="L3972">					stream_num_threads_clause.add(n.getTree());</span>
					// AST REWRITE
					// elements: n
					// token labels: 
					// rule labels: retval, n
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L3980">					retval.tree = root_0;</span>
<span class="nc bnc" id="L3981" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L3982" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_n=new RewriteRuleSubtreeStream(adaptor,&quot;rule n&quot;,n!=null?n.getTree():null);</span>

<span class="nc" id="L3984">					root_0 = (Object)adaptor.nil();</span>
					// 212:5: -&gt; ^( UNIQUE_PARALLEL $n)
					{
						// OmpParser.g:212:8: ^( UNIQUE_PARALLEL $n)
						{
<span class="nc" id="L3989">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L3990">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(UNIQUE_PARALLEL, &quot;UNIQUE_PARALLEL&quot;), root_1);</span>
<span class="nc" id="L3991">						adaptor.addChild(root_1, stream_n.nextTree());</span>
<span class="nc" id="L3992">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L3998">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L4004">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4006">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4007">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4010">		catch (RecognitionException re) {</span>
<span class="nc" id="L4011">			reportError(re);</span>
<span class="nc" id="L4012">			recover(input,re);</span>
<span class="nc" id="L4013">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4015">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4017">		}</span>
<span class="nc" id="L4018">		return retval;</span>
	}
	// $ANTLR end &quot;unique_parallel_clause&quot;


<span class="nc" id="L4023">	public static class if_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4026">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;if_clause&quot;
	// OmpParser.g:215:1: if_clause : IF LPAREN e1= expression RPAREN -&gt; ^( IF $e1) ;
	public final OmpParser.if_clause_return if_clause() throws RecognitionException {
<span class="nc" id="L4033">		OmpParser.if_clause_return retval = new OmpParser.if_clause_return();</span>
<span class="nc" id="L4034">		retval.start = input.LT(1);</span>

<span class="nc" id="L4036">		Object root_0 = null;</span>

<span class="nc" id="L4038">		Token IF66=null;</span>
<span class="nc" id="L4039">		Token LPAREN67=null;</span>
<span class="nc" id="L4040">		Token RPAREN68=null;</span>
<span class="nc" id="L4041">		ParserRuleReturnScope e1 =null;</span>

<span class="nc" id="L4043">		Object IF66_tree=null;</span>
<span class="nc" id="L4044">		Object LPAREN67_tree=null;</span>
<span class="nc" id="L4045">		Object RPAREN68_tree=null;</span>
<span class="nc" id="L4046">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4047">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4048">		RewriteRuleTokenStream stream_IF=new RewriteRuleTokenStream(adaptor,&quot;token IF&quot;);</span>
<span class="nc" id="L4049">		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,&quot;rule expression&quot;);</span>

		try {
			// OmpParser.g:216:3: ( IF LPAREN e1= expression RPAREN -&gt; ^( IF $e1) )
			// OmpParser.g:216:5: IF LPAREN e1= expression RPAREN
			{
<span class="nc" id="L4055">			IF66=(Token)match(input,IF,FOLLOW_IF_in_if_clause1161);  </span>
<span class="nc" id="L4056">			stream_IF.add(IF66);</span>

<span class="nc" id="L4058">			LPAREN67=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_if_clause1164);  </span>
<span class="nc" id="L4059">			stream_LPAREN.add(LPAREN67);</span>

<span class="nc" id="L4061">			pushFollow(FOLLOW_expression_in_if_clause1169);</span>
<span class="nc" id="L4062">			e1=expression();</span>
<span class="nc" id="L4063">			state._fsp--;</span>

<span class="nc" id="L4065">			stream_expression.add(e1.getTree());</span>
<span class="nc" id="L4066">			RPAREN68=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_if_clause1172);  </span>
<span class="nc" id="L4067">			stream_RPAREN.add(RPAREN68);</span>

			// AST REWRITE
			// elements: e1, IF
			// token labels: 
			// rule labels: retval, e1
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4076">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4077" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4078" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_e1=new RewriteRuleSubtreeStream(adaptor,&quot;rule e1&quot;,e1!=null?e1.getTree():null);</span>

<span class="nc" id="L4080">			root_0 = (Object)adaptor.nil();</span>
			// 217:5: -&gt; ^( IF $e1)
			{
				// OmpParser.g:217:8: ^( IF $e1)
				{
<span class="nc" id="L4085">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4086">				root_1 = (Object)adaptor.becomeRoot(stream_IF.nextNode(), root_1);</span>
<span class="nc" id="L4087">				adaptor.addChild(root_1, stream_e1.nextTree());</span>
<span class="nc" id="L4088">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4094">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4098">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4100">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4101">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4104">		catch (RecognitionException re) {</span>
<span class="nc" id="L4105">			reportError(re);</span>
<span class="nc" id="L4106">			recover(input,re);</span>
<span class="nc" id="L4107">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4109">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4111">		}</span>
<span class="nc" id="L4112">		return retval;</span>
	}
	// $ANTLR end &quot;if_clause&quot;


<span class="nc" id="L4117">	public static class num_threads_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4120">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;num_threads_clause&quot;
	// OmpParser.g:220:1: num_threads_clause : NUM_THREADS LPAREN e2= expression RPAREN -&gt; ^( NUM_THREADS $e2) ;
	public final OmpParser.num_threads_clause_return num_threads_clause() throws RecognitionException {
<span class="nc" id="L4127">		OmpParser.num_threads_clause_return retval = new OmpParser.num_threads_clause_return();</span>
<span class="nc" id="L4128">		retval.start = input.LT(1);</span>

<span class="nc" id="L4130">		Object root_0 = null;</span>

<span class="nc" id="L4132">		Token NUM_THREADS69=null;</span>
<span class="nc" id="L4133">		Token LPAREN70=null;</span>
<span class="nc" id="L4134">		Token RPAREN71=null;</span>
<span class="nc" id="L4135">		ParserRuleReturnScope e2 =null;</span>

<span class="nc" id="L4137">		Object NUM_THREADS69_tree=null;</span>
<span class="nc" id="L4138">		Object LPAREN70_tree=null;</span>
<span class="nc" id="L4139">		Object RPAREN71_tree=null;</span>
<span class="nc" id="L4140">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4141">		RewriteRuleTokenStream stream_NUM_THREADS=new RewriteRuleTokenStream(adaptor,&quot;token NUM_THREADS&quot;);</span>
<span class="nc" id="L4142">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4143">		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,&quot;rule expression&quot;);</span>

		try {
			// OmpParser.g:221:3: ( NUM_THREADS LPAREN e2= expression RPAREN -&gt; ^( NUM_THREADS $e2) )
			// OmpParser.g:221:5: NUM_THREADS LPAREN e2= expression RPAREN
			{
<span class="nc" id="L4149">			NUM_THREADS69=(Token)match(input,NUM_THREADS,FOLLOW_NUM_THREADS_in_num_threads_clause1200);  </span>
<span class="nc" id="L4150">			stream_NUM_THREADS.add(NUM_THREADS69);</span>

<span class="nc" id="L4152">			LPAREN70=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_num_threads_clause1203);  </span>
<span class="nc" id="L4153">			stream_LPAREN.add(LPAREN70);</span>

<span class="nc" id="L4155">			pushFollow(FOLLOW_expression_in_num_threads_clause1208);</span>
<span class="nc" id="L4156">			e2=expression();</span>
<span class="nc" id="L4157">			state._fsp--;</span>

<span class="nc" id="L4159">			stream_expression.add(e2.getTree());</span>
<span class="nc" id="L4160">			RPAREN71=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_num_threads_clause1211);  </span>
<span class="nc" id="L4161">			stream_RPAREN.add(RPAREN71);</span>

			// AST REWRITE
			// elements: NUM_THREADS, e2
			// token labels: 
			// rule labels: retval, e2
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4170">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_e2=new RewriteRuleSubtreeStream(adaptor,&quot;rule e2&quot;,e2!=null?e2.getTree():null);</span>

<span class="nc" id="L4174">			root_0 = (Object)adaptor.nil();</span>
			// 222:5: -&gt; ^( NUM_THREADS $e2)
			{
				// OmpParser.g:222:8: ^( NUM_THREADS $e2)
				{
<span class="nc" id="L4179">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4180">				root_1 = (Object)adaptor.becomeRoot(stream_NUM_THREADS.nextNode(), root_1);</span>
<span class="nc" id="L4181">				adaptor.addChild(root_1, stream_e2.nextTree());</span>
<span class="nc" id="L4182">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4188">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4192">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4194">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4195">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4198">		catch (RecognitionException re) {</span>
<span class="nc" id="L4199">			reportError(re);</span>
<span class="nc" id="L4200">			recover(input,re);</span>
<span class="nc" id="L4201">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4203">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4205">		}</span>
<span class="nc" id="L4206">		return retval;</span>
	}
	// $ANTLR end &quot;num_threads_clause&quot;


<span class="nc" id="L4211">	public static class data_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4214">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;data_clause&quot;
	// OmpParser.g:225:1: data_clause : (d1= private_clause -&gt; ^( DATA_CLAUSE $d1) |d2= firstprivate_clause -&gt; ^( DATA_CLAUSE $d2) |d3= lastprivate_clause -&gt; ^( DATA_CLAUSE $d3) |d4= shared_clause -&gt; ^( DATA_CLAUSE $d4) |d5= default_clause -&gt; ^( DATA_CLAUSE $d5) |d6= reduction_clause -&gt; ^( DATA_CLAUSE $d6) |d7= copyin_clause -&gt; ^( DATA_CLAUSE $d7) |d8= copyprivate_clause -&gt; ^( DATA_CLAUSE $d8) );
	public final OmpParser.data_clause_return data_clause() throws RecognitionException {
<span class="nc" id="L4221">		OmpParser.data_clause_return retval = new OmpParser.data_clause_return();</span>
<span class="nc" id="L4222">		retval.start = input.LT(1);</span>

<span class="nc" id="L4224">		Object root_0 = null;</span>

<span class="nc" id="L4226">		ParserRuleReturnScope d1 =null;</span>
<span class="nc" id="L4227">		ParserRuleReturnScope d2 =null;</span>
<span class="nc" id="L4228">		ParserRuleReturnScope d3 =null;</span>
<span class="nc" id="L4229">		ParserRuleReturnScope d4 =null;</span>
<span class="nc" id="L4230">		ParserRuleReturnScope d5 =null;</span>
<span class="nc" id="L4231">		ParserRuleReturnScope d6 =null;</span>
<span class="nc" id="L4232">		ParserRuleReturnScope d7 =null;</span>
<span class="nc" id="L4233">		ParserRuleReturnScope d8 =null;</span>

<span class="nc" id="L4235">		RewriteRuleSubtreeStream stream_copyin_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule copyin_clause&quot;);</span>
<span class="nc" id="L4236">		RewriteRuleSubtreeStream stream_firstprivate_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule firstprivate_clause&quot;);</span>
<span class="nc" id="L4237">		RewriteRuleSubtreeStream stream_lastprivate_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule lastprivate_clause&quot;);</span>
<span class="nc" id="L4238">		RewriteRuleSubtreeStream stream_default_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule default_clause&quot;);</span>
<span class="nc" id="L4239">		RewriteRuleSubtreeStream stream_shared_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule shared_clause&quot;);</span>
<span class="nc" id="L4240">		RewriteRuleSubtreeStream stream_copyprivate_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule copyprivate_clause&quot;);</span>
<span class="nc" id="L4241">		RewriteRuleSubtreeStream stream_private_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule private_clause&quot;);</span>
<span class="nc" id="L4242">		RewriteRuleSubtreeStream stream_reduction_clause=new RewriteRuleSubtreeStream(adaptor,&quot;rule reduction_clause&quot;);</span>

		try {
			// OmpParser.g:226:3: (d1= private_clause -&gt; ^( DATA_CLAUSE $d1) |d2= firstprivate_clause -&gt; ^( DATA_CLAUSE $d2) |d3= lastprivate_clause -&gt; ^( DATA_CLAUSE $d3) |d4= shared_clause -&gt; ^( DATA_CLAUSE $d4) |d5= default_clause -&gt; ^( DATA_CLAUSE $d5) |d6= reduction_clause -&gt; ^( DATA_CLAUSE $d6) |d7= copyin_clause -&gt; ^( DATA_CLAUSE $d7) |d8= copyprivate_clause -&gt; ^( DATA_CLAUSE $d8) )
<span class="nc" id="L4246">			int alt22=8;</span>
<span class="nc bnc" id="L4247" title="All 9 branches missed.">			switch ( input.LA(1) ) {</span>
			case PRIVATE:
				{
<span class="nc" id="L4250">				alt22=1;</span>
				}
<span class="nc" id="L4252">				break;</span>
			case FST_PRIVATE:
				{
<span class="nc" id="L4255">				alt22=2;</span>
				}
<span class="nc" id="L4257">				break;</span>
			case LST_PRIVATE:
				{
<span class="nc" id="L4260">				alt22=3;</span>
				}
<span class="nc" id="L4262">				break;</span>
			case SHARED:
				{
<span class="nc" id="L4265">				alt22=4;</span>
				}
<span class="nc" id="L4267">				break;</span>
			case DEFAULT:
				{
<span class="nc" id="L4270">				alt22=5;</span>
				}
<span class="nc" id="L4272">				break;</span>
			case REDUCTION:
				{
<span class="nc" id="L4275">				alt22=6;</span>
				}
<span class="nc" id="L4277">				break;</span>
			case COPYIN:
				{
<span class="nc" id="L4280">				alt22=7;</span>
				}
<span class="nc" id="L4282">				break;</span>
			case COPYPRIVATE:
				{
<span class="nc" id="L4285">				alt22=8;</span>
				}
<span class="nc" id="L4287">				break;</span>
			default:
<span class="nc" id="L4289">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 22, 0, input);
<span class="nc" id="L4291">				throw nvae;</span>
			}
<span class="nc bnc" id="L4293" title="All 9 branches missed.">			switch (alt22) {</span>
				case 1 :
					// OmpParser.g:226:5: d1= private_clause
					{
<span class="nc" id="L4297">					pushFollow(FOLLOW_private_clause_in_data_clause1239);</span>
<span class="nc" id="L4298">					d1=private_clause();</span>
<span class="nc" id="L4299">					state._fsp--;</span>

<span class="nc" id="L4301">					stream_private_clause.add(d1.getTree());</span>
					// AST REWRITE
					// elements: d1
					// token labels: 
					// rule labels: d1, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4309">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4310" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d1=new RewriteRuleSubtreeStream(adaptor,&quot;rule d1&quot;,d1!=null?d1.getTree():null);</span>
<span class="nc bnc" id="L4311" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L4313">					root_0 = (Object)adaptor.nil();</span>
					// 227:5: -&gt; ^( DATA_CLAUSE $d1)
					{
						// OmpParser.g:227:8: ^( DATA_CLAUSE $d1)
						{
<span class="nc" id="L4318">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4319">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4320">						adaptor.addChild(root_1, stream_d1.nextTree());</span>
<span class="nc" id="L4321">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4327">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4330">					break;</span>
				case 2 :
					// OmpParser.g:228:5: d2= firstprivate_clause
					{
<span class="nc" id="L4334">					pushFollow(FOLLOW_firstprivate_clause_in_data_clause1260);</span>
<span class="nc" id="L4335">					d2=firstprivate_clause();</span>
<span class="nc" id="L4336">					state._fsp--;</span>

<span class="nc" id="L4338">					stream_firstprivate_clause.add(d2.getTree());</span>
					// AST REWRITE
					// elements: d2
					// token labels: 
					// rule labels: retval, d2
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4346">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4347" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4348" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d2=new RewriteRuleSubtreeStream(adaptor,&quot;rule d2&quot;,d2!=null?d2.getTree():null);</span>

<span class="nc" id="L4350">					root_0 = (Object)adaptor.nil();</span>
					// 229:5: -&gt; ^( DATA_CLAUSE $d2)
					{
						// OmpParser.g:229:8: ^( DATA_CLAUSE $d2)
						{
<span class="nc" id="L4355">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4356">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4357">						adaptor.addChild(root_1, stream_d2.nextTree());</span>
<span class="nc" id="L4358">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4364">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4367">					break;</span>
				case 3 :
					// OmpParser.g:230:5: d3= lastprivate_clause
					{
<span class="nc" id="L4371">					pushFollow(FOLLOW_lastprivate_clause_in_data_clause1281);</span>
<span class="nc" id="L4372">					d3=lastprivate_clause();</span>
<span class="nc" id="L4373">					state._fsp--;</span>

<span class="nc" id="L4375">					stream_lastprivate_clause.add(d3.getTree());</span>
					// AST REWRITE
					// elements: d3
					// token labels: 
					// rule labels: retval, d3
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4383">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4384" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4385" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d3=new RewriteRuleSubtreeStream(adaptor,&quot;rule d3&quot;,d3!=null?d3.getTree():null);</span>

<span class="nc" id="L4387">					root_0 = (Object)adaptor.nil();</span>
					// 231:5: -&gt; ^( DATA_CLAUSE $d3)
					{
						// OmpParser.g:231:8: ^( DATA_CLAUSE $d3)
						{
<span class="nc" id="L4392">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4393">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4394">						adaptor.addChild(root_1, stream_d3.nextTree());</span>
<span class="nc" id="L4395">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4401">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4404">					break;</span>
				case 4 :
					// OmpParser.g:232:5: d4= shared_clause
					{
<span class="nc" id="L4408">					pushFollow(FOLLOW_shared_clause_in_data_clause1302);</span>
<span class="nc" id="L4409">					d4=shared_clause();</span>
<span class="nc" id="L4410">					state._fsp--;</span>

<span class="nc" id="L4412">					stream_shared_clause.add(d4.getTree());</span>
					// AST REWRITE
					// elements: d4
					// token labels: 
					// rule labels: retval, d4
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4420">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4421" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4422" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d4=new RewriteRuleSubtreeStream(adaptor,&quot;rule d4&quot;,d4!=null?d4.getTree():null);</span>

<span class="nc" id="L4424">					root_0 = (Object)adaptor.nil();</span>
					// 233:5: -&gt; ^( DATA_CLAUSE $d4)
					{
						// OmpParser.g:233:8: ^( DATA_CLAUSE $d4)
						{
<span class="nc" id="L4429">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4430">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4431">						adaptor.addChild(root_1, stream_d4.nextTree());</span>
<span class="nc" id="L4432">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4438">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4441">					break;</span>
				case 5 :
					// OmpParser.g:234:5: d5= default_clause
					{
<span class="nc" id="L4445">					pushFollow(FOLLOW_default_clause_in_data_clause1323);</span>
<span class="nc" id="L4446">					d5=default_clause();</span>
<span class="nc" id="L4447">					state._fsp--;</span>

<span class="nc" id="L4449">					stream_default_clause.add(d5.getTree());</span>
					// AST REWRITE
					// elements: d5
					// token labels: 
					// rule labels: retval, d5
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4457">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4458" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4459" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d5=new RewriteRuleSubtreeStream(adaptor,&quot;rule d5&quot;,d5!=null?d5.getTree():null);</span>

<span class="nc" id="L4461">					root_0 = (Object)adaptor.nil();</span>
					// 235:5: -&gt; ^( DATA_CLAUSE $d5)
					{
						// OmpParser.g:235:8: ^( DATA_CLAUSE $d5)
						{
<span class="nc" id="L4466">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4467">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4468">						adaptor.addChild(root_1, stream_d5.nextTree());</span>
<span class="nc" id="L4469">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4475">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4478">					break;</span>
				case 6 :
					// OmpParser.g:236:5: d6= reduction_clause
					{
<span class="nc" id="L4482">					pushFollow(FOLLOW_reduction_clause_in_data_clause1344);</span>
<span class="nc" id="L4483">					d6=reduction_clause();</span>
<span class="nc" id="L4484">					state._fsp--;</span>

<span class="nc" id="L4486">					stream_reduction_clause.add(d6.getTree());</span>
					// AST REWRITE
					// elements: d6
					// token labels: 
					// rule labels: retval, d6
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4494">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4495" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d6=new RewriteRuleSubtreeStream(adaptor,&quot;rule d6&quot;,d6!=null?d6.getTree():null);</span>

<span class="nc" id="L4498">					root_0 = (Object)adaptor.nil();</span>
					// 237:5: -&gt; ^( DATA_CLAUSE $d6)
					{
						// OmpParser.g:237:8: ^( DATA_CLAUSE $d6)
						{
<span class="nc" id="L4503">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4504">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4505">						adaptor.addChild(root_1, stream_d6.nextTree());</span>
<span class="nc" id="L4506">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4512">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4515">					break;</span>
				case 7 :
					// OmpParser.g:238:5: d7= copyin_clause
					{
<span class="nc" id="L4519">					pushFollow(FOLLOW_copyin_clause_in_data_clause1365);</span>
<span class="nc" id="L4520">					d7=copyin_clause();</span>
<span class="nc" id="L4521">					state._fsp--;</span>

<span class="nc" id="L4523">					stream_copyin_clause.add(d7.getTree());</span>
					// AST REWRITE
					// elements: d7
					// token labels: 
					// rule labels: retval, d7
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4531">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4533" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d7=new RewriteRuleSubtreeStream(adaptor,&quot;rule d7&quot;,d7!=null?d7.getTree():null);</span>

<span class="nc" id="L4535">					root_0 = (Object)adaptor.nil();</span>
					// 239:5: -&gt; ^( DATA_CLAUSE $d7)
					{
						// OmpParser.g:239:8: ^( DATA_CLAUSE $d7)
						{
<span class="nc" id="L4540">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4541">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4542">						adaptor.addChild(root_1, stream_d7.nextTree());</span>
<span class="nc" id="L4543">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4549">					retval.tree = root_0;</span>

					}
<span class="nc" id="L4552">					break;</span>
				case 8 :
					// OmpParser.g:240:5: d8= copyprivate_clause
					{
<span class="nc" id="L4556">					pushFollow(FOLLOW_copyprivate_clause_in_data_clause1386);</span>
<span class="nc" id="L4557">					d8=copyprivate_clause();</span>
<span class="nc" id="L4558">					state._fsp--;</span>

<span class="nc" id="L4560">					stream_copyprivate_clause.add(d8.getTree());</span>
					// AST REWRITE
					// elements: d8
					// token labels: 
					// rule labels: retval, d8
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L4568">					retval.tree = root_0;</span>
<span class="nc bnc" id="L4569" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4570" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_d8=new RewriteRuleSubtreeStream(adaptor,&quot;rule d8&quot;,d8!=null?d8.getTree():null);</span>

<span class="nc" id="L4572">					root_0 = (Object)adaptor.nil();</span>
					// 241:5: -&gt; ^( DATA_CLAUSE $d8)
					{
						// OmpParser.g:241:8: ^( DATA_CLAUSE $d8)
						{
<span class="nc" id="L4577">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4578">						root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(DATA_CLAUSE, &quot;DATA_CLAUSE&quot;), root_1);</span>
<span class="nc" id="L4579">						adaptor.addChild(root_1, stream_d8.nextTree());</span>
<span class="nc" id="L4580">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L4586">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L4592">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4594">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4595">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4598">		catch (RecognitionException re) {</span>
<span class="nc" id="L4599">			reportError(re);</span>
<span class="nc" id="L4600">			recover(input,re);</span>
<span class="nc" id="L4601">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4603">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4605">		}</span>
<span class="nc" id="L4606">		return retval;</span>
	}
	// $ANTLR end &quot;data_clause&quot;


<span class="nc" id="L4611">	public static class private_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4614">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;private_clause&quot;
	// OmpParser.g:244:1: private_clause : PRIVATE LPAREN i1= identifier_list RPAREN -&gt; ^( PRIVATE $i1) ;
	public final OmpParser.private_clause_return private_clause() throws RecognitionException {
<span class="nc" id="L4621">		OmpParser.private_clause_return retval = new OmpParser.private_clause_return();</span>
<span class="nc" id="L4622">		retval.start = input.LT(1);</span>

<span class="nc" id="L4624">		Object root_0 = null;</span>

<span class="nc" id="L4626">		Token PRIVATE72=null;</span>
<span class="nc" id="L4627">		Token LPAREN73=null;</span>
<span class="nc" id="L4628">		Token RPAREN74=null;</span>
<span class="nc" id="L4629">		ParserRuleReturnScope i1 =null;</span>

<span class="nc" id="L4631">		Object PRIVATE72_tree=null;</span>
<span class="nc" id="L4632">		Object LPAREN73_tree=null;</span>
<span class="nc" id="L4633">		Object RPAREN74_tree=null;</span>
<span class="nc" id="L4634">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4635">		RewriteRuleTokenStream stream_PRIVATE=new RewriteRuleTokenStream(adaptor,&quot;token PRIVATE&quot;);</span>
<span class="nc" id="L4636">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4637">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:245:3: ( PRIVATE LPAREN i1= identifier_list RPAREN -&gt; ^( PRIVATE $i1) )
			// OmpParser.g:245:5: PRIVATE LPAREN i1= identifier_list RPAREN
			{
<span class="nc" id="L4643">			PRIVATE72=(Token)match(input,PRIVATE,FOLLOW_PRIVATE_in_private_clause1414);  </span>
<span class="nc" id="L4644">			stream_PRIVATE.add(PRIVATE72);</span>

<span class="nc" id="L4646">			LPAREN73=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_private_clause1417);  </span>
<span class="nc" id="L4647">			stream_LPAREN.add(LPAREN73);</span>

<span class="nc" id="L4649">			pushFollow(FOLLOW_identifier_list_in_private_clause1422);</span>
<span class="nc" id="L4650">			i1=identifier_list();</span>
<span class="nc" id="L4651">			state._fsp--;</span>

<span class="nc" id="L4653">			stream_identifier_list.add(i1.getTree());</span>
<span class="nc" id="L4654">			RPAREN74=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_private_clause1425);  </span>
<span class="nc" id="L4655">			stream_RPAREN.add(RPAREN74);</span>

			// AST REWRITE
			// elements: i1, PRIVATE
			// token labels: 
			// rule labels: retval, i1
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4664">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4665" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4666" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i1=new RewriteRuleSubtreeStream(adaptor,&quot;rule i1&quot;,i1!=null?i1.getTree():null);</span>

<span class="nc" id="L4668">			root_0 = (Object)adaptor.nil();</span>
			// 246:5: -&gt; ^( PRIVATE $i1)
			{
				// OmpParser.g:246:8: ^( PRIVATE $i1)
				{
<span class="nc" id="L4673">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4674">				root_1 = (Object)adaptor.becomeRoot(stream_PRIVATE.nextNode(), root_1);</span>
<span class="nc" id="L4675">				adaptor.addChild(root_1, stream_i1.nextTree());</span>
<span class="nc" id="L4676">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4682">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4686">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4688">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4689">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4692">		catch (RecognitionException re) {</span>
<span class="nc" id="L4693">			reportError(re);</span>
<span class="nc" id="L4694">			recover(input,re);</span>
<span class="nc" id="L4695">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4697">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4699">		}</span>
<span class="nc" id="L4700">		return retval;</span>
	}
	// $ANTLR end &quot;private_clause&quot;


<span class="nc" id="L4705">	public static class firstprivate_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4708">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;firstprivate_clause&quot;
	// OmpParser.g:249:1: firstprivate_clause : FST_PRIVATE LPAREN i2= identifier_list RPAREN -&gt; ^( FST_PRIVATE $i2) ;
	public final OmpParser.firstprivate_clause_return firstprivate_clause() throws RecognitionException {
<span class="nc" id="L4715">		OmpParser.firstprivate_clause_return retval = new OmpParser.firstprivate_clause_return();</span>
<span class="nc" id="L4716">		retval.start = input.LT(1);</span>

<span class="nc" id="L4718">		Object root_0 = null;</span>

<span class="nc" id="L4720">		Token FST_PRIVATE75=null;</span>
<span class="nc" id="L4721">		Token LPAREN76=null;</span>
<span class="nc" id="L4722">		Token RPAREN77=null;</span>
<span class="nc" id="L4723">		ParserRuleReturnScope i2 =null;</span>

<span class="nc" id="L4725">		Object FST_PRIVATE75_tree=null;</span>
<span class="nc" id="L4726">		Object LPAREN76_tree=null;</span>
<span class="nc" id="L4727">		Object RPAREN77_tree=null;</span>
<span class="nc" id="L4728">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4729">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4730">		RewriteRuleTokenStream stream_FST_PRIVATE=new RewriteRuleTokenStream(adaptor,&quot;token FST_PRIVATE&quot;);</span>
<span class="nc" id="L4731">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:250:3: ( FST_PRIVATE LPAREN i2= identifier_list RPAREN -&gt; ^( FST_PRIVATE $i2) )
			// OmpParser.g:250:5: FST_PRIVATE LPAREN i2= identifier_list RPAREN
			{
<span class="nc" id="L4737">			FST_PRIVATE75=(Token)match(input,FST_PRIVATE,FOLLOW_FST_PRIVATE_in_firstprivate_clause1454);  </span>
<span class="nc" id="L4738">			stream_FST_PRIVATE.add(FST_PRIVATE75);</span>

<span class="nc" id="L4740">			LPAREN76=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_firstprivate_clause1457);  </span>
<span class="nc" id="L4741">			stream_LPAREN.add(LPAREN76);</span>

<span class="nc" id="L4743">			pushFollow(FOLLOW_identifier_list_in_firstprivate_clause1462);</span>
<span class="nc" id="L4744">			i2=identifier_list();</span>
<span class="nc" id="L4745">			state._fsp--;</span>

<span class="nc" id="L4747">			stream_identifier_list.add(i2.getTree());</span>
<span class="nc" id="L4748">			RPAREN77=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_firstprivate_clause1465);  </span>
<span class="nc" id="L4749">			stream_RPAREN.add(RPAREN77);</span>

			// AST REWRITE
			// elements: FST_PRIVATE, i2
			// token labels: 
			// rule labels: retval, i2
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4758">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4759" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4760" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i2=new RewriteRuleSubtreeStream(adaptor,&quot;rule i2&quot;,i2!=null?i2.getTree():null);</span>

<span class="nc" id="L4762">			root_0 = (Object)adaptor.nil();</span>
			// 251:5: -&gt; ^( FST_PRIVATE $i2)
			{
				// OmpParser.g:251:8: ^( FST_PRIVATE $i2)
				{
<span class="nc" id="L4767">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4768">				root_1 = (Object)adaptor.becomeRoot(stream_FST_PRIVATE.nextNode(), root_1);</span>
<span class="nc" id="L4769">				adaptor.addChild(root_1, stream_i2.nextTree());</span>
<span class="nc" id="L4770">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4776">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4780">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4782">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4783">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4786">		catch (RecognitionException re) {</span>
<span class="nc" id="L4787">			reportError(re);</span>
<span class="nc" id="L4788">			recover(input,re);</span>
<span class="nc" id="L4789">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4791">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4793">		}</span>
<span class="nc" id="L4794">		return retval;</span>
	}
	// $ANTLR end &quot;firstprivate_clause&quot;


<span class="nc" id="L4799">	public static class lastprivate_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4802">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;lastprivate_clause&quot;
	// OmpParser.g:254:1: lastprivate_clause : LST_PRIVATE LPAREN i3= identifier_list RPAREN -&gt; ^( LST_PRIVATE $i3) ;
	public final OmpParser.lastprivate_clause_return lastprivate_clause() throws RecognitionException {
<span class="nc" id="L4809">		OmpParser.lastprivate_clause_return retval = new OmpParser.lastprivate_clause_return();</span>
<span class="nc" id="L4810">		retval.start = input.LT(1);</span>

<span class="nc" id="L4812">		Object root_0 = null;</span>

<span class="nc" id="L4814">		Token LST_PRIVATE78=null;</span>
<span class="nc" id="L4815">		Token LPAREN79=null;</span>
<span class="nc" id="L4816">		Token RPAREN80=null;</span>
<span class="nc" id="L4817">		ParserRuleReturnScope i3 =null;</span>

<span class="nc" id="L4819">		Object LST_PRIVATE78_tree=null;</span>
<span class="nc" id="L4820">		Object LPAREN79_tree=null;</span>
<span class="nc" id="L4821">		Object RPAREN80_tree=null;</span>
<span class="nc" id="L4822">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4823">		RewriteRuleTokenStream stream_LST_PRIVATE=new RewriteRuleTokenStream(adaptor,&quot;token LST_PRIVATE&quot;);</span>
<span class="nc" id="L4824">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4825">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:255:3: ( LST_PRIVATE LPAREN i3= identifier_list RPAREN -&gt; ^( LST_PRIVATE $i3) )
			// OmpParser.g:255:5: LST_PRIVATE LPAREN i3= identifier_list RPAREN
			{
<span class="nc" id="L4831">			LST_PRIVATE78=(Token)match(input,LST_PRIVATE,FOLLOW_LST_PRIVATE_in_lastprivate_clause1493);  </span>
<span class="nc" id="L4832">			stream_LST_PRIVATE.add(LST_PRIVATE78);</span>

<span class="nc" id="L4834">			LPAREN79=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_lastprivate_clause1496);  </span>
<span class="nc" id="L4835">			stream_LPAREN.add(LPAREN79);</span>

<span class="nc" id="L4837">			pushFollow(FOLLOW_identifier_list_in_lastprivate_clause1501);</span>
<span class="nc" id="L4838">			i3=identifier_list();</span>
<span class="nc" id="L4839">			state._fsp--;</span>

<span class="nc" id="L4841">			stream_identifier_list.add(i3.getTree());</span>
<span class="nc" id="L4842">			RPAREN80=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_lastprivate_clause1504);  </span>
<span class="nc" id="L4843">			stream_RPAREN.add(RPAREN80);</span>

			// AST REWRITE
			// elements: i3, LST_PRIVATE
			// token labels: 
			// rule labels: retval, i3
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4852">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4853" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4854" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i3=new RewriteRuleSubtreeStream(adaptor,&quot;rule i3&quot;,i3!=null?i3.getTree():null);</span>

<span class="nc" id="L4856">			root_0 = (Object)adaptor.nil();</span>
			// 256:5: -&gt; ^( LST_PRIVATE $i3)
			{
				// OmpParser.g:256:8: ^( LST_PRIVATE $i3)
				{
<span class="nc" id="L4861">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4862">				root_1 = (Object)adaptor.becomeRoot(stream_LST_PRIVATE.nextNode(), root_1);</span>
<span class="nc" id="L4863">				adaptor.addChild(root_1, stream_i3.nextTree());</span>
<span class="nc" id="L4864">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4870">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4874">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4876">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4877">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4880">		catch (RecognitionException re) {</span>
<span class="nc" id="L4881">			reportError(re);</span>
<span class="nc" id="L4882">			recover(input,re);</span>
<span class="nc" id="L4883">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4885">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4887">		}</span>
<span class="nc" id="L4888">		return retval;</span>
	}
	// $ANTLR end &quot;lastprivate_clause&quot;


<span class="nc" id="L4893">	public static class shared_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4896">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;shared_clause&quot;
	// OmpParser.g:259:1: shared_clause : SHARED LPAREN i4= identifier_list RPAREN -&gt; ^( SHARED $i4) ;
	public final OmpParser.shared_clause_return shared_clause() throws RecognitionException {
<span class="nc" id="L4903">		OmpParser.shared_clause_return retval = new OmpParser.shared_clause_return();</span>
<span class="nc" id="L4904">		retval.start = input.LT(1);</span>

<span class="nc" id="L4906">		Object root_0 = null;</span>

<span class="nc" id="L4908">		Token SHARED81=null;</span>
<span class="nc" id="L4909">		Token LPAREN82=null;</span>
<span class="nc" id="L4910">		Token RPAREN83=null;</span>
<span class="nc" id="L4911">		ParserRuleReturnScope i4 =null;</span>

<span class="nc" id="L4913">		Object SHARED81_tree=null;</span>
<span class="nc" id="L4914">		Object LPAREN82_tree=null;</span>
<span class="nc" id="L4915">		Object RPAREN83_tree=null;</span>
<span class="nc" id="L4916">		RewriteRuleTokenStream stream_SHARED=new RewriteRuleTokenStream(adaptor,&quot;token SHARED&quot;);</span>
<span class="nc" id="L4917">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L4918">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L4919">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:260:3: ( SHARED LPAREN i4= identifier_list RPAREN -&gt; ^( SHARED $i4) )
			// OmpParser.g:260:5: SHARED LPAREN i4= identifier_list RPAREN
			{
<span class="nc" id="L4925">			SHARED81=(Token)match(input,SHARED,FOLLOW_SHARED_in_shared_clause1532);  </span>
<span class="nc" id="L4926">			stream_SHARED.add(SHARED81);</span>

<span class="nc" id="L4928">			LPAREN82=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_shared_clause1535);  </span>
<span class="nc" id="L4929">			stream_LPAREN.add(LPAREN82);</span>

<span class="nc" id="L4931">			pushFollow(FOLLOW_identifier_list_in_shared_clause1540);</span>
<span class="nc" id="L4932">			i4=identifier_list();</span>
<span class="nc" id="L4933">			state._fsp--;</span>

<span class="nc" id="L4935">			stream_identifier_list.add(i4.getTree());</span>
<span class="nc" id="L4936">			RPAREN83=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_shared_clause1543);  </span>
<span class="nc" id="L4937">			stream_RPAREN.add(RPAREN83);</span>

			// AST REWRITE
			// elements: i4, SHARED
			// token labels: 
			// rule labels: retval, i4
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L4946">			retval.tree = root_0;</span>
<span class="nc bnc" id="L4947" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L4948" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i4=new RewriteRuleSubtreeStream(adaptor,&quot;rule i4&quot;,i4!=null?i4.getTree():null);</span>

<span class="nc" id="L4950">			root_0 = (Object)adaptor.nil();</span>
			// 261:5: -&gt; ^( SHARED $i4)
			{
				// OmpParser.g:261:8: ^( SHARED $i4)
				{
<span class="nc" id="L4955">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L4956">				root_1 = (Object)adaptor.becomeRoot(stream_SHARED.nextNode(), root_1);</span>
<span class="nc" id="L4957">				adaptor.addChild(root_1, stream_i4.nextTree());</span>
<span class="nc" id="L4958">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L4964">			retval.tree = root_0;</span>

			}

<span class="nc" id="L4968">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L4970">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L4971">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L4974">		catch (RecognitionException re) {</span>
<span class="nc" id="L4975">			reportError(re);</span>
<span class="nc" id="L4976">			recover(input,re);</span>
<span class="nc" id="L4977">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L4979">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L4981">		}</span>
<span class="nc" id="L4982">		return retval;</span>
	}
	// $ANTLR end &quot;shared_clause&quot;


<span class="nc" id="L4987">	public static class default_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L4990">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;default_clause&quot;
	// OmpParser.g:264:1: default_clause : ( DEFAULT LPAREN SHARED RPAREN -&gt; ^( DEFAULT SHARED ) | DEFAULT LPAREN NONE RPAREN -&gt; ^( DEFAULT NONE ) );
	public final OmpParser.default_clause_return default_clause() throws RecognitionException {
<span class="nc" id="L4997">		OmpParser.default_clause_return retval = new OmpParser.default_clause_return();</span>
<span class="nc" id="L4998">		retval.start = input.LT(1);</span>

<span class="nc" id="L5000">		Object root_0 = null;</span>

<span class="nc" id="L5002">		Token DEFAULT84=null;</span>
<span class="nc" id="L5003">		Token LPAREN85=null;</span>
<span class="nc" id="L5004">		Token SHARED86=null;</span>
<span class="nc" id="L5005">		Token RPAREN87=null;</span>
<span class="nc" id="L5006">		Token DEFAULT88=null;</span>
<span class="nc" id="L5007">		Token LPAREN89=null;</span>
<span class="nc" id="L5008">		Token NONE90=null;</span>
<span class="nc" id="L5009">		Token RPAREN91=null;</span>

<span class="nc" id="L5011">		Object DEFAULT84_tree=null;</span>
<span class="nc" id="L5012">		Object LPAREN85_tree=null;</span>
<span class="nc" id="L5013">		Object SHARED86_tree=null;</span>
<span class="nc" id="L5014">		Object RPAREN87_tree=null;</span>
<span class="nc" id="L5015">		Object DEFAULT88_tree=null;</span>
<span class="nc" id="L5016">		Object LPAREN89_tree=null;</span>
<span class="nc" id="L5017">		Object NONE90_tree=null;</span>
<span class="nc" id="L5018">		Object RPAREN91_tree=null;</span>
<span class="nc" id="L5019">		RewriteRuleTokenStream stream_SHARED=new RewriteRuleTokenStream(adaptor,&quot;token SHARED&quot;);</span>
<span class="nc" id="L5020">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5021">		RewriteRuleTokenStream stream_NONE=new RewriteRuleTokenStream(adaptor,&quot;token NONE&quot;);</span>
<span class="nc" id="L5022">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5023">		RewriteRuleTokenStream stream_DEFAULT=new RewriteRuleTokenStream(adaptor,&quot;token DEFAULT&quot;);</span>

		try {
			// OmpParser.g:265:3: ( DEFAULT LPAREN SHARED RPAREN -&gt; ^( DEFAULT SHARED ) | DEFAULT LPAREN NONE RPAREN -&gt; ^( DEFAULT NONE ) )
<span class="nc" id="L5027">			int alt23=2;</span>
<span class="nc" id="L5028">			int LA23_0 = input.LA(1);</span>
<span class="nc bnc" id="L5029" title="All 2 branches missed.">			if ( (LA23_0==DEFAULT) ) {</span>
<span class="nc" id="L5030">				int LA23_1 = input.LA(2);</span>
<span class="nc bnc" id="L5031" title="All 2 branches missed.">				if ( (LA23_1==LPAREN) ) {</span>
<span class="nc" id="L5032">					int LA23_2 = input.LA(3);</span>
<span class="nc bnc" id="L5033" title="All 2 branches missed.">					if ( (LA23_2==SHARED) ) {</span>
<span class="nc" id="L5034">						alt23=1;</span>
					}
<span class="nc bnc" id="L5036" title="All 2 branches missed.">					else if ( (LA23_2==NONE) ) {</span>
<span class="nc" id="L5037">						alt23=2;</span>
					}

					else {
<span class="nc" id="L5041">						int nvaeMark = input.mark();</span>
						try {
<span class="nc bnc" id="L5043" title="All 2 branches missed.">							for (int nvaeConsume = 0; nvaeConsume &lt; 3 - 1; nvaeConsume++) {</span>
<span class="nc" id="L5044">								input.consume();</span>
							}
<span class="nc" id="L5046">							NoViableAltException nvae =</span>
								new NoViableAltException(&quot;&quot;, 23, 2, input);
<span class="nc" id="L5048">							throw nvae;</span>
						} finally {
<span class="nc" id="L5050">							input.rewind(nvaeMark);</span>
						}
					}

<span class="nc" id="L5054">				}</span>

				else {
<span class="nc" id="L5057">					int nvaeMark = input.mark();</span>
					try {
<span class="nc" id="L5059">						input.consume();</span>
<span class="nc" id="L5060">						NoViableAltException nvae =</span>
							new NoViableAltException(&quot;&quot;, 23, 1, input);
<span class="nc" id="L5062">						throw nvae;</span>
					} finally {
<span class="nc" id="L5064">						input.rewind(nvaeMark);</span>
					}
				}

<span class="nc" id="L5068">			}</span>

			else {
<span class="nc" id="L5071">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 23, 0, input);
<span class="nc" id="L5073">				throw nvae;</span>
			}

<span class="nc bnc" id="L5076" title="All 3 branches missed.">			switch (alt23) {</span>
				case 1 :
					// OmpParser.g:265:5: DEFAULT LPAREN SHARED RPAREN
					{
<span class="nc" id="L5080">					DEFAULT84=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_default_clause1571);  </span>
<span class="nc" id="L5081">					stream_DEFAULT.add(DEFAULT84);</span>

<span class="nc" id="L5083">					LPAREN85=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_default_clause1574);  </span>
<span class="nc" id="L5084">					stream_LPAREN.add(LPAREN85);</span>

<span class="nc" id="L5086">					SHARED86=(Token)match(input,SHARED,FOLLOW_SHARED_in_default_clause1577);  </span>
<span class="nc" id="L5087">					stream_SHARED.add(SHARED86);</span>

<span class="nc" id="L5089">					RPAREN87=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_default_clause1580);  </span>
<span class="nc" id="L5090">					stream_RPAREN.add(RPAREN87);</span>

					// AST REWRITE
					// elements: SHARED, DEFAULT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5099">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5100" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5102">					root_0 = (Object)adaptor.nil();</span>
					// 266:5: -&gt; ^( DEFAULT SHARED )
					{
						// OmpParser.g:266:8: ^( DEFAULT SHARED )
						{
<span class="nc" id="L5107">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5108">						root_1 = (Object)adaptor.becomeRoot(stream_DEFAULT.nextNode(), root_1);</span>
<span class="nc" id="L5109">						adaptor.addChild(root_1, stream_SHARED.nextNode());</span>
<span class="nc" id="L5110">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5116">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5119">					break;</span>
				case 2 :
					// OmpParser.g:267:5: DEFAULT LPAREN NONE RPAREN
					{
<span class="nc" id="L5123">					DEFAULT88=(Token)match(input,DEFAULT,FOLLOW_DEFAULT_in_default_clause1598);  </span>
<span class="nc" id="L5124">					stream_DEFAULT.add(DEFAULT88);</span>

<span class="nc" id="L5126">					LPAREN89=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_default_clause1601);  </span>
<span class="nc" id="L5127">					stream_LPAREN.add(LPAREN89);</span>

<span class="nc" id="L5129">					NONE90=(Token)match(input,NONE,FOLLOW_NONE_in_default_clause1604);  </span>
<span class="nc" id="L5130">					stream_NONE.add(NONE90);</span>

<span class="nc" id="L5132">					RPAREN91=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_default_clause1607);  </span>
<span class="nc" id="L5133">					stream_RPAREN.add(RPAREN91);</span>

					// AST REWRITE
					// elements: NONE, DEFAULT
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5142">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5143" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5145">					root_0 = (Object)adaptor.nil();</span>
					// 268:5: -&gt; ^( DEFAULT NONE )
					{
						// OmpParser.g:268:8: ^( DEFAULT NONE )
						{
<span class="nc" id="L5150">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5151">						root_1 = (Object)adaptor.becomeRoot(stream_DEFAULT.nextNode(), root_1);</span>
<span class="nc" id="L5152">						adaptor.addChild(root_1, stream_NONE.nextNode());</span>
<span class="nc" id="L5153">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5159">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L5165">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5167">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5168">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L5171">		catch (RecognitionException re) {</span>
<span class="nc" id="L5172">			reportError(re);</span>
<span class="nc" id="L5173">			recover(input,re);</span>
<span class="nc" id="L5174">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5176">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5178">		}</span>
<span class="nc" id="L5179">		return retval;</span>
	}
	// $ANTLR end &quot;default_clause&quot;


<span class="nc" id="L5184">	public static class reduction_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5187">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;reduction_clause&quot;
	// OmpParser.g:271:1: reduction_clause : REDUCTION LPAREN r= reduction_operator COLON i5= identifier_list RPAREN -&gt; ^( REDUCTION $r $i5) ;
	public final OmpParser.reduction_clause_return reduction_clause() throws RecognitionException {
<span class="nc" id="L5194">		OmpParser.reduction_clause_return retval = new OmpParser.reduction_clause_return();</span>
<span class="nc" id="L5195">		retval.start = input.LT(1);</span>

<span class="nc" id="L5197">		Object root_0 = null;</span>

<span class="nc" id="L5199">		Token REDUCTION92=null;</span>
<span class="nc" id="L5200">		Token LPAREN93=null;</span>
<span class="nc" id="L5201">		Token COLON94=null;</span>
<span class="nc" id="L5202">		Token RPAREN95=null;</span>
<span class="nc" id="L5203">		ParserRuleReturnScope r =null;</span>
<span class="nc" id="L5204">		ParserRuleReturnScope i5 =null;</span>

<span class="nc" id="L5206">		Object REDUCTION92_tree=null;</span>
<span class="nc" id="L5207">		Object LPAREN93_tree=null;</span>
<span class="nc" id="L5208">		Object COLON94_tree=null;</span>
<span class="nc" id="L5209">		Object RPAREN95_tree=null;</span>
<span class="nc" id="L5210">		RewriteRuleTokenStream stream_COLON=new RewriteRuleTokenStream(adaptor,&quot;token COLON&quot;);</span>
<span class="nc" id="L5211">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5212">		RewriteRuleTokenStream stream_REDUCTION=new RewriteRuleTokenStream(adaptor,&quot;token REDUCTION&quot;);</span>
<span class="nc" id="L5213">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5214">		RewriteRuleSubtreeStream stream_reduction_operator=new RewriteRuleSubtreeStream(adaptor,&quot;rule reduction_operator&quot;);</span>
<span class="nc" id="L5215">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:272:3: ( REDUCTION LPAREN r= reduction_operator COLON i5= identifier_list RPAREN -&gt; ^( REDUCTION $r $i5) )
			// OmpParser.g:272:5: REDUCTION LPAREN r= reduction_operator COLON i5= identifier_list RPAREN
			{
<span class="nc" id="L5221">			REDUCTION92=(Token)match(input,REDUCTION,FOLLOW_REDUCTION_in_reduction_clause1634);  </span>
<span class="nc" id="L5222">			stream_REDUCTION.add(REDUCTION92);</span>

<span class="nc" id="L5224">			LPAREN93=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_reduction_clause1636);  </span>
<span class="nc" id="L5225">			stream_LPAREN.add(LPAREN93);</span>

<span class="nc" id="L5227">			pushFollow(FOLLOW_reduction_operator_in_reduction_clause1640);</span>
<span class="nc" id="L5228">			r=reduction_operator();</span>
<span class="nc" id="L5229">			state._fsp--;</span>

<span class="nc" id="L5231">			stream_reduction_operator.add(r.getTree());</span>
<span class="nc" id="L5232">			COLON94=(Token)match(input,COLON,FOLLOW_COLON_in_reduction_clause1642);  </span>
<span class="nc" id="L5233">			stream_COLON.add(COLON94);</span>

<span class="nc" id="L5235">			pushFollow(FOLLOW_identifier_list_in_reduction_clause1646);</span>
<span class="nc" id="L5236">			i5=identifier_list();</span>
<span class="nc" id="L5237">			state._fsp--;</span>

<span class="nc" id="L5239">			stream_identifier_list.add(i5.getTree());</span>
<span class="nc" id="L5240">			RPAREN95=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_reduction_clause1648);  </span>
<span class="nc" id="L5241">			stream_RPAREN.add(RPAREN95);</span>

			// AST REWRITE
			// elements: i5, r, REDUCTION
			// token labels: 
			// rule labels: retval, r, i5
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L5250">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5251" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L5252" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,&quot;rule r&quot;,r!=null?r.getTree():null);</span>
<span class="nc bnc" id="L5253" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i5=new RewriteRuleSubtreeStream(adaptor,&quot;rule i5&quot;,i5!=null?i5.getTree():null);</span>

<span class="nc" id="L5255">			root_0 = (Object)adaptor.nil();</span>
			// 273:5: -&gt; ^( REDUCTION $r $i5)
			{
				// OmpParser.g:273:8: ^( REDUCTION $r $i5)
				{
<span class="nc" id="L5260">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5261">				root_1 = (Object)adaptor.becomeRoot(stream_REDUCTION.nextNode(), root_1);</span>
<span class="nc" id="L5262">				adaptor.addChild(root_1, stream_r.nextTree());</span>
<span class="nc" id="L5263">				adaptor.addChild(root_1, stream_i5.nextTree());</span>
<span class="nc" id="L5264">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5270">			retval.tree = root_0;</span>

			}

<span class="nc" id="L5274">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5276">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5277">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L5280">		catch (RecognitionException re) {</span>
<span class="nc" id="L5281">			reportError(re);</span>
<span class="nc" id="L5282">			recover(input,re);</span>
<span class="nc" id="L5283">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5285">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5287">		}</span>
<span class="nc" id="L5288">		return retval;</span>
	}
	// $ANTLR end &quot;reduction_clause&quot;


<span class="nc" id="L5293">	public static class copyin_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5296">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;copyin_clause&quot;
	// OmpParser.g:276:1: copyin_clause : COPYIN LPAREN i6= identifier_list RPAREN -&gt; ^( COPYIN $i6) ;
	public final OmpParser.copyin_clause_return copyin_clause() throws RecognitionException {
<span class="nc" id="L5303">		OmpParser.copyin_clause_return retval = new OmpParser.copyin_clause_return();</span>
<span class="nc" id="L5304">		retval.start = input.LT(1);</span>

<span class="nc" id="L5306">		Object root_0 = null;</span>

<span class="nc" id="L5308">		Token COPYIN96=null;</span>
<span class="nc" id="L5309">		Token LPAREN97=null;</span>
<span class="nc" id="L5310">		Token RPAREN98=null;</span>
<span class="nc" id="L5311">		ParserRuleReturnScope i6 =null;</span>

<span class="nc" id="L5313">		Object COPYIN96_tree=null;</span>
<span class="nc" id="L5314">		Object LPAREN97_tree=null;</span>
<span class="nc" id="L5315">		Object RPAREN98_tree=null;</span>
<span class="nc" id="L5316">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5317">		RewriteRuleTokenStream stream_COPYIN=new RewriteRuleTokenStream(adaptor,&quot;token COPYIN&quot;);</span>
<span class="nc" id="L5318">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5319">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:277:3: ( COPYIN LPAREN i6= identifier_list RPAREN -&gt; ^( COPYIN $i6) )
			// OmpParser.g:277:5: COPYIN LPAREN i6= identifier_list RPAREN
			{
<span class="nc" id="L5325">			COPYIN96=(Token)match(input,COPYIN,FOLLOW_COPYIN_in_copyin_clause1679);  </span>
<span class="nc" id="L5326">			stream_COPYIN.add(COPYIN96);</span>

<span class="nc" id="L5328">			LPAREN97=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_copyin_clause1682);  </span>
<span class="nc" id="L5329">			stream_LPAREN.add(LPAREN97);</span>

<span class="nc" id="L5331">			pushFollow(FOLLOW_identifier_list_in_copyin_clause1687);</span>
<span class="nc" id="L5332">			i6=identifier_list();</span>
<span class="nc" id="L5333">			state._fsp--;</span>

<span class="nc" id="L5335">			stream_identifier_list.add(i6.getTree());</span>
<span class="nc" id="L5336">			RPAREN98=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_copyin_clause1690);  </span>
<span class="nc" id="L5337">			stream_RPAREN.add(RPAREN98);</span>

			// AST REWRITE
			// elements: i6, COPYIN
			// token labels: 
			// rule labels: retval, i6
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L5346">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5347" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L5348" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i6=new RewriteRuleSubtreeStream(adaptor,&quot;rule i6&quot;,i6!=null?i6.getTree():null);</span>

<span class="nc" id="L5350">			root_0 = (Object)adaptor.nil();</span>
			// 278:5: -&gt; ^( COPYIN $i6)
			{
				// OmpParser.g:278:8: ^( COPYIN $i6)
				{
<span class="nc" id="L5355">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5356">				root_1 = (Object)adaptor.becomeRoot(stream_COPYIN.nextNode(), root_1);</span>
<span class="nc" id="L5357">				adaptor.addChild(root_1, stream_i6.nextTree());</span>
<span class="nc" id="L5358">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5364">			retval.tree = root_0;</span>

			}

<span class="nc" id="L5368">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5370">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5371">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L5374">		catch (RecognitionException re) {</span>
<span class="nc" id="L5375">			reportError(re);</span>
<span class="nc" id="L5376">			recover(input,re);</span>
<span class="nc" id="L5377">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5379">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5381">		}</span>
<span class="nc" id="L5382">		return retval;</span>
	}
	// $ANTLR end &quot;copyin_clause&quot;


<span class="nc" id="L5387">	public static class copyprivate_clause_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5390">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;copyprivate_clause&quot;
	// OmpParser.g:281:1: copyprivate_clause : COPYPRIVATE LPAREN i7= identifier_list RPAREN -&gt; ^( COPYPRIVATE $i7) ;
	public final OmpParser.copyprivate_clause_return copyprivate_clause() throws RecognitionException {
<span class="nc" id="L5397">		OmpParser.copyprivate_clause_return retval = new OmpParser.copyprivate_clause_return();</span>
<span class="nc" id="L5398">		retval.start = input.LT(1);</span>

<span class="nc" id="L5400">		Object root_0 = null;</span>

<span class="nc" id="L5402">		Token COPYPRIVATE99=null;</span>
<span class="nc" id="L5403">		Token LPAREN100=null;</span>
<span class="nc" id="L5404">		Token RPAREN101=null;</span>
<span class="nc" id="L5405">		ParserRuleReturnScope i7 =null;</span>

<span class="nc" id="L5407">		Object COPYPRIVATE99_tree=null;</span>
<span class="nc" id="L5408">		Object LPAREN100_tree=null;</span>
<span class="nc" id="L5409">		Object RPAREN101_tree=null;</span>
<span class="nc" id="L5410">		RewriteRuleTokenStream stream_RPAREN=new RewriteRuleTokenStream(adaptor,&quot;token RPAREN&quot;);</span>
<span class="nc" id="L5411">		RewriteRuleTokenStream stream_COPYPRIVATE=new RewriteRuleTokenStream(adaptor,&quot;token COPYPRIVATE&quot;);</span>
<span class="nc" id="L5412">		RewriteRuleTokenStream stream_LPAREN=new RewriteRuleTokenStream(adaptor,&quot;token LPAREN&quot;);</span>
<span class="nc" id="L5413">		RewriteRuleSubtreeStream stream_identifier_list=new RewriteRuleSubtreeStream(adaptor,&quot;rule identifier_list&quot;);</span>

		try {
			// OmpParser.g:282:3: ( COPYPRIVATE LPAREN i7= identifier_list RPAREN -&gt; ^( COPYPRIVATE $i7) )
			// OmpParser.g:282:5: COPYPRIVATE LPAREN i7= identifier_list RPAREN
			{
<span class="nc" id="L5419">			COPYPRIVATE99=(Token)match(input,COPYPRIVATE,FOLLOW_COPYPRIVATE_in_copyprivate_clause1718);  </span>
<span class="nc" id="L5420">			stream_COPYPRIVATE.add(COPYPRIVATE99);</span>

<span class="nc" id="L5422">			LPAREN100=(Token)match(input,LPAREN,FOLLOW_LPAREN_in_copyprivate_clause1721);  </span>
<span class="nc" id="L5423">			stream_LPAREN.add(LPAREN100);</span>

<span class="nc" id="L5425">			pushFollow(FOLLOW_identifier_list_in_copyprivate_clause1726);</span>
<span class="nc" id="L5426">			i7=identifier_list();</span>
<span class="nc" id="L5427">			state._fsp--;</span>

<span class="nc" id="L5429">			stream_identifier_list.add(i7.getTree());</span>
<span class="nc" id="L5430">			RPAREN101=(Token)match(input,RPAREN,FOLLOW_RPAREN_in_copyprivate_clause1729);  </span>
<span class="nc" id="L5431">			stream_RPAREN.add(RPAREN101);</span>

			// AST REWRITE
			// elements: i7, COPYPRIVATE
			// token labels: 
			// rule labels: retval, i7
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L5440">			retval.tree = root_0;</span>
<span class="nc bnc" id="L5441" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>
<span class="nc bnc" id="L5442" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_i7=new RewriteRuleSubtreeStream(adaptor,&quot;rule i7&quot;,i7!=null?i7.getTree():null);</span>

<span class="nc" id="L5444">			root_0 = (Object)adaptor.nil();</span>
			// 283:5: -&gt; ^( COPYPRIVATE $i7)
			{
				// OmpParser.g:283:8: ^( COPYPRIVATE $i7)
				{
<span class="nc" id="L5449">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5450">				root_1 = (Object)adaptor.becomeRoot(stream_COPYPRIVATE.nextNode(), root_1);</span>
<span class="nc" id="L5451">				adaptor.addChild(root_1, stream_i7.nextTree());</span>
<span class="nc" id="L5452">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5458">			retval.tree = root_0;</span>

			}

<span class="nc" id="L5462">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5464">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5465">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L5468">		catch (RecognitionException re) {</span>
<span class="nc" id="L5469">			reportError(re);</span>
<span class="nc" id="L5470">			recover(input,re);</span>
<span class="nc" id="L5471">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5473">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5475">		}</span>
<span class="nc" id="L5476">		return retval;</span>
	}
	// $ANTLR end &quot;copyprivate_clause&quot;


<span class="nc" id="L5481">	public static class reduction_operator_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5484">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;reduction_operator&quot;
	// OmpParser.g:286:1: reduction_operator : ( PLUS -&gt; ^( PLUS ) | STAR -&gt; ^( STAR ) | SUB -&gt; ^( SUB ) | AMPERSAND -&gt; ^( AMPERSAND ) | BITXOR -&gt; ^( BITXOR ) | BITOR -&gt; ^( BITOR ) | AND -&gt; ^( AND ) | OR -&gt; ^( OR ) | IDENTIFIER -&gt; ^( IDENTIFIER ) );
	public final OmpParser.reduction_operator_return reduction_operator() throws RecognitionException {
<span class="nc" id="L5491">		OmpParser.reduction_operator_return retval = new OmpParser.reduction_operator_return();</span>
<span class="nc" id="L5492">		retval.start = input.LT(1);</span>

<span class="nc" id="L5494">		Object root_0 = null;</span>

<span class="nc" id="L5496">		Token PLUS102=null;</span>
<span class="nc" id="L5497">		Token STAR103=null;</span>
<span class="nc" id="L5498">		Token SUB104=null;</span>
<span class="nc" id="L5499">		Token AMPERSAND105=null;</span>
<span class="nc" id="L5500">		Token BITXOR106=null;</span>
<span class="nc" id="L5501">		Token BITOR107=null;</span>
<span class="nc" id="L5502">		Token AND108=null;</span>
<span class="nc" id="L5503">		Token OR109=null;</span>
<span class="nc" id="L5504">		Token IDENTIFIER110=null;</span>

<span class="nc" id="L5506">		Object PLUS102_tree=null;</span>
<span class="nc" id="L5507">		Object STAR103_tree=null;</span>
<span class="nc" id="L5508">		Object SUB104_tree=null;</span>
<span class="nc" id="L5509">		Object AMPERSAND105_tree=null;</span>
<span class="nc" id="L5510">		Object BITXOR106_tree=null;</span>
<span class="nc" id="L5511">		Object BITOR107_tree=null;</span>
<span class="nc" id="L5512">		Object AND108_tree=null;</span>
<span class="nc" id="L5513">		Object OR109_tree=null;</span>
<span class="nc" id="L5514">		Object IDENTIFIER110_tree=null;</span>
<span class="nc" id="L5515">		RewriteRuleTokenStream stream_AMPERSAND=new RewriteRuleTokenStream(adaptor,&quot;token AMPERSAND&quot;);</span>
<span class="nc" id="L5516">		RewriteRuleTokenStream stream_SUB=new RewriteRuleTokenStream(adaptor,&quot;token SUB&quot;);</span>
<span class="nc" id="L5517">		RewriteRuleTokenStream stream_PLUS=new RewriteRuleTokenStream(adaptor,&quot;token PLUS&quot;);</span>
<span class="nc" id="L5518">		RewriteRuleTokenStream stream_STAR=new RewriteRuleTokenStream(adaptor,&quot;token STAR&quot;);</span>
<span class="nc" id="L5519">		RewriteRuleTokenStream stream_BITOR=new RewriteRuleTokenStream(adaptor,&quot;token BITOR&quot;);</span>
<span class="nc" id="L5520">		RewriteRuleTokenStream stream_AND=new RewriteRuleTokenStream(adaptor,&quot;token AND&quot;);</span>
<span class="nc" id="L5521">		RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,&quot;token IDENTIFIER&quot;);</span>
<span class="nc" id="L5522">		RewriteRuleTokenStream stream_OR=new RewriteRuleTokenStream(adaptor,&quot;token OR&quot;);</span>
<span class="nc" id="L5523">		RewriteRuleTokenStream stream_BITXOR=new RewriteRuleTokenStream(adaptor,&quot;token BITXOR&quot;);</span>

		try {
			// OmpParser.g:287:3: ( PLUS -&gt; ^( PLUS ) | STAR -&gt; ^( STAR ) | SUB -&gt; ^( SUB ) | AMPERSAND -&gt; ^( AMPERSAND ) | BITXOR -&gt; ^( BITXOR ) | BITOR -&gt; ^( BITOR ) | AND -&gt; ^( AND ) | OR -&gt; ^( OR ) | IDENTIFIER -&gt; ^( IDENTIFIER ) )
<span class="nc" id="L5527">			int alt24=9;</span>
<span class="nc bnc" id="L5528" title="All 10 branches missed.">			switch ( input.LA(1) ) {</span>
			case PLUS:
				{
<span class="nc" id="L5531">				alt24=1;</span>
				}
<span class="nc" id="L5533">				break;</span>
			case STAR:
				{
<span class="nc" id="L5536">				alt24=2;</span>
				}
<span class="nc" id="L5538">				break;</span>
			case SUB:
				{
<span class="nc" id="L5541">				alt24=3;</span>
				}
<span class="nc" id="L5543">				break;</span>
			case AMPERSAND:
				{
<span class="nc" id="L5546">				alt24=4;</span>
				}
<span class="nc" id="L5548">				break;</span>
			case BITXOR:
				{
<span class="nc" id="L5551">				alt24=5;</span>
				}
<span class="nc" id="L5553">				break;</span>
			case BITOR:
				{
<span class="nc" id="L5556">				alt24=6;</span>
				}
<span class="nc" id="L5558">				break;</span>
			case AND:
				{
<span class="nc" id="L5561">				alt24=7;</span>
				}
<span class="nc" id="L5563">				break;</span>
			case OR:
				{
<span class="nc" id="L5566">				alt24=8;</span>
				}
<span class="nc" id="L5568">				break;</span>
			case IDENTIFIER:
				{
<span class="nc" id="L5571">				alt24=9;</span>
				}
<span class="nc" id="L5573">				break;</span>
			default:
<span class="nc" id="L5575">				NoViableAltException nvae =</span>
					new NoViableAltException(&quot;&quot;, 24, 0, input);
<span class="nc" id="L5577">				throw nvae;</span>
			}
<span class="nc bnc" id="L5579" title="All 10 branches missed.">			switch (alt24) {</span>
				case 1 :
					// OmpParser.g:287:5: PLUS
					{
<span class="nc" id="L5583">					PLUS102=(Token)match(input,PLUS,FOLLOW_PLUS_in_reduction_operator1755);  </span>
<span class="nc" id="L5584">					stream_PLUS.add(PLUS102);</span>

					// AST REWRITE
					// elements: PLUS
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5593">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5594" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5596">					root_0 = (Object)adaptor.nil();</span>
					// 287:10: -&gt; ^( PLUS )
					{
						// OmpParser.g:287:13: ^( PLUS )
						{
<span class="nc" id="L5601">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5602">						root_1 = (Object)adaptor.becomeRoot(stream_PLUS.nextNode(), root_1);</span>
<span class="nc" id="L5603">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5609">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5612">					break;</span>
				case 2 :
					// OmpParser.g:288:5: STAR
					{
<span class="nc" id="L5616">					STAR103=(Token)match(input,STAR,FOLLOW_STAR_in_reduction_operator1767);  </span>
<span class="nc" id="L5617">					stream_STAR.add(STAR103);</span>

					// AST REWRITE
					// elements: STAR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5626">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5627" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5629">					root_0 = (Object)adaptor.nil();</span>
					// 288:10: -&gt; ^( STAR )
					{
						// OmpParser.g:288:13: ^( STAR )
						{
<span class="nc" id="L5634">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5635">						root_1 = (Object)adaptor.becomeRoot(stream_STAR.nextNode(), root_1);</span>
<span class="nc" id="L5636">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5642">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5645">					break;</span>
				case 3 :
					// OmpParser.g:289:5: SUB
					{
<span class="nc" id="L5649">					SUB104=(Token)match(input,SUB,FOLLOW_SUB_in_reduction_operator1779);  </span>
<span class="nc" id="L5650">					stream_SUB.add(SUB104);</span>

					// AST REWRITE
					// elements: SUB
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5659">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5660" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5662">					root_0 = (Object)adaptor.nil();</span>
					// 289:9: -&gt; ^( SUB )
					{
						// OmpParser.g:289:12: ^( SUB )
						{
<span class="nc" id="L5667">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5668">						root_1 = (Object)adaptor.becomeRoot(stream_SUB.nextNode(), root_1);</span>
<span class="nc" id="L5669">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5675">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5678">					break;</span>
				case 4 :
					// OmpParser.g:290:5: AMPERSAND
					{
<span class="nc" id="L5682">					AMPERSAND105=(Token)match(input,AMPERSAND,FOLLOW_AMPERSAND_in_reduction_operator1791);  </span>
<span class="nc" id="L5683">					stream_AMPERSAND.add(AMPERSAND105);</span>

					// AST REWRITE
					// elements: AMPERSAND
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5692">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5693" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5695">					root_0 = (Object)adaptor.nil();</span>
					// 290:15: -&gt; ^( AMPERSAND )
					{
						// OmpParser.g:290:18: ^( AMPERSAND )
						{
<span class="nc" id="L5700">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5701">						root_1 = (Object)adaptor.becomeRoot(stream_AMPERSAND.nextNode(), root_1);</span>
<span class="nc" id="L5702">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5708">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5711">					break;</span>
				case 5 :
					// OmpParser.g:291:5: BITXOR
					{
<span class="nc" id="L5715">					BITXOR106=(Token)match(input,BITXOR,FOLLOW_BITXOR_in_reduction_operator1803);  </span>
<span class="nc" id="L5716">					stream_BITXOR.add(BITXOR106);</span>

					// AST REWRITE
					// elements: BITXOR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5725">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5726" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5728">					root_0 = (Object)adaptor.nil();</span>
					// 291:12: -&gt; ^( BITXOR )
					{
						// OmpParser.g:291:15: ^( BITXOR )
						{
<span class="nc" id="L5733">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5734">						root_1 = (Object)adaptor.becomeRoot(stream_BITXOR.nextNode(), root_1);</span>
<span class="nc" id="L5735">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5741">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5744">					break;</span>
				case 6 :
					// OmpParser.g:292:5: BITOR
					{
<span class="nc" id="L5748">					BITOR107=(Token)match(input,BITOR,FOLLOW_BITOR_in_reduction_operator1815);  </span>
<span class="nc" id="L5749">					stream_BITOR.add(BITOR107);</span>

					// AST REWRITE
					// elements: BITOR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5758">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5759" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5761">					root_0 = (Object)adaptor.nil();</span>
					// 292:11: -&gt; ^( BITOR )
					{
						// OmpParser.g:292:14: ^( BITOR )
						{
<span class="nc" id="L5766">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5767">						root_1 = (Object)adaptor.becomeRoot(stream_BITOR.nextNode(), root_1);</span>
<span class="nc" id="L5768">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5774">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5777">					break;</span>
				case 7 :
					// OmpParser.g:293:5: AND
					{
<span class="nc" id="L5781">					AND108=(Token)match(input,AND,FOLLOW_AND_in_reduction_operator1827);  </span>
<span class="nc" id="L5782">					stream_AND.add(AND108);</span>

					// AST REWRITE
					// elements: AND
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5791">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5792" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5794">					root_0 = (Object)adaptor.nil();</span>
					// 293:9: -&gt; ^( AND )
					{
						// OmpParser.g:293:12: ^( AND )
						{
<span class="nc" id="L5799">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5800">						root_1 = (Object)adaptor.becomeRoot(stream_AND.nextNode(), root_1);</span>
<span class="nc" id="L5801">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5807">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5810">					break;</span>
				case 8 :
					// OmpParser.g:294:5: OR
					{
<span class="nc" id="L5814">					OR109=(Token)match(input,OR,FOLLOW_OR_in_reduction_operator1839);  </span>
<span class="nc" id="L5815">					stream_OR.add(OR109);</span>

					// AST REWRITE
					// elements: OR
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5824">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5825" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5827">					root_0 = (Object)adaptor.nil();</span>
					// 294:8: -&gt; ^( OR )
					{
						// OmpParser.g:294:11: ^( OR )
						{
<span class="nc" id="L5832">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5833">						root_1 = (Object)adaptor.becomeRoot(stream_OR.nextNode(), root_1);</span>
<span class="nc" id="L5834">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5840">					retval.tree = root_0;</span>

					}
<span class="nc" id="L5843">					break;</span>
				case 9 :
					// OmpParser.g:295:5: IDENTIFIER
					{
<span class="nc" id="L5847">					IDENTIFIER110=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_reduction_operator1851);  </span>
<span class="nc" id="L5848">					stream_IDENTIFIER.add(IDENTIFIER110);</span>

					// AST REWRITE
					// elements: IDENTIFIER
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
<span class="nc" id="L5857">					retval.tree = root_0;</span>
<span class="nc bnc" id="L5858" title="All 2 branches missed.">					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5860">					root_0 = (Object)adaptor.nil();</span>
					// 295:16: -&gt; ^( IDENTIFIER )
					{
						// OmpParser.g:295:19: ^( IDENTIFIER )
						{
<span class="nc" id="L5865">						Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5866">						root_1 = (Object)adaptor.becomeRoot(stream_IDENTIFIER.nextNode(), root_1);</span>
<span class="nc" id="L5867">						adaptor.addChild(root_0, root_1);</span>
						}

					}


<span class="nc" id="L5873">					retval.tree = root_0;</span>

					}
					break;

			}
<span class="nc" id="L5879">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5881">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5882">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L5885">		catch (RecognitionException re) {</span>
<span class="nc" id="L5886">			reportError(re);</span>
<span class="nc" id="L5887">			recover(input,re);</span>
<span class="nc" id="L5888">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L5890">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L5892">		}</span>
<span class="nc" id="L5893">		return retval;</span>
	}
	// $ANTLR end &quot;reduction_operator&quot;


<span class="nc" id="L5898">	public static class identifier_list_return extends ParserRuleReturnScope {</span>
		Object tree;
		@Override
<span class="nc" id="L5901">		public Object getTree() { return tree; }</span>
	};


	// $ANTLR start &quot;identifier_list&quot;
	// OmpParser.g:298:1: identifier_list : i1= IDENTIFIER ( COMMA i2+= IDENTIFIER )* -&gt; ^( IDENTIFIER_LIST $i1 ( $i2)* ) ;
	public final OmpParser.identifier_list_return identifier_list() throws RecognitionException {
<span class="nc" id="L5908">		OmpParser.identifier_list_return retval = new OmpParser.identifier_list_return();</span>
<span class="nc" id="L5909">		retval.start = input.LT(1);</span>

<span class="nc" id="L5911">		Object root_0 = null;</span>

<span class="nc" id="L5913">		Token i1=null;</span>
<span class="nc" id="L5914">		Token COMMA111=null;</span>
<span class="nc" id="L5915">		Token i2=null;</span>
<span class="nc" id="L5916">		List&lt;Object&gt; list_i2=null;</span>

<span class="nc" id="L5918">		Object i1_tree=null;</span>
<span class="nc" id="L5919">		Object COMMA111_tree=null;</span>
<span class="nc" id="L5920">		Object i2_tree=null;</span>
<span class="nc" id="L5921">		RewriteRuleTokenStream stream_COMMA=new RewriteRuleTokenStream(adaptor,&quot;token COMMA&quot;);</span>
<span class="nc" id="L5922">		RewriteRuleTokenStream stream_IDENTIFIER=new RewriteRuleTokenStream(adaptor,&quot;token IDENTIFIER&quot;);</span>

		try {
			// OmpParser.g:299:3: (i1= IDENTIFIER ( COMMA i2+= IDENTIFIER )* -&gt; ^( IDENTIFIER_LIST $i1 ( $i2)* ) )
			// OmpParser.g:300:3: i1= IDENTIFIER ( COMMA i2+= IDENTIFIER )*
			{
<span class="nc" id="L5928">			i1=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_identifier_list1874);  </span>
<span class="nc" id="L5929">			stream_IDENTIFIER.add(i1);</span>

			// OmpParser.g:300:17: ( COMMA i2+= IDENTIFIER )*
			loop25:
			while (true) {
<span class="nc" id="L5934">				int alt25=2;</span>
<span class="nc" id="L5935">				int LA25_0 = input.LA(1);</span>
<span class="nc bnc" id="L5936" title="All 2 branches missed.">				if ( (LA25_0==COMMA) ) {</span>
<span class="nc" id="L5937">					alt25=1;</span>
				}

<span class="nc bnc" id="L5940" title="All 2 branches missed.">				switch (alt25) {</span>
				case 1 :
					// OmpParser.g:300:19: COMMA i2+= IDENTIFIER
					{
<span class="nc" id="L5944">					COMMA111=(Token)match(input,COMMA,FOLLOW_COMMA_in_identifier_list1878);  </span>
<span class="nc" id="L5945">					stream_COMMA.add(COMMA111);</span>

<span class="nc" id="L5947">					i2=(Token)match(input,IDENTIFIER,FOLLOW_IDENTIFIER_in_identifier_list1883);  </span>
<span class="nc" id="L5948">					stream_IDENTIFIER.add(i2);</span>

<span class="nc bnc" id="L5950" title="All 2 branches missed.">					if (list_i2==null) list_i2=new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L5951">					list_i2.add(i2);</span>
					}
<span class="nc" id="L5953">					break;</span>

				default :
<span class="nc" id="L5956">					break loop25;</span>
				}
<span class="nc" id="L5958">			}</span>

			// AST REWRITE
			// elements: i2, i1
			// token labels: i1
			// rule labels: retval
			// token list labels: i2
			// rule list labels: 
			// wildcard labels: 
<span class="nc" id="L5967">			retval.tree = root_0;</span>
<span class="nc" id="L5968">			RewriteRuleTokenStream stream_i1=new RewriteRuleTokenStream(adaptor,&quot;token i1&quot;,i1);</span>
<span class="nc" id="L5969">			RewriteRuleTokenStream stream_i2=new RewriteRuleTokenStream(adaptor,&quot;token i2&quot;, list_i2);</span>
<span class="nc bnc" id="L5970" title="All 2 branches missed.">			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,&quot;rule retval&quot;,retval!=null?retval.getTree():null);</span>

<span class="nc" id="L5972">			root_0 = (Object)adaptor.nil();</span>
			// 301:3: -&gt; ^( IDENTIFIER_LIST $i1 ( $i2)* )
			{
				// OmpParser.g:301:6: ^( IDENTIFIER_LIST $i1 ( $i2)* )
				{
<span class="nc" id="L5977">				Object root_1 = (Object)adaptor.nil();</span>
<span class="nc" id="L5978">				root_1 = (Object)adaptor.becomeRoot((Object)adaptor.create(IDENTIFIER_LIST, &quot;IDENTIFIER_LIST&quot;), root_1);</span>
<span class="nc" id="L5979">				adaptor.addChild(root_1, stream_i1.nextNode());</span>
				// OmpParser.g:301:29: ( $i2)*
<span class="nc bnc" id="L5981" title="All 2 branches missed.">				while ( stream_i2.hasNext() ) {</span>
<span class="nc" id="L5982">					adaptor.addChild(root_1, stream_i2.nextNode());</span>
				}
<span class="nc" id="L5984">				stream_i2.reset();</span>

<span class="nc" id="L5986">				adaptor.addChild(root_0, root_1);</span>
				}

			}


<span class="nc" id="L5992">			retval.tree = root_0;</span>

			}

<span class="nc" id="L5996">			retval.stop = input.LT(-1);</span>

<span class="nc" id="L5998">			retval.tree = (Object)adaptor.rulePostProcessing(root_0);</span>
<span class="nc" id="L5999">			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);</span>

		}
<span class="nc" id="L6002">		catch (RecognitionException re) {</span>
<span class="nc" id="L6003">			reportError(re);</span>
<span class="nc" id="L6004">			recover(input,re);</span>
<span class="nc" id="L6005">			retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);</span>
		}
<span class="nc" id="L6007">		finally {</span>
			// do for sure before leaving
<span class="nc" id="L6009">		}</span>
<span class="nc" id="L6010">		return retval;</span>
	}
	// $ANTLR end &quot;identifier_list&quot;

	// Delegated rules
<span class="nc" id="L6015">	public OmpParser_CivlCParser.typeSpecifierOrQualifier_return typeSpecifierOrQualifier() throws RecognitionException { return gCivlCParser.typeSpecifierOrQualifier(); }</span>

<span class="nc" id="L6017">	public OmpParser_CivlCParser.initializer_return initializer() throws RecognitionException { return gCivlCParser.initializer(); }</span>

<span class="nc" id="L6019">	public OmpParser_CivlCParser.postfixExpression_return postfixExpression() throws RecognitionException { return gCivlCParser.postfixExpression(); }</span>

<span class="nc" id="L6021">	public OmpParser_CivlCParser.declaratorOrAbstractDeclarator_return declaratorOrAbstractDeclarator() throws RecognitionException { return gCivlCParser.declaratorOrAbstractDeclarator(); }</span>

<span class="nc" id="L6023">	public OmpParser_CivlCParser.translationUnit_return translationUnit() throws RecognitionException { return gCivlCParser.translationUnit(); }</span>

<span class="nc" id="L6025">	public OmpParser_CivlCParser.castExpression_return castExpression() throws RecognitionException { return gCivlCParser.castExpression(); }</span>

<span class="nc" id="L6027">	public OmpParser_CivlCParser.genericAssociation_return genericAssociation() throws RecognitionException { return gCivlCParser.genericAssociation(); }</span>

<span class="nc" id="L6029">	public OmpParser_CivlCParser.structDeclarationList_return structDeclarationList() throws RecognitionException { return gCivlCParser.structDeclarationList(); }</span>

<span class="nc" id="L6031">	public OmpParser_CivlCParser.conditionalExpression_return conditionalExpression() throws RecognitionException { return gCivlCParser.conditionalExpression(); }</span>

<span class="nc" id="L6033">	public OmpParser_CivlCParser.contract_return contract() throws RecognitionException { return gCivlCParser.contract(); }</span>

<span class="nc" id="L6035">	public OmpParser_CivlCParser.porItem_return porItem() throws RecognitionException { return gCivlCParser.porItem(); }</span>

<span class="nc" id="L6037">	public OmpParser_CivlCParser.initDeclarator_return initDeclarator() throws RecognitionException { return gCivlCParser.initDeclarator(); }</span>

<span class="nc" id="L6039">	public OmpParser_CivlCParser.quantifier_return quantifier() throws RecognitionException { return gCivlCParser.quantifier(); }</span>

<span class="nc" id="L6041">	public OmpParser_CivlCParser.designatedInitializer_return designatedInitializer() throws RecognitionException { return gCivlCParser.designatedInitializer(); }</span>

<span class="nc" id="L6043">	public OmpParser_CivlCParser.parameterTypeListWithScope_return parameterTypeListWithScope() throws RecognitionException { return gCivlCParser.parameterTypeListWithScope(); }</span>

<span class="nc" id="L6045">	public OmpParser_CivlCParser.postfixExpressionRoot_return postfixExpressionRoot() throws RecognitionException { return gCivlCParser.postfixExpressionRoot(); }</span>

<span class="nc" id="L6047">	public OmpParser_CivlCParser.callsExpression_return callsExpression() throws RecognitionException { return gCivlCParser.callsExpression(); }</span>

<span class="nc" id="L6049">	public OmpParser_CivlCParser.quantifierExpression_return quantifierExpression() throws RecognitionException { return gCivlCParser.quantifierExpression(); }</span>

<span class="nc" id="L6051">	public OmpParser_CivlCParser.unaryOperator_return unaryOperator() throws RecognitionException { return gCivlCParser.unaryOperator(); }</span>

<span class="nc" id="L6053">	public OmpParser_CivlCParser.rangeExpression_return rangeExpression() throws RecognitionException { return gCivlCParser.rangeExpression(); }</span>

<span class="nc" id="L6055">	public OmpParser_CivlCParser.blockItem_return blockItem() throws RecognitionException { return gCivlCParser.blockItem(); }</span>

<span class="nc" id="L6057">	public OmpParser_CivlCParser.argumentExpressionList_return argumentExpressionList() throws RecognitionException { return gCivlCParser.argumentExpressionList(); }</span>

<span class="nc" id="L6059">	public OmpParser_CivlCParser.directAbstractDeclarator_return directAbstractDeclarator() throws RecognitionException { return gCivlCParser.directAbstractDeclarator(); }</span>

<span class="nc" id="L6061">	public OmpParser_CivlCParser.structOrUnionSpecifier_return structOrUnionSpecifier() throws RecognitionException { return gCivlCParser.structOrUnionSpecifier(); }</span>

<span class="nc" id="L6063">	public OmpParser_CivlCParser.chooseStatement_return chooseStatement() throws RecognitionException { return gCivlCParser.chooseStatement(); }</span>

<span class="nc" id="L6065">	public OmpParser_CivlCParser.expressionStatement_return expressionStatement() throws RecognitionException { return gCivlCParser.expressionStatement(); }</span>

<span class="nc" id="L6067">	public OmpParser_CivlCParser.atomicTypeSpecifier_return atomicTypeSpecifier() throws RecognitionException { return gCivlCParser.atomicTypeSpecifier(); }</span>

<span class="nc" id="L6069">	public OmpParser_CivlCParser.parameterTypeList_return parameterTypeList() throws RecognitionException { return gCivlCParser.parameterTypeList(); }</span>

<span class="nc" id="L6071">	public OmpParser_CivlCParser.assignmentOperator_return assignmentOperator() throws RecognitionException { return gCivlCParser.assignmentOperator(); }</span>

<span class="nc" id="L6073">	public OmpParser_CivlCParser.shiftExpression_return shiftExpression() throws RecognitionException { return gCivlCParser.shiftExpression(); }</span>

<span class="nc" id="L6075">	public OmpParser_CivlCParser.equalityOperator_return equalityOperator() throws RecognitionException { return gCivlCParser.equalityOperator(); }</span>

<span class="nc" id="L6077">	public OmpParser_CivlCParser.enumeratorList_return enumeratorList() throws RecognitionException { return gCivlCParser.enumeratorList(); }</span>

<span class="nc" id="L6079">	public OmpParser_CivlCParser.declarationSpecifiers_return declarationSpecifiers() throws RecognitionException { return gCivlCParser.declarationSpecifiers(); }</span>

<span class="nc" id="L6081">	public OmpParser_CivlCParser.declarationSpecifierList_return declarationSpecifierList() throws RecognitionException { return gCivlCParser.declarationSpecifierList(); }</span>

<span class="nc" id="L6083">	public OmpParser_CivlCParser.storageClassSpecifier_return storageClassSpecifier() throws RecognitionException { return gCivlCParser.storageClassSpecifier(); }</span>

<span class="nc" id="L6085">	public OmpParser_CivlCParser.statementWithScope_return statementWithScope() throws RecognitionException { return gCivlCParser.statementWithScope(); }</span>

<span class="nc" id="L6087">	public OmpParser_CivlCParser.atomicStatement_return atomicStatement() throws RecognitionException { return gCivlCParser.atomicStatement(); }</span>

<span class="nc" id="L6089">	public OmpParser_CivlCParser.structDeclarator_return structDeclarator() throws RecognitionException { return gCivlCParser.structDeclarator(); }</span>

<span class="nc" id="L6091">	public OmpParser_CivlCParser.pointer_part_return pointer_part() throws RecognitionException { return gCivlCParser.pointer_part(); }</span>

<span class="nc" id="L6093">	public OmpParser_CivlCParser.inclusiveOrExpression_return inclusiveOrExpression() throws RecognitionException { return gCivlCParser.inclusiveOrExpression(); }</span>

<span class="nc" id="L6095">	public OmpParser_CivlCParser.invariant_opt_return invariant_opt() throws RecognitionException { return gCivlCParser.invariant_opt(); }</span>

<span class="nc" id="L6097">	public OmpParser_CivlCParser.partial_return partial() throws RecognitionException { return gCivlCParser.partial(); }</span>

<span class="nc" id="L6099">	public OmpParser_CivlCParser.designatorList_return designatorList() throws RecognitionException { return gCivlCParser.designatorList(); }</span>

<span class="nc" id="L6101">	public OmpParser_CivlCParser.genericSelection_return genericSelection() throws RecognitionException { return gCivlCParser.genericSelection(); }</span>

<span class="nc" id="L6103">	public OmpParser_CivlCParser.directDeclaratorArraySuffix_return directDeclaratorArraySuffix() throws RecognitionException { return gCivlCParser.directDeclaratorArraySuffix(); }</span>

<span class="nc" id="L6105">	public OmpParser_CivlCParser.directDeclaratorPrefix_return directDeclaratorPrefix() throws RecognitionException { return gCivlCParser.directDeclaratorPrefix(); }</span>

<span class="nc" id="L6107">	public OmpParser_CivlCParser.statement_return statement() throws RecognitionException { return gCivlCParser.statement(); }</span>

<span class="nc" id="L6109">	public OmpParser_CivlCParser.abstractDeclarator_return abstractDeclarator() throws RecognitionException { return gCivlCParser.abstractDeclarator(); }</span>

<span class="nc" id="L6111">	public OmpParser_CivlCParser.compoundStatement_return compoundStatement() throws RecognitionException { return gCivlCParser.compoundStatement(); }</span>

<span class="nc" id="L6113">	public OmpParser_CivlCParser.structDeclaration_return structDeclaration() throws RecognitionException { return gCivlCParser.structDeclaration(); }</span>

<span class="nc" id="L6115">	public OmpParser_CivlCParser.whenStatement_return whenStatement() throws RecognitionException { return gCivlCParser.whenStatement(); }</span>

<span class="nc" id="L6117">	public OmpParser_CivlCParser.selectionStatement_return selectionStatement() throws RecognitionException { return gCivlCParser.selectionStatement(); }</span>

<span class="nc" id="L6119">	public OmpParser_CivlCParser.derivativeExpression_return derivativeExpression() throws RecognitionException { return gCivlCParser.derivativeExpression(); }</span>

<span class="nc" id="L6121">	public OmpParser_CivlCParser.primaryExpression_return primaryExpression() throws RecognitionException { return gCivlCParser.primaryExpression(); }</span>

<span class="nc" id="L6123">	public OmpParser_CivlCParser.expression_return expression() throws RecognitionException { return gCivlCParser.expression(); }</span>

<span class="nc" id="L6125">	public OmpParser_CivlCParser.typeName_opt_return typeName_opt() throws RecognitionException { return gCivlCParser.typeName_opt(); }</span>

<span class="nc" id="L6127">	public OmpParser_CivlCParser.directDeclaratorFunctionSuffix_return directDeclaratorFunctionSuffix() throws RecognitionException { return gCivlCParser.directDeclaratorFunctionSuffix(); }</span>

<span class="nc" id="L6129">	public OmpParser_CivlCParser.typeQualifierList_opt_return typeQualifierList_opt() throws RecognitionException { return gCivlCParser.typeQualifierList_opt(); }</span>

<span class="nc" id="L6131">	public OmpParser_CivlCParser.assignmentExpression_return assignmentExpression() throws RecognitionException { return gCivlCParser.assignmentExpression(); }</span>

<span class="nc" id="L6133">	public OmpParser_CivlCParser.enumerator_return enumerator() throws RecognitionException { return gCivlCParser.enumerator(); }</span>

<span class="nc" id="L6135">	public OmpParser_CivlCParser.spawnExpression_return spawnExpression() throws RecognitionException { return gCivlCParser.spawnExpression(); }</span>

<span class="nc" id="L6137">	public OmpParser_CivlCParser.functionDefinition_return functionDefinition() throws RecognitionException { return gCivlCParser.functionDefinition(); }</span>

<span class="nc" id="L6139">	public OmpParser_CivlCParser.assignmentExpression_opt_return assignmentExpression_opt() throws RecognitionException { return gCivlCParser.assignmentExpression_opt(); }</span>

<span class="nc" id="L6141">	public OmpParser_CivlCParser.partialList_return partialList() throws RecognitionException { return gCivlCParser.partialList(); }</span>

<span class="nc" id="L6143">	public OmpParser_CivlCParser.relationalExpression_return relationalExpression() throws RecognitionException { return gCivlCParser.relationalExpression(); }</span>

<span class="nc" id="L6145">	public OmpParser_CivlCParser.enumSpecifier_return enumSpecifier() throws RecognitionException { return gCivlCParser.enumSpecifier(); }</span>

<span class="nc" id="L6147">	public OmpParser_CivlCParser.directDeclarator_return directDeclarator() throws RecognitionException { return gCivlCParser.directDeclarator(); }</span>

<span class="nc" id="L6149">	public OmpParser_CivlCParser.commaExpression_return commaExpression() throws RecognitionException { return gCivlCParser.commaExpression(); }</span>

<span class="nc" id="L6151">	public OmpParser_CivlCParser.additiveExpression_return additiveExpression() throws RecognitionException { return gCivlCParser.additiveExpression(); }</span>

<span class="nc" id="L6153">	public OmpParser_CivlCParser.relationalOperator_return relationalOperator() throws RecognitionException { return gCivlCParser.relationalOperator(); }</span>

<span class="nc" id="L6155">	public OmpParser_CivlCParser.iterationStatement_return iterationStatement() throws RecognitionException { return gCivlCParser.iterationStatement(); }</span>

<span class="nc" id="L6157">	public OmpParser_CivlCParser.parameterList_return parameterList() throws RecognitionException { return gCivlCParser.parameterList(); }</span>

<span class="nc" id="L6159">	public OmpParser_CivlCParser.datomicStatement_return datomicStatement() throws RecognitionException { return gCivlCParser.datomicStatement(); }</span>

<span class="nc" id="L6161">	public OmpParser_CivlCParser.designator_return designator() throws RecognitionException { return gCivlCParser.designator(); }</span>

<span class="nc" id="L6163">	public OmpParser_CivlCParser.designation_return designation() throws RecognitionException { return gCivlCParser.designation(); }</span>

<span class="nc" id="L6165">	public OmpParser_CivlCParser.pragmaBody_return pragmaBody() throws RecognitionException { return gCivlCParser.pragmaBody(); }</span>

<span class="nc" id="L6167">	public OmpParser_CivlCParser.specifierQualifierList_return specifierQualifierList() throws RecognitionException { return gCivlCParser.specifierQualifierList(); }</span>

<span class="nc" id="L6169">	public OmpParser_CivlCParser.typeofSpecifier_return typeofSpecifier() throws RecognitionException { return gCivlCParser.typeofSpecifier(); }</span>

<span class="nc" id="L6171">	public OmpParser_CivlCParser.remoteExpression_return remoteExpression() throws RecognitionException { return gCivlCParser.remoteExpression(); }</span>

<span class="nc" id="L6173">	public OmpParser_CivlCParser.staticAssertDeclaration_return staticAssertDeclaration() throws RecognitionException { return gCivlCParser.staticAssertDeclaration(); }</span>

<span class="nc" id="L6175">	public OmpParser_CivlCParser.jumpStatement_return jumpStatement() throws RecognitionException { return gCivlCParser.jumpStatement(); }</span>

<span class="nc" id="L6177">	public OmpParser_CivlCParser.typeQualifier_return typeQualifier() throws RecognitionException { return gCivlCParser.typeQualifier(); }</span>

<span class="nc" id="L6179">	public OmpParser_CivlCParser.labeledStatement_return labeledStatement() throws RecognitionException { return gCivlCParser.labeledStatement(); }</span>

<span class="nc" id="L6181">	public OmpParser_CivlCParser.typeName_return typeName() throws RecognitionException { return gCivlCParser.typeName(); }</span>

<span class="nc" id="L6183">	public OmpParser_CivlCParser.enumerationConstant_return enumerationConstant() throws RecognitionException { return gCivlCParser.enumerationConstant(); }</span>

<span class="nc" id="L6185">	public OmpParser_CivlCParser.blockItemWithScope_return blockItemWithScope() throws RecognitionException { return gCivlCParser.blockItemWithScope(); }</span>

<span class="nc" id="L6187">	public OmpParser_CivlCParser.pragma_return pragma() throws RecognitionException { return gCivlCParser.pragma(); }</span>

<span class="nc" id="L6189">	public OmpParser_CivlCParser.contractItem_return contractItem() throws RecognitionException { return gCivlCParser.contractItem(); }</span>

<span class="nc" id="L6191">	public OmpParser_CivlCParser.typeSpecifier_return typeSpecifier() throws RecognitionException { return gCivlCParser.typeSpecifier(); }</span>

<span class="nc" id="L6193">	public OmpParser_CivlCParser.constantExpression_return constantExpression() throws RecognitionException { return gCivlCParser.constantExpression(); }</span>

<span class="nc" id="L6195">	public OmpParser_CivlCParser.structDeclaratorList_return structDeclaratorList() throws RecognitionException { return gCivlCParser.structDeclaratorList(); }</span>

<span class="nc" id="L6197">	public OmpParser_CivlCParser.identifierList_return identifierList() throws RecognitionException { return gCivlCParser.identifierList(); }</span>

<span class="nc" id="L6199">	public OmpParser_CivlCParser.typedefName_return typedefName() throws RecognitionException { return gCivlCParser.typedefName(); }</span>

<span class="nc" id="L6201">	public OmpParser_CivlCParser.directDeclaratorSuffix_return directDeclaratorSuffix() throws RecognitionException { return gCivlCParser.directDeclaratorSuffix(); }</span>

<span class="nc" id="L6203">	public OmpParser_CivlCParser.functionSpecifier_return functionSpecifier() throws RecognitionException { return gCivlCParser.functionSpecifier(); }</span>

<span class="nc" id="L6205">	public OmpParser_CivlCParser.exclusiveOrExpression_return exclusiveOrExpression() throws RecognitionException { return gCivlCParser.exclusiveOrExpression(); }</span>

<span class="nc" id="L6207">	public OmpParser_CivlCParser.parameterDeclaration_return parameterDeclaration() throws RecognitionException { return gCivlCParser.parameterDeclaration(); }</span>

<span class="nc" id="L6209">	public OmpParser_CivlCParser.initDeclaratorList_return initDeclaratorList() throws RecognitionException { return gCivlCParser.initDeclaratorList(); }</span>

<span class="nc" id="L6211">	public OmpParser_CivlCParser.declarationList_opt_return declarationList_opt() throws RecognitionException { return gCivlCParser.declarationList_opt(); }</span>

<span class="nc" id="L6213">	public OmpParser_CivlCParser.structOrUnion_return structOrUnion() throws RecognitionException { return gCivlCParser.structOrUnion(); }</span>

<span class="nc" id="L6215">	public OmpParser_CivlCParser.multiplicativeExpression_return multiplicativeExpression() throws RecognitionException { return gCivlCParser.multiplicativeExpression(); }</span>

<span class="nc" id="L6217">	public OmpParser_CivlCParser.typeQualifierList_return typeQualifierList() throws RecognitionException { return gCivlCParser.typeQualifierList(); }</span>

<span class="nc" id="L6219">	public OmpParser_CivlCParser.logicalOrExpression_return logicalOrExpression() throws RecognitionException { return gCivlCParser.logicalOrExpression(); }</span>

<span class="nc" id="L6221">	public OmpParser_CivlCParser.logicalAndExpression_return logicalAndExpression() throws RecognitionException { return gCivlCParser.logicalAndExpression(); }</span>

<span class="nc" id="L6223">	public OmpParser_CivlCParser.alignmentSpecifier_return alignmentSpecifier() throws RecognitionException { return gCivlCParser.alignmentSpecifier(); }</span>

<span class="nc" id="L6225">	public OmpParser_CivlCParser.constant_return constant() throws RecognitionException { return gCivlCParser.constant(); }</span>

<span class="nc" id="L6227">	public OmpParser_CivlCParser.pointer_return pointer() throws RecognitionException { return gCivlCParser.pointer(); }</span>

<span class="nc" id="L6229">	public OmpParser_CivlCParser.equalityExpression_return equalityExpression() throws RecognitionException { return gCivlCParser.equalityExpression(); }</span>

<span class="nc" id="L6231">	public OmpParser_CivlCParser.declarator_return declarator() throws RecognitionException { return gCivlCParser.declarator(); }</span>

<span class="nc" id="L6233">	public OmpParser_CivlCParser.initializerList_return initializerList() throws RecognitionException { return gCivlCParser.initializerList(); }</span>

<span class="nc" id="L6235">	public OmpParser_CivlCParser.expression_opt_return expression_opt() throws RecognitionException { return gCivlCParser.expression_opt(); }</span>

<span class="nc" id="L6237">	public OmpParser_CivlCParser.andExpression_return andExpression() throws RecognitionException { return gCivlCParser.andExpression(); }</span>

<span class="nc" id="L6239">	public OmpParser_CivlCParser.logicalImpliesExpression_return logicalImpliesExpression() throws RecognitionException { return gCivlCParser.logicalImpliesExpression(); }</span>

<span class="nc" id="L6241">	public OmpParser_CivlCParser.blockItemList_return blockItemList() throws RecognitionException { return gCivlCParser.blockItemList(); }</span>

<span class="nc" id="L6243">	public OmpParser_CivlCParser.declarationSpecifier_return declarationSpecifier() throws RecognitionException { return gCivlCParser.declarationSpecifier(); }</span>

<span class="nc" id="L6245">	public OmpParser_CivlCParser.directAbstractDeclaratorSuffix_return directAbstractDeclaratorSuffix() throws RecognitionException { return gCivlCParser.directAbstractDeclaratorSuffix(); }</span>

<span class="nc" id="L6247">	public OmpParser_CivlCParser.genericAssocList_return genericAssocList() throws RecognitionException { return gCivlCParser.genericAssocList(); }</span>

<span class="nc" id="L6249">	public OmpParser_CivlCParser.separationLogicItem_return separationLogicItem() throws RecognitionException { return gCivlCParser.separationLogicItem(); }</span>

<span class="nc" id="L6251">	public OmpParser_CivlCParser.domainSpecifier_return domainSpecifier() throws RecognitionException { return gCivlCParser.domainSpecifier(); }</span>

<span class="nc" id="L6253">	public OmpParser_CivlCParser.parameterTypeListWithoutScope_return parameterTypeListWithoutScope() throws RecognitionException { return gCivlCParser.parameterTypeListWithoutScope(); }</span>

<span class="nc" id="L6255">	public OmpParser_CivlCParser.unaryExpression_return unaryExpression() throws RecognitionException { return gCivlCParser.unaryExpression(); }</span>

<span class="nc" id="L6257">	public OmpParser_CivlCParser.declaration_return declaration() throws RecognitionException { return gCivlCParser.declaration(); }</span>



<span class="nc" id="L6261">	public static final BitSet FOLLOW_parallel_for_directive_in_openmp_construct96 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6262">	public static final BitSet FOLLOW_parallel_sections_directive_in_openmp_construct102 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6263">	public static final BitSet FOLLOW_parallel_directive_in_openmp_construct108 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6264">	public static final BitSet FOLLOW_for_directive_in_openmp_construct114 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6265">	public static final BitSet FOLLOW_sections_directive_in_openmp_construct120 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6266">	public static final BitSet FOLLOW_single_directive_in_openmp_construct126 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6267">	public static final BitSet FOLLOW_master_directive_in_openmp_construct132 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6268">	public static final BitSet FOLLOW_critical_directive_in_openmp_construct138 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6269">	public static final BitSet FOLLOW_ordered_directive_in_openmp_construct144 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6270">	public static final BitSet FOLLOW_section_directive_in_openmp_construct150 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6271">	public static final BitSet FOLLOW_ompatomic_directive_in_openmp_construct156 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6272">	public static final BitSet FOLLOW_barrier_directive_in_openmp_construct162 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6273">	public static final BitSet FOLLOW_flush_directive_in_openmp_construct168 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6274">	public static final BitSet FOLLOW_threadprivate_directive_in_openmp_construct174 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6275">	public static final BitSet FOLLOW_PARALLEL_in_parallel_directive187 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000288A300000L});</span>
<span class="nc" id="L6276">	public static final BitSet FOLLOW_parallel_clause_in_parallel_directive193 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000288A300000L});</span>
<span class="nc" id="L6277">	public static final BitSet FOLLOW_unique_parallel_clause_in_parallel_clause220 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6278">	public static final BitSet FOLLOW_data_clause_in_parallel_clause226 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6279">	public static final BitSet FOLLOW_MASTER_in_master_directive241 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6280">	public static final BitSet FOLLOW_CRITICAL_in_critical_directive260 = new BitSet(new long[]{0x0000000000000002L,0x0000010000000000L});</span>
<span class="nc" id="L6281">	public static final BitSet FOLLOW_LPAREN_in_critical_directive264 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6282">	public static final BitSet FOLLOW_IDENTIFIER_in_critical_directive269 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6283">	public static final BitSet FOLLOW_RPAREN_in_critical_directive272 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6284">	public static final BitSet FOLLOW_SECTIONS_in_sections_directive301 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000284A300000L});</span>
<span class="nc" id="L6285">	public static final BitSet FOLLOW_sections_clause_in_sections_directive307 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000284A300000L});</span>
<span class="nc" id="L6286">	public static final BitSet FOLLOW_data_clause_in_sections_clause334 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6287">	public static final BitSet FOLLOW_nowait_directive_in_sections_clause340 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6288">	public static final BitSet FOLLOW_SECTION_in_section_directive353 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6289">	public static final BitSet FOLLOW_PARALLEL_in_parallel_for_directive374 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000020L});</span>
<span class="nc" id="L6290">	public static final BitSet FOLLOW_FOR_in_parallel_for_directive376 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000AA8A380000L});</span>
<span class="nc" id="L6291">	public static final BitSet FOLLOW_parallel_for_clause_in_parallel_for_directive380 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000AA8A380000L});</span>
<span class="nc" id="L6292">	public static final BitSet FOLLOW_unique_parallel_clause_in_parallel_for_clause408 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6293">	public static final BitSet FOLLOW_unique_for_clause_in_parallel_for_clause414 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6294">	public static final BitSet FOLLOW_data_clause_in_parallel_for_clause420 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6295">	public static final BitSet FOLLOW_PARALLEL_in_parallel_sections_directive433 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000020000000000L});</span>
<span class="nc" id="L6296">	public static final BitSet FOLLOW_SECTIONS_in_parallel_sections_directive436 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000288A300000L});</span>
<span class="nc" id="L6297">	public static final BitSet FOLLOW_parallel_sections_clause_in_parallel_sections_directive441 = new BitSet(new long[]{0x0000020000000002L,0x0000000008000000L,0x0000002000000000L,0x0000000000000000L,0x000000288A300000L});</span>
<span class="nc" id="L6298">	public static final BitSet FOLLOW_unique_parallel_clause_in_parallel_sections_clause469 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6299">	public static final BitSet FOLLOW_data_clause_in_parallel_sections_clause475 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6300">	public static final BitSet FOLLOW_SINGLE_in_single_directive488 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000284A300000L});</span>
<span class="nc" id="L6301">	public static final BitSet FOLLOW_single_clause_in_single_directive493 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000284A300000L});</span>
<span class="nc" id="L6302">	public static final BitSet FOLLOW_data_clause_in_single_clause521 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6303">	public static final BitSet FOLLOW_nowait_directive_in_single_clause527 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6304">	public static final BitSet FOLLOW_BARRIER_in_barrier_directive540 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6305">	public static final BitSet FOLLOW_OMPATOMIC_in_ompatomic_directive561 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000641000040000L});</span>
<span class="nc" id="L6306">	public static final BitSet FOLLOW_atomic_clasue_in_ompatomic_directive565 = new BitSet(new long[]{0x0000000000000002L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000040000000000L});</span>
<span class="nc" id="L6307">	public static final BitSet FOLLOW_seq_cst_clause_in_ompatomic_directive570 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6308">	public static final BitSet FOLLOW_SEQ_CST_in_seq_cst_clause629 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6309">	public static final BitSet FOLLOW_FLUSH_in_flush_directive642 = new BitSet(new long[]{0x0000000000000002L,0x0000010000000000L});</span>
<span class="nc" id="L6310">	public static final BitSet FOLLOW_flush_vars_in_flush_directive647 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6311">	public static final BitSet FOLLOW_LPAREN_in_flush_vars675 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6312">	public static final BitSet FOLLOW_identifier_list_in_flush_vars681 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6313">	public static final BitSet FOLLOW_RPAREN_in_flush_vars684 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6314">	public static final BitSet FOLLOW_ORDERED_in_ordered_directive710 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6315">	public static final BitSet FOLLOW_NOWAIT_in_nowait_directive731 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6316">	public static final BitSet FOLLOW_THD_PRIVATE_in_threadprivate_directive750 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6317">	public static final BitSet FOLLOW_LPAREN_in_threadprivate_directive753 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6318">	public static final BitSet FOLLOW_identifier_list_in_threadprivate_directive758 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6319">	public static final BitSet FOLLOW_RPAREN_in_threadprivate_directive761 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6320">	public static final BitSet FOLLOW_FOR_in_for_directive787 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000AA4A380000L});</span>
<span class="nc" id="L6321">	public static final BitSet FOLLOW_for_clause_in_for_directive793 = new BitSet(new long[]{0x0000020000000002L,0x0000000000000000L,0x0000002000000000L,0x0000000000000000L,0x000000AA4A380000L});</span>
<span class="nc" id="L6322">	public static final BitSet FOLLOW_unique_for_clause_in_for_clause824 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6323">	public static final BitSet FOLLOW_data_clause_in_for_clause841 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6324">	public static final BitSet FOLLOW_nowait_directive_in_for_clause858 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6325">	public static final BitSet FOLLOW_ORDERED_in_unique_for_clause880 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6326">	public static final BitSet FOLLOW_schedule_clause_in_unique_for_clause895 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6327">	public static final BitSet FOLLOW_collapse_clause_in_unique_for_clause912 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6328">	public static final BitSet FOLLOW_SCHEDULE_in_schedule_clause935 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6329">	public static final BitSet FOLLOW_LPAREN_in_schedule_clause938 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L,0x0000000000000000L,0x0000004004800000L});</span>
<span class="nc" id="L6330">	public static final BitSet FOLLOW_schedule_kind_in_schedule_clause943 = new BitSet(new long[]{0x0000000800000000L});</span>
<span class="nc" id="L6331">	public static final BitSet FOLLOW_COMMA_in_schedule_clause946 = new BitSet(new long[]{0x21001002110080C0L,0x0020810204040252L,0x2614700A08012800L,0x0000000000001000L});</span>
<span class="nc" id="L6332">	public static final BitSet FOLLOW_expression_in_schedule_clause951 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6333">	public static final BitSet FOLLOW_RPAREN_in_schedule_clause954 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6334">	public static final BitSet FOLLOW_SCHEDULE_in_schedule_clause981 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6335">	public static final BitSet FOLLOW_LPAREN_in_schedule_clause984 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0001000000000000L,0x0000000000000000L,0x0000004004800000L});</span>
<span class="nc" id="L6336">	public static final BitSet FOLLOW_schedule_kind_in_schedule_clause989 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6337">	public static final BitSet FOLLOW_RPAREN_in_schedule_clause992 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6338">	public static final BitSet FOLLOW_COLLAPSE_in_collapse_clause1017 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6339">	public static final BitSet FOLLOW_LPAREN_in_collapse_clause1020 = new BitSet(new long[]{0x0000000000000000L,0x0000000200000000L});</span>
<span class="nc" id="L6340">	public static final BitSet FOLLOW_INTEGER_CONSTANT_in_collapse_clause1025 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6341">	public static final BitSet FOLLOW_RPAREN_in_collapse_clause1028 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6342">	public static final BitSet FOLLOW_STATIC_in_schedule_kind1053 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6343">	public static final BitSet FOLLOW_DYNAMIC_in_schedule_kind1065 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6344">	public static final BitSet FOLLOW_GUIDED_in_schedule_kind1077 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6345">	public static final BitSet FOLLOW_RUNTIME_in_schedule_kind1089 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6346">	public static final BitSet FOLLOW_if_clause_in_unique_parallel_clause1110 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6347">	public static final BitSet FOLLOW_num_threads_clause_in_unique_parallel_clause1132 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6348">	public static final BitSet FOLLOW_IF_in_if_clause1161 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6349">	public static final BitSet FOLLOW_LPAREN_in_if_clause1164 = new BitSet(new long[]{0x21001002110080C0L,0x0020810204040252L,0x2614700A08012800L,0x0000000000001000L});</span>
<span class="nc" id="L6350">	public static final BitSet FOLLOW_expression_in_if_clause1169 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6351">	public static final BitSet FOLLOW_RPAREN_in_if_clause1172 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6352">	public static final BitSet FOLLOW_NUM_THREADS_in_num_threads_clause1200 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6353">	public static final BitSet FOLLOW_LPAREN_in_num_threads_clause1203 = new BitSet(new long[]{0x21001002110080C0L,0x0020810204040252L,0x2614700A08012800L,0x0000000000001000L});</span>
<span class="nc" id="L6354">	public static final BitSet FOLLOW_expression_in_num_threads_clause1208 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6355">	public static final BitSet FOLLOW_RPAREN_in_num_threads_clause1211 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6356">	public static final BitSet FOLLOW_private_clause_in_data_clause1239 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6357">	public static final BitSet FOLLOW_firstprivate_clause_in_data_clause1260 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6358">	public static final BitSet FOLLOW_lastprivate_clause_in_data_clause1281 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6359">	public static final BitSet FOLLOW_shared_clause_in_data_clause1302 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6360">	public static final BitSet FOLLOW_default_clause_in_data_clause1323 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6361">	public static final BitSet FOLLOW_reduction_clause_in_data_clause1344 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6362">	public static final BitSet FOLLOW_copyin_clause_in_data_clause1365 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6363">	public static final BitSet FOLLOW_copyprivate_clause_in_data_clause1386 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6364">	public static final BitSet FOLLOW_PRIVATE_in_private_clause1414 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6365">	public static final BitSet FOLLOW_LPAREN_in_private_clause1417 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6366">	public static final BitSet FOLLOW_identifier_list_in_private_clause1422 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6367">	public static final BitSet FOLLOW_RPAREN_in_private_clause1425 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6368">	public static final BitSet FOLLOW_FST_PRIVATE_in_firstprivate_clause1454 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6369">	public static final BitSet FOLLOW_LPAREN_in_firstprivate_clause1457 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6370">	public static final BitSet FOLLOW_identifier_list_in_firstprivate_clause1462 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6371">	public static final BitSet FOLLOW_RPAREN_in_firstprivate_clause1465 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6372">	public static final BitSet FOLLOW_LST_PRIVATE_in_lastprivate_clause1493 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6373">	public static final BitSet FOLLOW_LPAREN_in_lastprivate_clause1496 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6374">	public static final BitSet FOLLOW_identifier_list_in_lastprivate_clause1501 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6375">	public static final BitSet FOLLOW_RPAREN_in_lastprivate_clause1504 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6376">	public static final BitSet FOLLOW_SHARED_in_shared_clause1532 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6377">	public static final BitSet FOLLOW_LPAREN_in_shared_clause1535 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6378">	public static final BitSet FOLLOW_identifier_list_in_shared_clause1540 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6379">	public static final BitSet FOLLOW_RPAREN_in_shared_clause1543 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6380">	public static final BitSet FOLLOW_DEFAULT_in_default_clause1571 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6381">	public static final BitSet FOLLOW_LPAREN_in_default_clause1574 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000002000000000L});</span>
<span class="nc" id="L6382">	public static final BitSet FOLLOW_SHARED_in_default_clause1577 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6383">	public static final BitSet FOLLOW_RPAREN_in_default_clause1580 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6384">	public static final BitSet FOLLOW_DEFAULT_in_default_clause1598 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6385">	public static final BitSet FOLLOW_LPAREN_in_default_clause1601 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000000000000L,0x0000000020000000L});</span>
<span class="nc" id="L6386">	public static final BitSet FOLLOW_NONE_in_default_clause1604 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6387">	public static final BitSet FOLLOW_RPAREN_in_default_clause1607 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6388">	public static final BitSet FOLLOW_REDUCTION_in_reduction_clause1634 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6389">	public static final BitSet FOLLOW_LPAREN_in_reduction_clause1636 = new BitSet(new long[]{0x00000000000A0180L,0x0400000004000000L,0x0010400000000800L});</span>
<span class="nc" id="L6390">	public static final BitSet FOLLOW_reduction_operator_in_reduction_clause1640 = new BitSet(new long[]{0x0000000400000000L});</span>
<span class="nc" id="L6391">	public static final BitSet FOLLOW_COLON_in_reduction_clause1642 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6392">	public static final BitSet FOLLOW_identifier_list_in_reduction_clause1646 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6393">	public static final BitSet FOLLOW_RPAREN_in_reduction_clause1648 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6394">	public static final BitSet FOLLOW_COPYIN_in_copyin_clause1679 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6395">	public static final BitSet FOLLOW_LPAREN_in_copyin_clause1682 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6396">	public static final BitSet FOLLOW_identifier_list_in_copyin_clause1687 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6397">	public static final BitSet FOLLOW_RPAREN_in_copyin_clause1690 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6398">	public static final BitSet FOLLOW_COPYPRIVATE_in_copyprivate_clause1718 = new BitSet(new long[]{0x0000000000000000L,0x0000010000000000L});</span>
<span class="nc" id="L6399">	public static final BitSet FOLLOW_LPAREN_in_copyprivate_clause1721 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6400">	public static final BitSet FOLLOW_identifier_list_in_copyprivate_clause1726 = new BitSet(new long[]{0x0000000000000000L,0x0000000000000000L,0x0000000040000000L});</span>
<span class="nc" id="L6401">	public static final BitSet FOLLOW_RPAREN_in_copyprivate_clause1729 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6402">	public static final BitSet FOLLOW_PLUS_in_reduction_operator1755 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6403">	public static final BitSet FOLLOW_STAR_in_reduction_operator1767 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6404">	public static final BitSet FOLLOW_SUB_in_reduction_operator1779 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6405">	public static final BitSet FOLLOW_AMPERSAND_in_reduction_operator1791 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6406">	public static final BitSet FOLLOW_BITXOR_in_reduction_operator1803 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6407">	public static final BitSet FOLLOW_BITOR_in_reduction_operator1815 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6408">	public static final BitSet FOLLOW_AND_in_reduction_operator1827 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6409">	public static final BitSet FOLLOW_OR_in_reduction_operator1839 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6410">	public static final BitSet FOLLOW_IDENTIFIER_in_reduction_operator1851 = new BitSet(new long[]{0x0000000000000002L});</span>
<span class="nc" id="L6411">	public static final BitSet FOLLOW_IDENTIFIER_in_identifier_list1874 = new BitSet(new long[]{0x0000000800000002L});</span>
<span class="nc" id="L6412">	public static final BitSet FOLLOW_COMMA_in_identifier_list1878 = new BitSet(new long[]{0x0000000000000000L,0x0000000004000000L});</span>
<span class="nc" id="L6413">	public static final BitSet FOLLOW_IDENTIFIER_in_identifier_list1883 = new BitSet(new long[]{0x0000000800000002L});</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>